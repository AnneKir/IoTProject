"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../..");
const __2 = require("../..");
class Buffer {
    constructor(capacity, limit, position, mark) {
        this._cap = 0;
        this._limit = 0;
        this._pos = 0;
        this._mark = -1;
        if (capacity < 0)
            throw new __1.IllegalArgumentException('Negative capacity');
        this._cap = capacity;
        this.limit(limit);
        this.position(position);
        if (mark >= 0) {
            if (mark > this._pos)
                throw new __1.IllegalArgumentException('Mark is greater than current position');
            this._mark = mark;
        }
    }
    capacity() {
        return this._cap;
    }
    clear() {
        this._limit = this._cap;
        this._pos = 0;
        this._mark = -1;
        return this;
    }
    flip() {
        this._limit = this._pos;
        this._pos = 0;
        this._mark = -1;
        return this;
    }
    hasRemaining() {
        return this.remaining() > 0;
    }
    limit(newLimit) {
        if (!newLimit)
            return this._limit;
        if ((newLimit < 0) || (newLimit > this._cap))
            throw new __1.IllegalArgumentException('New limit out of bound');
        if (newLimit < this._mark)
            this._mark = -1;
        if (this._pos > newLimit)
            this._pos = newLimit;
        this._limit = newLimit;
        return this;
    }
    mark() {
        this._mark = this._pos;
        return this;
    }
    position(newPosition) {
        if (newPosition === undefined)
            return this._pos;
        if ((newPosition < 0) || (newPosition > this._limit))
            throw new __1.IllegalArgumentException('New position out of bound');
        if (newPosition <= this._mark)
            this._mark = -1;
        this._pos = newPosition;
        return this;
    }
    remaining() {
        return this._limit - this._pos;
    }
    reset() {
        if (this._mark === -1)
            throw new __2.InvalidMarkException();
        this._pos = this._mark;
        return this;
    }
    rewind() {
        this._pos = 0;
        this._mark = -1;
        return this;
    }
}
exports.Buffer = Buffer;
//# sourceMappingURL=buffer.js.map