"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../..");
const __2 = require("../..");
const __3 = require("../..");
const TsQDecorator_1 = require("../../tsQ/decorator/TsQDecorator");
class Map {
    constructor() {
        this._entries = [];
    }
    clear() {
        this._entries.length = 0;
    }
    compute(key, remappingFunction) {
        let oldValue = this.get(key);
        let newValue = remappingFunction.apply(key, oldValue);
        if (oldValue !== null) {
            if (newValue !== null) {
                return this.put(key, newValue);
            }
            else {
                return this.remove(key);
            }
        }
        else {
            if (newValue !== null) {
                return this.put(key, newValue);
            }
            else {
                return null;
            }
        }
    }
    computeIfAbsent(key, mappingFunction) {
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        if (this.get(key) === null) {
            let newValue = mappingFunction.apply(key);
            if (newValue !== null)
                return this.put(key, newValue);
        }
    }
    computeIfPresent(key, v) {
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        if (this.get(key) !== null) {
            let oldValue = this.get(key);
            let newValue = v.apply(key, oldValue);
            if (newValue !== null)
                return this.put(key, newValue);
            else
                return this.remove(key);
        }
    }
    containsKey(key) {
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        return this._entries.find((entry) => {
            return entry.getKey() === key;
        }) !== undefined;
    }
    containsValue(value) {
        if (value === null || value === undefined)
            throw new __1.NullReferenceException('The value cannot be null nor undefined');
        return this._entries.find((entry) => {
            return entry.getValue() === value;
        }) !== undefined;
    }
    entrySet() {
        let set = new __2.Set();
        set.addAll(this._entries);
        return set;
    }
    equals(m) {
        return this.entrySet().equals(m.entrySet());
    }
    forEach(callback) {
        this._entries = this._entries.map(mapEntry => callback.apply(mapEntry));
    }
    get(key) {
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        try {
            return this._entries
                .find((mapEntry) => mapEntry.getKey() === key)
                .getValue();
        }
        catch (e) {
            return null;
        }
    }
    getOrDefault(key, defaultValue) {
        let get = this.get(key);
        if (get) {
            return get;
        }
        else {
            return defaultValue;
        }
    }
    hashCode() {
        return this.entrySet().toArray().reduce((accumulator, mapEntry) => {
            return accumulator + mapEntry.hashCode();
        }, 0);
    }
    isEmpty() {
        return this._entries.length === 0;
    }
    keySet() {
        return this._entries.reduce((set, mapEntry) => {
            set.add(mapEntry.getKey());
            return set;
        }, new __2.Set());
    }
    merge(key, value, remappingFunction) {
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        let oldValue = this.get(key);
        let newValue = (oldValue === null) ? value : remappingFunction.apply(oldValue, value);
        if (newValue === null) {
            this.remove(key);
        }
        else {
            this.put(key, newValue);
            return newValue;
        }
    }
    put(key, value) {
        let previousValue = null;
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        if (this.containsKey(key))
            this._entries = this._entries
                .map((mapEntry) => {
                if (mapEntry.getKey() === key)
                    previousValue = mapEntry.setValue(value);
                return mapEntry;
            });
        else
            this._entries.push(new __3.MapEntry(key, value));
        return previousValue;
    }
    putAll(m) {
        m.entrySet()
            .toArray()
            .forEach((mapEntry) => this.put(mapEntry.getKey(), mapEntry.getValue()));
    }
    putIfAbsent(key, value) {
        if (key === null || key === undefined)
            throw new __1.NullReferenceException('The key cannot be null nor undefined');
        let v = this.get(key);
        if (v === null)
            v = this.put(key, value);
        return v;
    }
    remove(key, value) {
        if (value)
            if (this.containsKey(key) && this.get(key) === value) {
                this.remove(key);
                return true;
            }
            else {
                return false;
            }
        else {
            if (key === null || key === undefined)
                throw new __1.NullReferenceException('The key cannot be null nor undefined');
            let length = this._entries.length;
            this._entries = this._entries
                .filter((mapEntry) => mapEntry.getKey() !== key);
            return this._entries.length !== length;
        }
    }
    replace(key, value, newValue) {
        if (newValue)
            if (this.containsKey(key) && this.get(key) === value) {
                this.put(key, newValue);
                return true;
            }
            else {
                return false;
            }
        else {
            if (key === null || key === undefined)
                throw new __1.NullReferenceException('The key cannot be null nor undefined');
            if (this.containsKey(key)) {
                return this.put(key, value);
            }
            else {
                return null;
            }
        }
    }
    replaceAll(f) {
        if (f === null || f === undefined)
            throw new __1.NullReferenceException('The function cannot be null nor undefined');
        this.entrySet().toArray().forEach((mapEntry) => {
            mapEntry.setValue(f.apply(mapEntry.getKey(), mapEntry.getValue()));
        });
    }
    size() {
        return this._entries.length;
    }
    values() {
        return this._entries
            .map((mapEntry) => mapEntry.getValue());
    }
}
__decorate([
    TsQDecorator_1.TsQ()
], Map.prototype, "values", null);
exports.Map = Map;
//# sourceMappingURL=map.js.map