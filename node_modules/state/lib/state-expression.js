// Generated by CoffeeScript 1.6.3
(function() {
  var GUARD_ACTIONS, O, STATE_ATTRIBUTES, STATE_ATTRIBUTE_MODIFIERS, STATE_EVENT_TYPES, STATE_EXPRESSION_CATEGORIES, STATE_EXPRESSION_CATEGORY_SYNONYMS, State, StateExpression, TransitionExpression, state,
    __hasProp = {}.hasOwnProperty;

  O = require('omicron');

  state = require('./state-function');

  State = require('./state');

  TransitionExpression = require('./transition-expression');

  STATE_ATTRIBUTES = state.STATE_ATTRIBUTES, STATE_ATTRIBUTE_MODIFIERS = state.STATE_ATTRIBUTE_MODIFIERS, STATE_EXPRESSION_CATEGORIES = state.STATE_EXPRESSION_CATEGORIES, STATE_EXPRESSION_CATEGORY_SYNONYMS = state.STATE_EXPRESSION_CATEGORY_SYNONYMS, STATE_EVENT_TYPES = state.STATE_EVENT_TYPES, GUARD_ACTIONS = state.GUARD_ACTIONS;

  module.exports = StateExpression = (function() {
    var NIL, NORMAL, assign, attributeFlags, attributeMap, categoryMap, clone, decode, edit, encode, eventTypes, guardActions, interpret, invert, isArray, isNumber, isPlainObject, synonymMap, untype;

    NIL = O.NIL, isNumber = O.isNumber, isPlainObject = O.isPlainObject, isArray = O.isArray;

    assign = O.assign, edit = O.edit, clone = O.clone, invert = O.invert;

    NORMAL = STATE_ATTRIBUTES.NORMAL;

    attributeMap = (function() {
      var key, object, value, _ref;
      _ref = object = assign(STATE_ATTRIBUTE_MODIFIERS);
      for (key in _ref) {
        value = _ref[key];
        object[key] = key.toUpperCase();
      }
      return object;
    })();

    attributeFlags = (function() {
      var key, object, value, _ref;
      _ref = object = invert(STATE_ATTRIBUTES);
      for (key in _ref) {
        value = _ref[key];
        object[key] = value.toLowerCase();
      }
      return object;
    })();

    categoryMap = assign(STATE_EXPRESSION_CATEGORIES);

    synonymMap = STATE_EXPRESSION_CATEGORY_SYNONYMS;

    eventTypes = assign(STATE_EVENT_TYPES);

    guardActions = assign(GUARD_ACTIONS);

    function StateExpression(attributes, expr) {
      if (typeof attributes === 'string') {
        expr || (expr = {});
      } else if (expr == null) {
        expr = attributes;
        attributes = void 0;
      }
      if (!(expr instanceof StateExpression)) {
        expr = interpret(expr);
      }
      edit('deep all', this, expr);
      if (attributes != null) {
        if (!isNumber(attributes)) {
          attributes = encode(attributes);
        }
      } else {
        if (expr) {
          attributes = expr.attributes;
        }
      }
      this.attributes = attributes || NORMAL;
    }

    interpret = function(expr) {
      var category, item, key, object, result, type, value, _ref, _ref1, _ref2, _ref3;
      result = assign(STATE_EXPRESSION_CATEGORIES, null);
      for (key in expr) {
        if (!__hasProp.call(expr, key)) continue;
        value = expr[key];
        category = categoryMap[key] || synonymMap[key];
        if ((category != null) && (value != null)) {
          result[category] = typeof value === 'string' ? value : isArray(value) ? value.slice(0) : clone(result[category], value);
          continue;
        }
        category = value === state || value instanceof StateExpression ? 'substates' : value instanceof TransitionExpression ? 'transitions' : void 0;
        if (category != null) {
          item = result[category] || (result[category] = {});
          item[key] = value;
          continue;
        }
        category = (eventTypes[key] != null) || typeof value === 'string' ? 'events' : guardActions[key] != null ? 'guards' : typeof value === 'function' || (type = value != null ? value.type : void 0) && (type === 'state-bound-function' || type === 'state-fixed-function') ? 'methods' : value === NIL || isPlainObject(value) ? 'substates' : void 0;
        if (category != null) {
          item = result[category] || (result[category] = {});
          item[key] = value;
          continue;
        }
      }
      _ref = object = result.events;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (!isArray(value)) {
          object[key] = [value];
        }
      }
      _ref1 = object = result.guards;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        value = _ref1[key];
        if (!isPlainObject(value)) {
          object[key] = {
            '*': value
          };
        }
      }
      _ref2 = object = result.transitions;
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        if (!(value === NIL || value instanceof TransitionExpression)) {
          object[key] = new TransitionExpression(value);
        }
      }
      _ref3 = object = result.substates;
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        value = _ref3[key];
        if (value === state) {
          object[key] = new StateExpression;
        } else if (value instanceof State) {
          object[key] = value.express(true);
        } else if (!(value === NIL || value instanceof StateExpression)) {
          object[key] = new StateExpression(value);
        }
      }
      return result;
    };

    encode = function(attributes) {
      var key, result, value;
      if (typeof attributes === 'string') {
        attributes = assign(attributes);
      }
      result = NORMAL;
      for (key in attributes) {
        if (!__hasProp.call(attributes, key)) continue;
        value = attributes[key];
        if (key in attributeMap) {
          result |= STATE_ATTRIBUTES[attributeMap[key]];
        }
      }
      return result;
    };

    decode = function(number) {
      var key, value;
      return ((function() {
        var _results;
        _results = [];
        for (key in attributeFlags) {
          value = attributeFlags[key];
          if (number & key) {
            _results.push(value);
          }
        }
        return _results;
      })()).join(' ');
    };

    StateExpression.untype = untype = function(expr) {
      var key, name, result, s, subexpr, value, _ref;
      result = {};
      for (key in expr) {
        if (!__hasProp.call(expr, key)) continue;
        value = expr[key];
        result[key] = value;
      }
      _ref = s = result.states;
      for (name in _ref) {
        subexpr = _ref[name];
        s[name] = untype(subexpr);
      }
      return result;
    };

    StateExpression.encodeAttributes = encode;

    StateExpression.decodeAttributes = decode;

    return StateExpression;

  })();

}).call(this);
