{"ast":null,"code":"import { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nexport function debounce(durationSelector) {\n  return operate(function (source, subscriber) {\n    var hasValue = false;\n    var lastValue = null;\n    var durationSubscriber = null;\n    var emit = function emit() {\n      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        hasValue = false;\n        var value = lastValue;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n      hasValue = true;\n      lastValue = value;\n      durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\n      innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n    }, function () {\n      emit();\n      subscriber.complete();\n    }, undefined, function () {\n      lastValue = durationSubscriber = null;\n    }));\n  });\n}","map":{"version":3,"mappings":"AAEA,SAASA,OAAO,QAAQ,cAAc;AACtC,SAASC,IAAI,QAAQ,cAAc;AACnC,SAASC,wBAAwB,QAAQ,sBAAsB;AAC/D,SAASC,SAAS,QAAQ,yBAAyB;AA4DnD,OAAM,SAAUC,QAAQ,CAAIC,gBAAoD;EAC9E,OAAOL,OAAO,CAAC,UAACM,MAAM,EAAEC,UAAU;IAChC,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIC,SAAS,GAAa,IAAI;IAE9B,IAAIC,kBAAkB,GAA2B,IAAI;IAErD,IAAMC,IAAI,GAAG,SAAPA,IAAI,GAAG;MAIXD,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEE,WAAW,EAAE;MACjCF,kBAAkB,GAAG,IAAI;MACzB,IAAIF,QAAQ,EAAE;QAEZA,QAAQ,GAAG,KAAK;QAChB,IAAMK,KAAK,GAAGJ,SAAU;QACxBA,SAAS,GAAG,IAAI;QAChBF,UAAU,CAACO,IAAI,CAACD,KAAK,CAAC;;IAE1B,CAAC;IAEDP,MAAM,CAACS,SAAS,CACdb,wBAAwB,CACtBK,UAAU,EACV,UAACM,KAAQ;MAIPH,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAEE,WAAW,EAAE;MACjCJ,QAAQ,GAAG,IAAI;MACfC,SAAS,GAAGI,KAAK;MAGjBH,kBAAkB,GAAGR,wBAAwB,CAACK,UAAU,EAAEI,IAAI,EAAEV,IAAI,CAAC;MAErEE,SAAS,CAACE,gBAAgB,CAACQ,KAAK,CAAC,CAAC,CAACE,SAAS,CAACL,kBAAkB,CAAC;IAClE,CAAC,EACD;MAGEC,IAAI,EAAE;MACNJ,UAAU,CAACS,QAAQ,EAAE;IACvB,CAAC,EAEDC,SAAS,EACT;MAEER,SAAS,GAAGC,kBAAkB,GAAG,IAAI;IACvC,CAAC,CACF,CACF;EACH,CAAC,CAAC;AACJ","names":["operate","noop","createOperatorSubscriber","innerFrom","debounce","durationSelector","source","subscriber","hasValue","lastValue","durationSubscriber","emit","unsubscribe","value","next","subscribe","complete","undefined"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\debounce.ts"],"sourcesContent":["import { Subscriber } from '../Subscriber';\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { noop } from '../util/noop';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Emits a notification from the source Observable only after a particular time span\r\n * determined by another Observable has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\r\n * emission silence is determined by a second Observable.</span>\r\n *\r\n * ![](debounce.svg)\r\n *\r\n * `debounce` delays notifications emitted by the source Observable, but drops previous\r\n * pending delayed emissions if a new notification arrives on the source Observable.\r\n * This operator keeps track of the most recent notification from the source\r\n * Observable, and spawns a duration Observable by calling the\r\n * `durationSelector` function. The notification is emitted only when the duration\r\n * Observable emits a next notification, and if no other notification was emitted on\r\n * the source Observable since the duration Observable was spawned. If a new\r\n * notification appears before the duration Observable emits, the previous notification will\r\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\r\n * If the completing event happens during the scheduled duration the last cached notification\r\n * is emitted before the completion event is forwarded to the output observable.\r\n * If the error event happens during the scheduled duration or after it only the error event is\r\n * forwarded to the output observable. The cache notification is not emitted in this case.\r\n *\r\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\r\n * delay-like operator since output emissions do not necessarily occur at the\r\n * same time as they did on the source Observable.\r\n *\r\n * ## Example\r\n *\r\n * Emit the most recent click after a burst of clicks\r\n *\r\n * ```ts\r\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   scan(i => ++i, 1),\r\n *   debounce(i => interval(200 * i))\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n *\r\n * @param durationSelector A function\r\n * that receives a value from the source Observable, for computing the timeout\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by the specified duration Observable returned by\r\n * `durationSelector`, and may drop some values if they occur too frequently.\r\n */\r\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    let lastValue: T | null = null;\r\n    // The subscriber/subscription for the current debounce, if there is one.\r\n    let durationSubscriber: Subscriber<any> | null = null;\r\n\r\n    const emit = () => {\r\n      // Unsubscribe any current debounce subscription we have,\r\n      // we only cared about the first notification from it, and we\r\n      // want to clean that subscription up as soon as possible.\r\n      durationSubscriber?.unsubscribe();\r\n      durationSubscriber = null;\r\n      if (hasValue) {\r\n        // We have a value! Free up memory first, then emit the value.\r\n        hasValue = false;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // Cancel any pending debounce duration. We don't\r\n          // need to null it out here yet tho, because we're just going\r\n          // to create another one in a few lines.\r\n          durationSubscriber?.unsubscribe();\r\n          hasValue = true;\r\n          lastValue = value;\r\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\r\n          // and we're going to emit the value.\r\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\r\n          // Subscribe to the duration.\r\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\r\n        },\r\n        () => {\r\n          // Source completed.\r\n          // Emit any pending debounced values then complete\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer\r\n        undefined,\r\n        () => {\r\n          // Finalization.\r\n          lastValue = durationSubscriber = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}