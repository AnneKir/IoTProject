{"ast":null,"code":"import { __read } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nvar nodeEventEmitterMethods = ['addListener', 'removeListener'];\nvar eventTargetMethods = ['addEventListener', 'removeEventListener'];\nvar jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n  }\n  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function (methodName) {\n      return function (handler) {\n        return target[methodName](eventName, handler, options);\n      };\n    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2),\n    add = _a[0],\n    remove = _a[1];\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap(function (subTarget) {\n        return fromEvent(subTarget, eventName, options);\n      })(innerFrom(target));\n    }\n  }\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n  return new Observable(function (subscriber) {\n    var handler = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return subscriber.next(1 < args.length ? args : args[0]);\n    };\n    add(handler);\n    return function () {\n      return remove(handler);\n    };\n  });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n  return function (methodName) {\n    return function (handler) {\n      return target[methodName](eventName, handler);\n    };\n  };\n}\nfunction isNodeStyleEventEmitter(target) {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n  return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}","map":{"version":3,"mappings":"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","names":["innerFrom","Observable","mergeMap","isArrayLike","isFunction","mapOneOrManyArgs","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","resultSelector","undefined","pipe","isEventTarget","map","methodName","handler","isNodeStyleEventEmitter","toCommonHandlerRegistry","isJQueryStyleEventEmitter","add","remove","subTarget","TypeError","subscriber","_i","args","next","length","addListener","removeListener","on","off","addEventListener","removeEventListener"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\fromEvent.ts"],"sourcesContent":["import { innerFrom } from '../observable/innerFrom';\r\nimport { Observable } from '../Observable';\r\nimport { mergeMap } from '../operators/mergeMap';\r\nimport { isArrayLike } from '../util/isArrayLike';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\n\r\n// These constants are used to create handler registry functions using array mapping below.\r\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\r\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\r\nconst jqueryMethods = ['on', 'off'] as const;\r\n\r\nexport interface NodeStyleEventEmitter {\r\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\r\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\r\n}\r\n\r\nexport type NodeEventHandler = (...args: any[]) => void;\r\n\r\n// For APIs that implement `addListener` and `removeListener` methods that may\r\n// not use the same arguments or return EventEmitter values\r\n// such as React Native\r\nexport interface NodeCompatibleEventEmitter {\r\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\r\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\r\n}\r\n\r\n// Use handler types like those in @types/jquery. See:\r\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\r\nexport interface JQueryStyleEventEmitter<TContext, T> {\r\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\r\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\r\n}\r\n\r\nexport interface EventListenerObject<E> {\r\n  handleEvent(evt: E): void;\r\n}\r\n\r\nexport interface HasEventTargetAddRemove<E> {\r\n  addEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): void;\r\n  removeEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\r\n    options?: EventListenerOptions | boolean\r\n  ): void;\r\n}\r\n\r\nexport interface EventListenerOptions {\r\n  capture?: boolean;\r\n  passive?: boolean;\r\n  once?: boolean;\r\n}\r\n\r\nexport interface AddEventListenerOptions extends EventListenerOptions {\r\n  once?: boolean;\r\n  passive?: boolean;\r\n}\r\n\r\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  resultSelector: (event: T) => R\r\n): Observable<R>;\r\nexport function fromEvent<T>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  options: EventListenerOptions\r\n): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  options: EventListenerOptions,\r\n  resultSelector: (event: T) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\r\nexport function fromEvent<R>(\r\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent(\r\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\r\n  eventName: string\r\n): Observable<unknown>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\r\nexport function fromEvent<R>(\r\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent<T>(\r\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\r\n  eventName: string\r\n): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\r\n  eventName: string,\r\n  resultSelector: (value: T, ...args: any[]) => R\r\n): Observable<R>;\r\n\r\n/**\r\n * Creates an Observable that emits events of a specific type coming from the\r\n * given event target.\r\n *\r\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\r\n * EventEmitter events or others.</span>\r\n *\r\n * ![](fromEvent.png)\r\n *\r\n * `fromEvent` accepts as a first argument event target, which is an object with methods\r\n * for registering event handler functions. As a second argument it takes string that indicates\r\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\r\n * which are described in detail below. If your event target does not match any of the ones listed,\r\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\r\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\r\n * handler functions have different names, but they all accept a string describing event type\r\n * and function itself, which will be called whenever said event happens.\r\n *\r\n * Every time resulting Observable is subscribed, event handler function will be registered\r\n * to event target on given event type. When that event fires, value\r\n * passed as a first argument to registered function will be emitted by output Observable.\r\n * When Observable is unsubscribed, function will be unregistered from event target.\r\n *\r\n * Note that if event target calls registered function with more than one argument, second\r\n * and following arguments will not appear in resulting stream. In order to get access to them,\r\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\r\n * passed to event handler. Output Observable will then emit value returned by project function,\r\n * instead of the usual value.\r\n *\r\n * Remember that event targets listed below are checked via duck typing. It means that\r\n * no matter what kind of object you have and no matter what environment you work in,\r\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\r\n * of course they behave as was described above). So for example if Node.js library exposes\r\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\r\n * a good choice.\r\n *\r\n * If the API you use is more callback then event handler oriented (subscribed\r\n * callback function fires only once and thus there is no need to manually\r\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\r\n * instead.\r\n *\r\n * `fromEvent` supports following types of event targets:\r\n *\r\n * **DOM EventTarget**\r\n *\r\n * This is an object with `addEventListener` and `removeEventListener` methods.\r\n *\r\n * In the browser, `addEventListener` accepts - apart from event type string and event\r\n * handler function arguments - optional third parameter, which is either an object or boolean,\r\n * both used for additional configuration how and when passed function will be called. When\r\n * `fromEvent` is used with event target of that type, you can provide this values\r\n * as third parameter as well.\r\n *\r\n * **Node.js EventEmitter**\r\n *\r\n * An object with `addListener` and `removeListener` methods.\r\n *\r\n * **JQuery-style event target**\r\n *\r\n * An object with `on` and `off` methods\r\n *\r\n * **DOM NodeList**\r\n *\r\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\r\n *\r\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\r\n * it contains and install event handler function in every of them. When returned Observable\r\n * is unsubscribed, function will be removed from all Nodes.\r\n *\r\n * **DOM HtmlCollection**\r\n *\r\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\r\n * installed and removed in each of elements.\r\n *\r\n *\r\n * ## Examples\r\n *\r\n * Emit clicks happening on the DOM document\r\n *\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * clicks.subscribe(x => console.log(x));\r\n *\r\n * // Results in:\r\n * // MouseEvent object logged to console every time a click\r\n * // occurs on the document.\r\n * ```\r\n *\r\n * Use `addEventListener` with capture option\r\n *\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter\r\n *                                                              // which will be passed to addEventListener\r\n * const clicksInDiv = fromEvent(someDivInDocument, 'click');\r\n *\r\n * clicksInDocument.subscribe(() => console.log('document'));\r\n * clicksInDiv.subscribe(() => console.log('div'));\r\n *\r\n * // By default events bubble UP in DOM tree, so normally\r\n * // when we would click on div in document\r\n * // \"div\" would be logged first and then \"document\".\r\n * // Since we specified optional `capture` option, document\r\n * // will catch event when it goes DOWN DOM tree, so console\r\n * // will log \"document\" and then \"div\".\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link bindNodeCallback}\r\n * @see {@link fromEventPattern}\r\n *\r\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\r\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\r\n * @param {string} eventName The event name of interest, being emitted by the\r\n * `target`.\r\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\r\n * @return {Observable<T>}\r\n */\r\nexport function fromEvent<T>(\r\n  target: any,\r\n  eventName: string,\r\n  options?: EventListenerOptions | ((...args: any[]) => T),\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T> {\r\n  if (isFunction(options)) {\r\n    resultSelector = options;\r\n    options = undefined;\r\n  }\r\n  if (resultSelector) {\r\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\r\n  }\r\n\r\n  // Figure out our add and remove methods. In order to do this,\r\n  // we are going to analyze the target in a preferred order, if\r\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\r\n  // method names and apply them to a map to create opposite versions of the\r\n  // same function. This is because they all operate in duplicate pairs,\r\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\r\n  // The call only differs by method name, as to whether or not you're adding or removing.\r\n  const [add, remove] =\r\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\r\n    isEventTarget(target)\r\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\r\n      : // In all other cases, the call pattern is identical with the exception of the method names.\r\n      isNodeStyleEventEmitter(target)\r\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\r\n      : isJQueryStyleEventEmitter(target)\r\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\r\n      : [];\r\n\r\n  // If add is falsy, it's because we didn't match a pattern above.\r\n  // Check to see if it is an ArrayLike, because if it is, we want to\r\n  // try to apply fromEvent to all of it's items. We do this check last,\r\n  // because there are may be some types that are both ArrayLike *and* implement\r\n  // event registry points, and we'd rather delegate to that when possible.\r\n  if (!add) {\r\n    if (isArrayLike(target)) {\r\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\r\n        innerFrom(target)\r\n      ) as Observable<T>;\r\n    }\r\n  }\r\n\r\n  // If add is falsy and we made it here, it's because we didn't\r\n  // match any valid target objects above.\r\n  if (!add) {\r\n    throw new TypeError('Invalid event target');\r\n  }\r\n\r\n  return new Observable<T>((subscriber) => {\r\n    // The handler we are going to register. Forwards the event object, by itself, or\r\n    // an array of arguments to the event handler, if there is more than one argument,\r\n    // to the consumer.\r\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\r\n    // Do the work of adding the handler to the target.\r\n    add(handler);\r\n    // When we finalize, we want to remove the handler and free up memory.\r\n    return () => remove!(handler);\r\n  });\r\n}\r\n\r\n/**\r\n * Used to create `add` and `remove` functions to register and unregister event handlers\r\n * from a target in the most common handler pattern, where there are only two arguments.\r\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\r\n * @param target The target we're calling methods on\r\n * @param eventName The event name for the event we're creating register or unregister functions for\r\n */\r\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\r\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required node-style EventEmitter methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\r\n  return isFunction(target.addListener) && isFunction(target.removeListener);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\r\n  return isFunction(target.on) && isFunction(target.off);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required EventTarget methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\r\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}