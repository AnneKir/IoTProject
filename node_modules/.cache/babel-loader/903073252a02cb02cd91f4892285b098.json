{"ast":null,"code":"import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nexport function using(resourceFactory, observableFactory) {\n  return new Observable(function (subscriber) {\n    var resource = resourceFactory();\n    var result = observableFactory(resource);\n    var source = result ? innerFrom(result) : EMPTY;\n    source.subscribe(subscriber);\n    return function () {\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAE1C,SAASC,SAAS,QAAQ,aAAa;AACvC,SAASC,KAAK,QAAQ,SAAS;AA8B/B,OAAM,SAAUC,KAAK,CACnBC,eAA4C,EAC5CC,iBAAgE;EAEhE,OAAO,IAAIL,UAAU,CAAqB,UAACM,UAAU;IACnD,IAAMC,QAAQ,GAAGH,eAAe,EAAE;IAClC,IAAMI,MAAM,GAAGH,iBAAiB,CAACE,QAAQ,CAAC;IAC1C,IAAME,MAAM,GAAGD,MAAM,GAAGP,SAAS,CAACO,MAAM,CAAC,GAAGN,KAAK;IACjDO,MAAM,CAACC,SAAS,CAACJ,UAAU,CAAC;IAC5B,OAAO;MAGL,IAAIC,QAAQ,EAAE;QACZA,QAAQ,CAACI,WAAW,EAAE;;IAE1B,CAAC;EACH,CAAC,CAAC;AACJ","names":["Observable","innerFrom","EMPTY","using","resourceFactory","observableFactory","subscriber","resource","result","source","subscribe","unsubscribe"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\using.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\r\nimport { innerFrom } from './innerFrom';\r\nimport { EMPTY } from './empty';\r\n\r\n/**\r\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\r\n *\r\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\r\n *\r\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\r\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\r\n * that object and should return an Observable. That Observable can use resource object during its execution.\r\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\r\n * resource object will be shared in any way between subscriptions.\r\n *\r\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\r\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\r\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\r\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\r\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\r\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\r\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\r\n *\r\n * @see {@link defer}\r\n *\r\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\r\n * that implements `unsubscribe` method.\r\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\r\n * creates an Observable, that can use injected resource object.\r\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\r\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\r\n */\r\nexport function using<T extends ObservableInput<any>>(\r\n  resourceFactory: () => Unsubscribable | void,\r\n  observableFactory: (resource: Unsubscribable | void) => T | void\r\n): Observable<ObservedValueOf<T>> {\r\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\r\n    const resource = resourceFactory();\r\n    const result = observableFactory(resource);\r\n    const source = result ? innerFrom(result) : EMPTY;\r\n    source.subscribe(subscriber);\r\n    return () => {\r\n      // NOTE: Optional chaining did not work here.\r\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\r\n      if (resource) {\r\n        resource.unsubscribe();\r\n      }\r\n    };\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}