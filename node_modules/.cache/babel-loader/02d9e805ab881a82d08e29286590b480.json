{"ast":null,"code":"import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementOrOptions, duration, connector) {\n  return operate(function (source, subscriber) {\n    var element;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions;\n    } else {\n      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;\n    }\n    var groups = new Map();\n    var notify = function notify(cb) {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n    var handleError = function handleError(err) {\n      return notify(function (consumer) {\n        return consumer.error(err);\n      });\n    };\n    var activeGroups = 0;\n    var teardownAttempted = false;\n    var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function (value) {\n      try {\n        var key_1 = keySelector(value);\n        var group_1 = groups.get(key_1);\n        if (!group_1) {\n          groups.set(key_1, group_1 = connector ? connector() : new Subject());\n          var grouped = createGroupedObservable(key_1, group_1);\n          subscriber.next(grouped);\n          if (duration) {\n            var durationSubscriber_1 = createOperatorSubscriber(group_1, function () {\n              group_1.complete();\n              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();\n            }, undefined, undefined, function () {\n              return groups.delete(key_1);\n            });\n            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));\n          }\n        }\n        group_1.next(element ? element(value) : value);\n      } catch (err) {\n        handleError(err);\n      }\n    }, function () {\n      return notify(function (consumer) {\n        return consumer.complete();\n      });\n    }, handleError, function () {\n      return groups.clear();\n    }, function () {\n      teardownAttempted = true;\n      return activeGroups === 0;\n    });\n    source.subscribe(groupBySourceSubscriber);\n    function createGroupedObservable(key, groupSubject) {\n      var result = new Observable(function (groupSubscriber) {\n        activeGroups++;\n        var innerSub = groupSubject.subscribe(groupSubscriber);\n        return function () {\n          innerSub.unsubscribe();\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["Observable","innerFrom","Subject","operate","createOperatorSubscriber","OperatorSubscriber","groupBy","keySelector","elementOrOptions","duration","connector","source","subscriber","element","groups","Map","notify","cb","forEach","handleError","err","consumer","error","activeGroups","teardownAttempted","groupBySourceSubscriber","value","key_1","group_1","get","set","grouped","createGroupedObservable","next","durationSubscriber_1","complete","unsubscribe","undefined","delete","add","subscribe","clear","key","groupSubject","result","groupSubscriber","innerSub"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\groupBy.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subject } from '../Subject';\r\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport interface BasicGroupByOptions<K, T> {\r\n  element?: undefined;\r\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\r\n  connector?: () => SubjectLike<T>;\r\n}\r\n\r\nexport interface GroupByOptionsWithElement<K, E, T> {\r\n  element: (value: T) => E;\r\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\r\n  connector?: () => SubjectLike<E>;\r\n}\r\n\r\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\r\n\r\nexport function groupBy<T, K, E>(\r\n  key: (value: T) => K,\r\n  options: GroupByOptionsWithElement<K, E, T>\r\n): OperatorFunction<T, GroupedObservable<K, E>>;\r\n\r\nexport function groupBy<T, K extends T>(\r\n  key: (value: T) => value is K\r\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\r\n\r\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\r\n\r\n/**\r\n * @deprecated use the options parameter instead.\r\n */\r\nexport function groupBy<T, K>(\r\n  key: (value: T) => K,\r\n  element: void,\r\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\r\n): OperatorFunction<T, GroupedObservable<K, T>>;\r\n\r\n/**\r\n * @deprecated use the options parameter instead.\r\n */\r\nexport function groupBy<T, K, R>(\r\n  key: (value: T) => K,\r\n  element?: (value: T) => R,\r\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\r\n): OperatorFunction<T, GroupedObservable<K, R>>;\r\n\r\n/**\r\n * Groups the items emitted by an Observable according to a specified criterion,\r\n * and emits these grouped items as `GroupedObservables`, one\r\n * {@link GroupedObservable} per group.\r\n *\r\n * ![](groupBy.png)\r\n *\r\n * When the Observable emits an item, a key is computed for this item with the key function.\r\n *\r\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\r\n * {@link GroupedObservable} for this key is created and emits.\r\n *\r\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\r\n * key is available as the `key` field of a {@link GroupedObservable} instance.\r\n *\r\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\r\n * returned by the element function.\r\n *\r\n * ## Examples\r\n *\r\n * Group objects by `id` and return as array\r\n *\r\n * ```ts\r\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\r\n *\r\n * of(\r\n *   { id: 1, name: 'JavaScript' },\r\n *   { id: 2, name: 'Parcel' },\r\n *   { id: 2, name: 'webpack' },\r\n *   { id: 1, name: 'TypeScript' },\r\n *   { id: 3, name: 'TSLint' }\r\n * ).pipe(\r\n *   groupBy(p => p.id),\r\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\r\n * )\r\n * .subscribe(p => console.log(p));\r\n *\r\n * // displays:\r\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\r\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\r\n * // [{ id: 3, name: 'TSLint' }]\r\n * ```\r\n *\r\n * Pivot data on the `id` field\r\n *\r\n * ```ts\r\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\r\n *\r\n * of(\r\n *   { id: 1, name: 'JavaScript' },\r\n *   { id: 2, name: 'Parcel' },\r\n *   { id: 2, name: 'webpack' },\r\n *   { id: 1, name: 'TypeScript' },\r\n *   { id: 3, name: 'TSLint' }\r\n * ).pipe(\r\n *   groupBy(p => p.id, { element: p => p.name }),\r\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\r\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\r\n * )\r\n * .subscribe(p => console.log(p));\r\n *\r\n * // displays:\r\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\r\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\r\n * // { id: 3, values: [ 'TSLint' ] }\r\n * ```\r\n *\r\n * @param key A function that extracts the key\r\n * for each item.\r\n * @param element A function that extracts the\r\n * return element for each item.\r\n * @param duration\r\n * A function that returns an Observable to determine how long each group should\r\n * exist.\r\n * @param connector Factory function to create an\r\n * intermediate Subject through which grouped elements are emitted.\r\n * @return A function that returns an Observable that emits GroupedObservables,\r\n * each of which corresponds to a unique key value and each of which emits\r\n * those items from the source Observable that share that key value.\r\n *\r\n * @deprecated Use the options parameter instead.\r\n */\r\nexport function groupBy<T, K, R>(\r\n  key: (value: T) => K,\r\n  element?: (value: T) => R,\r\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\r\n  connector?: () => Subject<R>\r\n): OperatorFunction<T, GroupedObservable<K, R>>;\r\n\r\n// Impl\r\nexport function groupBy<T, K, R>(\r\n  keySelector: (value: T) => K,\r\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\r\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\r\n  connector?: () => SubjectLike<any>\r\n): OperatorFunction<T, GroupedObservable<K, R>> {\r\n  return operate((source, subscriber) => {\r\n    let element: ((value: any) => any) | void;\r\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\r\n      element = elementOrOptions as ((value: any) => any);\r\n    } else {\r\n      ({ duration, element, connector } = elementOrOptions);\r\n    }\r\n\r\n    // A lookup for the groups that we have so far.\r\n    const groups = new Map<K, SubjectLike<any>>();\r\n\r\n    // Used for notifying all groups and the subscriber in the same way.\r\n    const notify = (cb: (group: Observer<any>) => void) => {\r\n      groups.forEach(cb);\r\n      cb(subscriber);\r\n    };\r\n\r\n    // Used to handle errors from the source, AND errors that occur during the\r\n    // next call from the source.\r\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\r\n\r\n    // The number of actively subscribed groups\r\n    let activeGroups = 0;\r\n\r\n    // Whether or not teardown was attempted on this subscription.\r\n    let teardownAttempted = false;\r\n\r\n    // Capturing a reference to this, because we need a handle to it\r\n    // in `createGroupedObservable` below. This is what we use to\r\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\r\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\r\n    // in cases where a user unsubscribes from the main resulting subscription, but\r\n    // still has groups from this subscription subscribed and would expect values from it\r\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\r\n    const groupBySourceSubscriber = new OperatorSubscriber(\r\n      subscriber,\r\n      (value: T) => {\r\n        // Because we have to notify all groups of any errors that occur in here,\r\n        // we have to add our own try/catch to ensure that those errors are propagated.\r\n        // OperatorSubscriber will only send the error to the main subscriber.\r\n        try {\r\n          const key = keySelector(value);\r\n\r\n          let group = groups.get(key);\r\n          if (!group) {\r\n            // Create our group subject\r\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\r\n\r\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\r\n            // because the grouped observable has special semantics around reference counting\r\n            // to ensure we don't sever our connection to the source prematurely.\r\n            const grouped = createGroupedObservable(key, group);\r\n            subscriber.next(grouped);\r\n\r\n            if (duration) {\r\n              const durationSubscriber = createOperatorSubscriber(\r\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\r\n                // when the duration subscription is torn down. That is important, because then\r\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\r\n                // after the connection to the source has been severed, they will get an\r\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\r\n                group as any,\r\n                () => {\r\n                  // Our duration notified! We can complete the group.\r\n                  // The group will be removed from the map in the finalization phase.\r\n                  group!.complete();\r\n                  durationSubscriber?.unsubscribe();\r\n                },\r\n                // Completions are also sent to the group, but just the group.\r\n                undefined,\r\n                // Errors on the duration subscriber are sent to the group\r\n                // but only the group. They are not sent to the main subscription.\r\n                undefined,\r\n                // Finalization: Remove this group from our map.\r\n                () => groups.delete(key)\r\n              );\r\n\r\n              // Start our duration notifier.\r\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\r\n            }\r\n          }\r\n\r\n          // Send the value to our group.\r\n          group.next(element ? element(value) : value);\r\n        } catch (err) {\r\n          handleError(err);\r\n        }\r\n      },\r\n      // Source completes.\r\n      () => notify((consumer) => consumer.complete()),\r\n      // Error from the source.\r\n      handleError,\r\n      // Free up memory.\r\n      // When the source subscription is _finally_ torn down, release the subjects and keys\r\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\r\n      // don't have to.\r\n      () => groups.clear(),\r\n      () => {\r\n        teardownAttempted = true;\r\n        // We only kill our subscription to the source if we have\r\n        // no active groups. As stated above, consider this scenario:\r\n        // source$.pipe(groupBy(fn), take(2)).\r\n        return activeGroups === 0;\r\n      }\r\n    );\r\n\r\n    // Subscribe to the source\r\n    source.subscribe(groupBySourceSubscriber);\r\n\r\n    /**\r\n     * Creates the actual grouped observable returned.\r\n     * @param key The key of the group\r\n     * @param groupSubject The subject that fuels the group\r\n     */\r\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\r\n      const result: any = new Observable<T>((groupSubscriber) => {\r\n        activeGroups++;\r\n        const innerSub = groupSubject.subscribe(groupSubscriber);\r\n        return () => {\r\n          innerSub.unsubscribe();\r\n          // We can kill the subscription to our source if we now have no more\r\n          // active groups subscribed, and a finalization was already attempted on\r\n          // the source.\r\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\r\n        };\r\n      });\r\n      result.key = key;\r\n      return result;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\r\n * contains a `key` property for the grouping.\r\n */\r\nexport interface GroupedObservable<K, T> extends Observable<T> {\r\n  /**\r\n   * The key value for the grouped notifications.\r\n   */\r\n  readonly key: K;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}