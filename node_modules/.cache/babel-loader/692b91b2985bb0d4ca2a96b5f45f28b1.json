{"ast":null,"code":"import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\nexport var queueScheduler = new QueueScheduler(QueueAction);\nexport var queue = queueScheduler;","map":{"version":3,"mappings":"AAAA,SAASA,WAAW,QAAQ,eAAe;AAC3C,SAASC,cAAc,QAAQ,kBAAkB;AAiEjD,OAAO,IAAMC,cAAc,GAAG,IAAID,cAAc,CAACD,WAAW,CAAC;AAK7D,OAAO,IAAMG,KAAK,GAAGD,cAAc","names":["QueueAction","QueueScheduler","queueScheduler","queue"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\scheduler\\queue.ts"],"sourcesContent":["import { QueueAction } from './QueueAction';\r\nimport { QueueScheduler } from './QueueScheduler';\r\n\r\n/**\r\n *\r\n * Queue Scheduler\r\n *\r\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\r\n *\r\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\r\n *\r\n * When used without delay, it schedules given task synchronously - executes it right when\r\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\r\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\r\n * that task will be put on a queue and wait for current one to finish.\r\n *\r\n * This means that when you execute task with `queue` scheduler, you are sure it will end\r\n * before any other task scheduled with that scheduler will start.\r\n *\r\n * ## Examples\r\n * Schedule recursively first, then do something\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(() => {\r\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\r\n *\r\n *   console.log('first');\r\n * });\r\n *\r\n * // Logs:\r\n * // \"first\"\r\n * // \"second\"\r\n * ```\r\n *\r\n * Reschedule itself recursively\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(function(state) {\r\n *   if (state !== 0) {\r\n *     console.log('before', state);\r\n *     this.schedule(state - 1); // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n *     console.log('after', state);\r\n *   }\r\n * }, 0, 3);\r\n *\r\n * // In scheduler that runs recursively, you would expect:\r\n * // \"before\", 3\r\n * // \"before\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * // \"after\", 2\r\n * // \"after\", 3\r\n *\r\n * // But with queue it logs:\r\n * // \"before\", 3\r\n * // \"after\", 3\r\n * // \"before\", 2\r\n * // \"after\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * ```\r\n */\r\n\r\nexport const queueScheduler = new QueueScheduler(QueueAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\r\n */\r\nexport const queue = queueScheduler;\r\n"]},"metadata":{},"sourceType":"module"}