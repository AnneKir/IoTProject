{"ast":null,"code":"const Peer = require('simple-peer');\nclass SimplePeerClientWrapper {\n  constructor(socket, debug, simplePeerOptions) {\n    this.initPeerRequest = false;\n    this.socket = socket;\n    this.localStream;\n    this.debug = debug;\n    this.connections = [];\n    this.onConnectCallback;\n    this.onDataCallback;\n    this.onStreamCallback;\n    // this.onTrackCallback;\n    this.onCloseCallback;\n    this.onErrorCallback;\n    this.simplePeerOptions;\n    if (typeof simplePeerOptions !== 'undefined') {\n      this.simplePeerOptions = simplePeerOptions;\n    }\n  }\n  setlocalStream(stream) {\n    this.localStream = stream;\n  }\n  init() {\n    this.debug && console.log('running init Peer Client. # of ' + this.connections.length);\n    this.initPeerRequest = true;\n    for (let i = 0; i < this.connections.length; i++) {\n      this.socket.emit('initiate peer', this.connections[i].room);\n      if (this.connections[i].initiator) {\n        this.attemptPeerStart(this.connections[i]);\n      }\n    }\n  }\n  attemptPeerStart(connection) {\n    this.debug && console.log('Attempting peer start', connection.peerStarted, connection.roomReady);\n    if (!connection.peerStarted && connection.roomReady) {\n      this.debug && console.log('Creating peer connection');\n      this.createPeerConnection(connection);\n    } else {\n      this.debug && console.log('Not creating peer connection');\n    }\n  }\n  createPeerConnection(connection) {\n    this.debug && console.log('creating simple peer');\n    const options = this._getPeerOptions(connection.initiator);\n    const peer = new Peer(options);\n\n    // If initiator,peer.on'signal' will fire right away, if not it waits for signal\n    // https://github.com/feross/simple-peer#peeronsignal-data--\n    peer.on('signal', data => this._sendSignal(data, connection));\n    peer.on('connect', () => this._handleConnection());\n    peer.on('error', err => this._handleError(err));\n    peer.on('stream', stream => this._handleStream(stream));\n    peer.on('data', data => this._handleData(data));\n    // peer.on('track', (track, stream) =>\n    //   this._handleTrack(track, stream),\n    // );\n    peer.on('close', () => this._handleClose());\n    connection.peerStarted = true;\n    connection.peer = peer;\n  }\n  isPeerStarted() {\n    let peerStarted = false;\n\n    // if any peer connection is not started then it returns false\n    for (let i = 0; i < this.connections.length; i++) {\n      peerStarted = this.connections[i].peerStarted;\n    }\n    return peerStarted;\n  }\n  setEventCallback(event, callback) {\n    switch (event) {\n      case 'connect':\n        this.onConnectCallback = callback;\n        break;\n      case 'data':\n        this.onDataCallback = callback;\n        break;\n      case 'stream':\n        this.onStreamCallback = callback;\n        break;\n      // case 'track':\n      //   this.onTrackCallback = callback;\n      //   break;\n      case 'close':\n        this.onCloseCallback = callback;\n        break;\n      case 'error':\n        this.onErrorCallback = callback;\n    }\n  }\n  sendData(data) {\n    let msg = JSON.stringify({\n      data: data,\n      userId: this.socket.id\n    });\n    for (let i = 0; i < this.connections.length; i++) {\n      const peer = this.connections[i];\n      if (peer.peerStarted) {\n        const peerConn = peer.peer;\n        if (peerConn.connected) {\n          peerConn.write(msg);\n        }\n      }\n    }\n  }\n  terminateSession() {\n    for (let i = 0; i < this.connections.length; i++) {\n      const peer = this.connections[i].peer;\n      peer.destroy(); // simple-peer method to close and cleanup peer connection\n      this.connections[i].peer = null;\n      this.connections[i].peerStarted = false;\n    }\n    this.socket.emit('hangup');\n    this.socket.close();\n  }\n  _getPeerOptions(initiator) {\n    const options = {\n      initiator: initiator\n    };\n    if (typeof this.localStream !== 'undefined') {\n      options.stream = this.localStream;\n    }\n    if (typeof this.simplePeerOptions !== 'undefined') {\n      const spOptions = Object.entries(this.simplePeerOptions);\n      if (spOptions.length > 0) {\n        for (const [key, value] of spOptions) {\n          options[key] = value;\n        }\n      }\n    }\n    return options;\n  }\n  _sendSignal(data, connection) {\n    this.debug && console.log('sending signal');\n    const message = {\n      room: connection.room,\n      data: JSON.stringify(data)\n    };\n    this.socket.emit('sending signal', message);\n  }\n  _handleConnection() {\n    this.debug && console.log('SIMPLE PEER IS CONNECTED');\n    if (this.onConnectCallback) this.onConnectCallback();\n  }\n  _handleStream(stream) {\n    this.onStreamCallback(stream);\n  }\n  _handleError(err) {\n    if (typeof this.onErrorCallback !== 'undefined') {\n      this.onErrorCallback(err);\n    } else {\n      console.log(err);\n    }\n  }\n  _handleData(data) {\n    const decodedString = new TextDecoder('utf-8').decode(data);\n    const decodedJSON = JSON.parse(decodedString);\n    this.onDataCallback(decodedJSON);\n  }\n  _handleClose() {\n    if (typeof this.onCloseCallback !== 'undefined') {\n      this.onCloseCallback();\n    }\n    this.debug && console.log('Closing Connection');\n  }\n  _handleRemoteHangup() {\n    this.debug && console.log('Handling remote hangup');\n    this.terminateSession(true);\n  }\n  _closePeerConnection() {\n    // peerStarted = false;\n    // peer.destroy();\n    // peer = null;\n  }\n}\nmodule.exports = SimplePeerClientWrapper;","map":{"version":3,"names":["Peer","require","SimplePeerClientWrapper","constructor","socket","debug","simplePeerOptions","initPeerRequest","localStream","connections","onConnectCallback","onDataCallback","onStreamCallback","onCloseCallback","onErrorCallback","setlocalStream","stream","init","console","log","length","i","emit","room","initiator","attemptPeerStart","connection","peerStarted","roomReady","createPeerConnection","options","_getPeerOptions","peer","on","data","_sendSignal","_handleConnection","err","_handleError","_handleStream","_handleData","_handleClose","isPeerStarted","setEventCallback","event","callback","sendData","msg","JSON","stringify","userId","id","peerConn","connected","write","terminateSession","destroy","close","spOptions","Object","entries","key","value","message","decodedString","TextDecoder","decode","decodedJSON","parse","_handleRemoteHangup","_closePeerConnection","module","exports"],"sources":["C:/Users/Amali/Desktop/Building_the_IoT_w._P2P_and_Cloud_Computing/IoTProject/node_modules/simple-peer-wrapper/src/simple-peer-client-wrapper.js"],"sourcesContent":["const Peer = require('simple-peer');\n\nclass SimplePeerClientWrapper {\n  constructor(socket, debug, simplePeerOptions) {\n    this.initPeerRequest = false;\n    this.socket = socket;\n    this.localStream;\n    this.debug = debug;\n    this.connections = [];\n    this.onConnectCallback;\n    this.onDataCallback;\n    this.onStreamCallback;\n    // this.onTrackCallback;\n    this.onCloseCallback;\n    this.onErrorCallback;\n    this.simplePeerOptions;\n\n    if (typeof simplePeerOptions !== 'undefined') {\n      this.simplePeerOptions = simplePeerOptions;\n    }\n  }\n\n  setlocalStream(stream) {\n    this.localStream = stream;\n  }\n\n  init() {\n    this.debug &&\n      console.log(\n        'running init Peer Client. # of ' + this.connections.length,\n      );\n    this.initPeerRequest = true;\n\n    for (let i = 0; i < this.connections.length; i++) {\n      this.socket.emit('initiate peer', this.connections[i].room);\n      if (this.connections[i].initiator) {\n        this.attemptPeerStart(this.connections[i]);\n      }\n    }\n  }\n\n  attemptPeerStart(connection) {\n    this.debug &&\n      console.log(\n        'Attempting peer start',\n        connection.peerStarted,\n        connection.roomReady,\n      );\n\n    if (!connection.peerStarted && connection.roomReady) {\n      this.debug && console.log('Creating peer connection');\n      this.createPeerConnection(connection);\n    } else {\n      this.debug && console.log('Not creating peer connection');\n    }\n  }\n\n  createPeerConnection(connection) {\n    this.debug && console.log('creating simple peer');\n\n    const options = this._getPeerOptions(connection.initiator);\n    const peer = new Peer(options);\n\n    // If initiator,peer.on'signal' will fire right away, if not it waits for signal\n    // https://github.com/feross/simple-peer#peeronsignal-data--\n    peer.on('signal', (data) => this._sendSignal(data, connection));\n    peer.on('connect', () => this._handleConnection());\n    peer.on('error', (err) => this._handleError(err));\n    peer.on('stream', (stream) => this._handleStream(stream));\n    peer.on('data', (data) => this._handleData(data));\n    // peer.on('track', (track, stream) =>\n    //   this._handleTrack(track, stream),\n    // );\n    peer.on('close', () => this._handleClose());\n\n    connection.peerStarted = true;\n    connection.peer = peer;\n  }\n\n  isPeerStarted() {\n    let peerStarted = false;\n\n    // if any peer connection is not started then it returns false\n    for (let i = 0; i < this.connections.length; i++) {\n      peerStarted = this.connections[i].peerStarted;\n    }\n    return peerStarted;\n  }\n\n  setEventCallback(event, callback) {\n    switch (event) {\n      case 'connect':\n        this.onConnectCallback = callback;\n        break;\n      case 'data':\n        this.onDataCallback = callback;\n        break;\n      case 'stream':\n        this.onStreamCallback = callback;\n        break;\n      // case 'track':\n      //   this.onTrackCallback = callback;\n      //   break;\n      case 'close':\n        this.onCloseCallback = callback;\n        break;\n      case 'error':\n        this.onErrorCallback = callback;\n    }\n  }\n\n  sendData(data) {\n    let msg = JSON.stringify({ data: data, userId: this.socket.id });\n    for (let i = 0; i < this.connections.length; i++) {\n      const peer = this.connections[i];\n      if (peer.peerStarted) {\n        const peerConn = peer.peer;\n        if (peerConn.connected) {\n          peerConn.write(msg);\n        }\n      }\n    }\n  }\n\n  terminateSession() {\n    for (let i = 0; i < this.connections.length; i++) {\n      const peer = this.connections[i].peer;\n      peer.destroy(); // simple-peer method to close and cleanup peer connection\n      this.connections[i].peer = null;\n      this.connections[i].peerStarted = false;\n    }\n\n    this.socket.emit('hangup');\n    this.socket.close();\n  }\n\n  _getPeerOptions(initiator) {\n    const options = {\n      initiator: initiator,\n    };\n\n    if (typeof this.localStream !== 'undefined') {\n      options.stream = this.localStream;\n    }\n\n    if (typeof this.simplePeerOptions !== 'undefined') {\n      const spOptions = Object.entries(this.simplePeerOptions);\n\n      if (spOptions.length > 0) {\n        for (const [key, value] of spOptions) {\n          options[key] = value;\n        }\n      }\n    }\n    return options;\n  }\n\n  _sendSignal(data, connection) {\n    this.debug && console.log('sending signal');\n\n    const message = {\n      room: connection.room,\n      data: JSON.stringify(data),\n    };\n\n    this.socket.emit('sending signal', message);\n  }\n\n  _handleConnection() {\n    this.debug && console.log('SIMPLE PEER IS CONNECTED');\n    if (this.onConnectCallback) this.onConnectCallback();\n  }\n\n  _handleStream(stream) {\n    this.onStreamCallback(stream);\n  }\n\n  _handleError(err) {\n    if (typeof this.onErrorCallback !== 'undefined') {\n      this.onErrorCallback(err);\n    } else {\n      console.log(err);\n    }\n  }\n\n  _handleData(data) {\n    const decodedString = new TextDecoder('utf-8').decode(data);\n    const decodedJSON = JSON.parse(decodedString);\n    this.onDataCallback(decodedJSON);\n  }\n\n  _handleClose() {\n    if (typeof this.onCloseCallback !== 'undefined') {\n      this.onCloseCallback();\n    }\n\n    this.debug && console.log('Closing Connection');\n  }\n\n  _handleRemoteHangup() {\n    this.debug && console.log('Handling remote hangup');\n    this.terminateSession(true);\n  }\n\n  _closePeerConnection() {\n    // peerStarted = false;\n    // peer.destroy();\n    // peer = null;\n  }\n}\n\nmodule.exports = SimplePeerClientWrapper;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}