{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { operate } from '../util/lift';\nexport function share(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.connector,\n    connector = _a === void 0 ? function () {\n      return new Subject();\n    } : _a,\n    _b = options.resetOnError,\n    resetOnError = _b === void 0 ? true : _b,\n    _c = options.resetOnComplete,\n    resetOnComplete = _c === void 0 ? true : _c,\n    _d = options.resetOnRefCountZero,\n    resetOnRefCountZero = _d === void 0 ? true : _d;\n  return function (wrapperSource) {\n    var connection;\n    var resetConnection;\n    var subject;\n    var refCount = 0;\n    var hasCompleted = false;\n    var hasErrored = false;\n    var cancelReset = function cancelReset() {\n      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n      resetConnection = undefined;\n    };\n    var reset = function reset() {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    var resetAndUnsubscribe = function resetAndUnsubscribe() {\n      var conn = connection;\n      reset();\n      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n    };\n    return operate(function (source, subscriber) {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();\n      subscriber.add(function () {\n        refCount--;\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n      dest.subscribe(subscriber);\n      if (!connection && refCount > 0) {\n        connection = new SafeSubscriber({\n          next: function next(value) {\n            return dest.next(value);\n          },\n          error: function error(err) {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: function complete() {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          }\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\nfunction handleReset(reset, on) {\n  var args = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    args[_i - 2] = arguments[_i];\n  }\n  if (on === true) {\n    reset();\n    return;\n  }\n  if (on === false) {\n    return;\n  }\n  var onSubscriber = new SafeSubscriber({\n    next: function next() {\n      onSubscriber.unsubscribe();\n      reset();\n    }\n  });\n  return on.apply(void 0, __spreadArray([], __read(args))).subscribe(onSubscriber);\n}","map":{"version":3,"mappings":"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","names":["innerFrom","Subject","SafeSubscriber","operate","share","options","connector","_b","resetOnError","_c","resetOnComplete","_d","resetOnRefCountZero","wrapperSource","connection","resetConnection","subject","refCount","hasCompleted","hasErrored","cancelReset","unsubscribe","undefined","reset","resetAndUnsubscribe","conn","source","subscriber","dest","add","handleReset","subscribe","next","value","error","err","complete","on","_i","args","onSubscriber"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\share.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subject } from '../Subject';\r\nimport { SafeSubscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction, SubjectLike } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\nexport interface ShareConfig<T> {\r\n  /**\r\n   * The factory used to create the subject that will connect the source observable to\r\n   * multicast consumers.\r\n   */\r\n  connector?: () => SubjectLike<T>;\r\n  /**\r\n   * If true, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\r\n   * allows the resulting observable to be \"retried\" in the event of an error.\r\n   * If false, when an error comes from the source it will push the error into the connecting subject, and the subject\r\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\r\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\r\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\r\n   * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained\r\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\r\n   */\r\n  resetOnError?: boolean | ((error: any) => Observable<any>);\r\n  /**\r\n   * If true, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\r\n   * allows the resulting observable to be \"repeated\" after it is done.\r\n   * If false, when the source completes, it will push the completion through the connecting subject, and the subject\r\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\r\n   * or resubscriptions will resubscribe to that same subject.\r\n   * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained\r\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\r\n   */\r\n  resetOnComplete?: boolean | (() => Observable<any>);\r\n  /**\r\n   * If true, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\r\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\r\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\r\n   * again.\r\n   * If false, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\r\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\r\n   * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained\r\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\r\n   */\r\n  resetOnRefCountZero?: boolean | (() => Observable<any>);\r\n}\r\n\r\nexport function share<T>(): MonoTypeOperatorFunction<T>;\r\n\r\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\r\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\r\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\r\n * This is an alias for `multicast(() => new Subject()), refCount()`.\r\n *\r\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\r\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\r\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\r\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\r\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\r\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\r\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\r\n *\r\n * ![](share.png)\r\n *\r\n * ## Example\r\n *\r\n * Generate new multicast Observable from the `source` Observable value\r\n *\r\n * ```ts\r\n * import { interval, tap, map, take, share } from 'rxjs';\r\n *\r\n * const source = interval(1000).pipe(\r\n *   tap(x => console.log('Processing: ', x)),\r\n *   map(x => x * x),\r\n *   take(6),\r\n *   share()\r\n * );\r\n *\r\n * source.subscribe(x => console.log('subscription 1: ', x));\r\n * source.subscribe(x => console.log('subscription 2: ', x));\r\n *\r\n * // Logs:\r\n * // Processing: 0\r\n * // subscription 1: 0\r\n * // subscription 2: 0\r\n * // Processing: 1\r\n * // subscription 1: 1\r\n * // subscription 2: 1\r\n * // Processing: 2\r\n * // subscription 1: 4\r\n * // subscription 2: 4\r\n * // Processing: 3\r\n * // subscription 1: 9\r\n * // subscription 2: 9\r\n * // Processing: 4\r\n * // subscription 1: 16\r\n * // subscription 2: 16\r\n * // Processing: 5\r\n * // subscription 1: 25\r\n * // subscription 2: 25\r\n * ```\r\n *\r\n * ## Example with notifier factory: Delayed reset\r\n *\r\n * ```ts\r\n * import { interval, take, share, timer } from 'rxjs';\r\n *\r\n * const source = interval(1000).pipe(\r\n *   take(3),\r\n *   share({\r\n *     resetOnRefCountZero: () => timer(1000)\r\n *   })\r\n * );\r\n *\r\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\r\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\r\n *\r\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\r\n *\r\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\r\n *\r\n * // Logs:\r\n * // subscription 1:  0\r\n * // (subscription 1 unsubscribes here)\r\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\r\n * // subscription 2:  1\r\n * // subscription 2:  2\r\n * // (subscription 2 unsubscribes here)\r\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\r\n * // subscription 3:  0\r\n * // subscription 3:  1\r\n * // subscription 3:  2\r\n * ```\r\n *\r\n * @see {@link shareReplay}\r\n *\r\n * @return A function that returns an Observable that mirrors the source.\r\n */\r\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\r\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\r\n  // It's necessary to use a wrapper here, as the _operator_ must be\r\n  // referentially transparent. Otherwise, it cannot be used in calls to the\r\n  // static `pipe` function - to create a partial pipeline.\r\n  //\r\n  // The _operator function_ - the function returned by the _operator_ - will\r\n  // not be referentially transparent - as it shares its source - but the\r\n  // _operator function_ is called when the complete pipeline is composed via a\r\n  // call to a source observable's `pipe` method - not when the static `pipe`\r\n  // function is called.\r\n  return (wrapperSource) => {\r\n    let connection: SafeSubscriber<T> | undefined;\r\n    let resetConnection: Subscription | undefined;\r\n    let subject: SubjectLike<T> | undefined;\r\n    let refCount = 0;\r\n    let hasCompleted = false;\r\n    let hasErrored = false;\r\n\r\n    const cancelReset = () => {\r\n      resetConnection?.unsubscribe();\r\n      resetConnection = undefined;\r\n    };\r\n    // Used to reset the internal state to a \"cold\"\r\n    // state, as though it had never been subscribed to.\r\n    const reset = () => {\r\n      cancelReset();\r\n      connection = subject = undefined;\r\n      hasCompleted = hasErrored = false;\r\n    };\r\n    const resetAndUnsubscribe = () => {\r\n      // We need to capture the connection before\r\n      // we reset (if we need to reset).\r\n      const conn = connection;\r\n      reset();\r\n      conn?.unsubscribe();\r\n    };\r\n\r\n    return operate<T, T>((source, subscriber) => {\r\n      refCount++;\r\n      if (!hasErrored && !hasCompleted) {\r\n        cancelReset();\r\n      }\r\n\r\n      // Create the subject if we don't have one yet. Grab a local reference to\r\n      // it as well, which avoids non-null assertions when using it and, if we\r\n      // connect to it now, then error/complete need a reference after it was\r\n      // reset.\r\n      const dest = (subject = subject ?? connector());\r\n\r\n      // Add the finalization directly to the subscriber - instead of returning it -\r\n      // so that the handling of the subscriber's unsubscription will be wired\r\n      // up _before_ the subscription to the source occurs. This is done so that\r\n      // the assignment to the source connection's `closed` property will be seen\r\n      // by synchronous firehose sources.\r\n      subscriber.add(() => {\r\n        refCount--;\r\n\r\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\r\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\r\n        // configuration.\r\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\r\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\r\n        }\r\n      });\r\n\r\n      // The following line adds the subscription to the subscriber passed.\r\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\r\n      dest.subscribe(subscriber);\r\n\r\n      if (\r\n        !connection &&\r\n        // Check this shareReplay is still activate - it can be reset to 0\r\n        // and be \"unsubscribed\" _before_ it actually subscribes.\r\n        // If we were to subscribe then, it'd leak and get stuck.\r\n        refCount > 0\r\n      ) {\r\n        // We need to create a subscriber here - rather than pass an observer and\r\n        // assign the returned subscription to connection - because it's possible\r\n        // for reentrant subscriptions to the shared observable to occur and in\r\n        // those situations we want connection to be already-assigned so that we\r\n        // don't create another connection to the source.\r\n        connection = new SafeSubscriber({\r\n          next: (value) => dest.next(value),\r\n          error: (err) => {\r\n            hasErrored = true;\r\n            cancelReset();\r\n            resetConnection = handleReset(reset, resetOnError, err);\r\n            dest.error(err);\r\n          },\r\n          complete: () => {\r\n            hasCompleted = true;\r\n            cancelReset();\r\n            resetConnection = handleReset(reset, resetOnComplete);\r\n            dest.complete();\r\n          },\r\n        });\r\n        innerFrom(source).subscribe(connection);\r\n      }\r\n    })(wrapperSource);\r\n  };\r\n}\r\n\r\nfunction handleReset<T extends unknown[] = never[]>(\r\n  reset: () => void,\r\n  on: boolean | ((...args: T) => Observable<any>),\r\n  ...args: T\r\n): Subscription | undefined {\r\n  if (on === true) {\r\n    reset();\r\n    return;\r\n  }\r\n\r\n  if (on === false) {\r\n    return;\r\n  }\r\n\r\n  const onSubscriber = new SafeSubscriber({\r\n    next: () => {\r\n      onSubscriber.unsubscribe();\r\n      reset();\r\n    },\r\n  });\r\n\r\n  return on(...args).subscribe(onSubscriber);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}