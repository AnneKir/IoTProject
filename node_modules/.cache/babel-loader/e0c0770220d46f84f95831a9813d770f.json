{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Action } from './Action';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nvar AsyncAction = function (_super) {\n  __extends(AsyncAction, _super);\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n  AsyncAction.prototype.schedule = function (state, delay) {\n    var _a;\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (this.closed) {\n      return this;\n    }\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n    this.pending = true;\n    this.delay = delay;\n    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n  AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n  AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n    return undefined;\n  };\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n    this.pending = false;\n    var error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n  AsyncAction.prototype._execute = function (state, _delay) {\n    var errored = false;\n    var errorValue;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n  AsyncAction.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      var _a = this,\n        id = _a.id,\n        scheduler = _a.scheduler;\n      var actions = scheduler.actions;\n      this.work = this.state = this.scheduler = null;\n      this.pending = false;\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n      this.delay = null;\n      _super.prototype.unsubscribe.call(this);\n    }\n  };\n  return AsyncAction;\n}(Action);\nexport { AsyncAction };","map":{"version":3,"mappings":"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","names":["Action","intervalProvider","arrRemove","__extends","scheduler","work","_super","_this","AsyncAction","state","delay","closed","id","recycleAsyncId","pending","requestAsyncId","_id","setInterval","flush","bind","_scheduler","clearInterval","undefined","Error","error","_execute","_delay","errored","errorValue","e","unsubscribe","actions"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\scheduler\\AsyncAction.ts"],"sourcesContent":["import { Action } from './Action';\r\nimport { SchedulerAction } from '../types';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { intervalProvider } from './intervalProvider';\r\nimport { arrRemove } from '../util/arrRemove';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsyncAction<T> extends Action<T> {\r\n  public id: TimerHandle | undefined;\r\n  public state?: T;\r\n  // @ts-ignore: Property has no initializer and is not definitely assigned\r\n  public delay: number;\r\n  protected pending: boolean = false;\r\n\r\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n\r\n    // Always replace the current state with the new state.\r\n    this.state = state;\r\n\r\n    const id = this.id;\r\n    const scheduler = this.scheduler;\r\n\r\n    //\r\n    // Important implementation note:\r\n    //\r\n    // Actions only execute once by default, unless rescheduled from within the\r\n    // scheduled callback. This allows us to implement single and repeat\r\n    // actions via the same code path, without adding API surface area, as well\r\n    // as mimic traditional recursion but across asynchronous boundaries.\r\n    //\r\n    // However, JS runtimes and timers distinguish between intervals achieved by\r\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\r\n    // serial `setTimeout` calls can be individually delayed, which delays\r\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\r\n    // guarantee the interval callback will be invoked more precisely to the\r\n    // interval period, regardless of load.\r\n    //\r\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\r\n    // If the action reschedules itself with the same delay, the interval is not\r\n    // canceled. If the action doesn't reschedule, or reschedules with a\r\n    // different delay, the interval will be canceled after scheduled callback\r\n    // execution.\r\n    //\r\n    if (id != null) {\r\n      this.id = this.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Set the pending flag indicating that this action has been scheduled, or\r\n    // has recursively rescheduled itself.\r\n    this.pending = true;\r\n\r\n    this.delay = delay;\r\n    // If this action has already an async Id, don't request a new one.\r\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\r\n\r\n    return this;\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\r\n  }\r\n\r\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\r\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\r\n    if (delay != null && this.delay === delay && this.pending === false) {\r\n      return id;\r\n    }\r\n    // Otherwise, if the action's delay time is different from the current delay,\r\n    // or the action has been rescheduled before it's executed, clear the interval id\r\n    if (id != null) {\r\n      intervalProvider.clearInterval(id);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Immediately executes this action and the `work` it contains.\r\n   * @return {any}\r\n   */\r\n  public execute(state: T, delay: number): any {\r\n    if (this.closed) {\r\n      return new Error('executing a cancelled action');\r\n    }\r\n\r\n    this.pending = false;\r\n    const error = this._execute(state, delay);\r\n    if (error) {\r\n      return error;\r\n    } else if (this.pending === false && this.id != null) {\r\n      // Dequeue if the action didn't reschedule itself. Don't call\r\n      // unsubscribe(), because the action could reschedule later.\r\n      // For example:\r\n      // ```\r\n      // scheduler.schedule(function doWork(counter) {\r\n      //   /* ... I'm a busy worker bee ... */\r\n      //   var originalAction = this;\r\n      //   /* wait 100ms before rescheduling the action */\r\n      //   setTimeout(function () {\r\n      //     originalAction.schedule(counter + 1);\r\n      //   }, 100);\r\n      // }, 1000);\r\n      // ```\r\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\r\n    }\r\n  }\r\n\r\n  protected _execute(state: T, _delay: number): any {\r\n    let errored: boolean = false;\r\n    let errorValue: any;\r\n    try {\r\n      this.work(state);\r\n    } catch (e) {\r\n      errored = true;\r\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\r\n      // return here, we can't have it return \"\" or 0 or false.\r\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\r\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\r\n    }\r\n    if (errored) {\r\n      this.unsubscribe();\r\n      return errorValue;\r\n    }\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.closed) {\r\n      const { id, scheduler } = this;\r\n      const { actions } = scheduler;\r\n\r\n      this.work = this.state = this.scheduler = null!;\r\n      this.pending = false;\r\n\r\n      arrRemove(actions, this);\r\n      if (id != null) {\r\n        this.id = this.recycleAsyncId(scheduler, id, null);\r\n      }\r\n\r\n      this.delay = null!;\r\n      super.unsubscribe();\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}