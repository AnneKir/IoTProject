{"ast":null,"code":"import { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nexport function mergeScan(accumulator, seed, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Infinity;\n  }\n  return operate(function (source, subscriber) {\n    var state = seed;\n    return mergeInternals(source, subscriber, function (value, index) {\n      return accumulator(state, value, index);\n    }, concurrent, function (value) {\n      state = value;\n    }, false, undefined, function () {\n      return state = null;\n    });\n  });\n}","map":{"version":3,"mappings":"AACA,SAASA,OAAO,QAAQ,cAAc;AACtC,SAASC,cAAc,QAAQ,kBAAkB;AAoEjD,OAAM,SAAUC,SAAS,CACvBC,WAAoE,EACpEC,IAAO,EACPC,UAAqB;EAArB;IAAAA,qBAAqB;EAAA;EAErB,OAAOL,OAAO,CAAC,UAACM,MAAM,EAAEC,UAAU;IAEhC,IAAIC,KAAK,GAAGJ,IAAI;IAEhB,OAAOH,cAAc,CACnBK,MAAM,EACNC,UAAU,EACV,UAACE,KAAK,EAAEC,KAAK;MAAK,kBAAW,CAACF,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC;IAAhC,CAAgC,EAClDL,UAAU,EACV,UAACI,KAAK;MACJD,KAAK,GAAGC,KAAK;IACf,CAAC,EACD,KAAK,EACLE,SAAS,EACT;MAAM,OAACH,KAAK,GAAG,IAAK;IAAd,CAAe,CACtB;EACH,CAAC,CAAC;AACJ","names":["operate","mergeInternals","mergeScan","accumulator","seed","concurrent","source","subscriber","state","value","index","undefined"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\mergeScan.ts"],"sourcesContent":["import { ObservableInput, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { mergeInternals } from './mergeInternals';\r\n\r\n/**\r\n * Applies an accumulator function over the source Observable where the\r\n * accumulator function itself returns an Observable, then each intermediate\r\n * Observable returned is merged into the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\r\n * by the accumulator are merged into the outer Observable.</span>\r\n *\r\n * The first parameter of the `mergeScan` is an `accumulator` function which is\r\n * being called every time the source Observable emits a value. `mergeScan` will\r\n * subscribe to the value returned by the `accumulator` function and will emit\r\n * values to the subscriber emitted by inner Observable.\r\n *\r\n * The `accumulator` function is being called with three parameters passed to it:\r\n * `acc`, `value` and `index`. The `acc` parameter is used as the state parameter\r\n * whose value is initially set to the `seed` parameter (the second parameter\r\n * passed to the `mergeScan` operator).\r\n *\r\n * `mergeScan` internally keeps the value of the `acc` parameter: as long as the\r\n * source Observable emits without inner Observable emitting, the `acc` will be\r\n * set to `seed`. The next time the inner Observable emits a value, `mergeScan`\r\n * will internally remember it and it will be passed to the `accumulator`\r\n * function as `acc` parameter the next time source emits.\r\n *\r\n * The `value` parameter of the `accumulator` function is the value emitted by the\r\n * source Observable, while the `index` is a number which represent the order of the\r\n * current emission by the source Observable. It starts with 0.\r\n *\r\n * The last parameter to the `mergeScan` is the `concurrent` value which defaults\r\n * to Infinity. It represents the maximum number of inner Observable subscriptions\r\n * at a time.\r\n *\r\n * ## Example\r\n *\r\n * Count the number of click events\r\n *\r\n * ```ts\r\n * import { fromEvent, map, mergeScan, of } from 'rxjs';\r\n *\r\n * const click$ = fromEvent(document, 'click');\r\n * const one$ = click$.pipe(map(() => 1));\r\n * const seed = 0;\r\n * const count$ = one$.pipe(\r\n *   mergeScan((acc, one) => of(acc + one), seed)\r\n * );\r\n *\r\n * count$.subscribe(x => console.log(x));\r\n *\r\n * // Results:\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * // ...and so on for each click\r\n * ```\r\n *\r\n * @see {@link scan}\r\n * @see {@link switchScan}\r\n *\r\n * @param {function(acc: R, value: T): Observable<R>} accumulator\r\n * The accumulator function called on each source value.\r\n * @param seed The initial accumulation value.\r\n * @param {number} [concurrent=Infinity] Maximum number of\r\n * input Observables being subscribed to concurrently.\r\n * @return A function that returns an Observable of the accumulated values.\r\n */\r\nexport function mergeScan<T, R>(\r\n  accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\r\n  seed: R,\r\n  concurrent = Infinity\r\n): OperatorFunction<T, R> {\r\n  return operate((source, subscriber) => {\r\n    // The accumulated state.\r\n    let state = seed;\r\n\r\n    return mergeInternals(\r\n      source,\r\n      subscriber,\r\n      (value, index) => accumulator(state, value, index),\r\n      concurrent,\r\n      (value) => {\r\n        state = value;\r\n      },\r\n      false,\r\n      undefined,\r\n      () => (state = null!)\r\n    );\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}