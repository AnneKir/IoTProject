{"ast":null,"code":"import { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\nexport function catchError(selector) {\n  return operate(function (source, subscriber) {\n    var innerSub = null;\n    var syncUnsub = false;\n    var handledResult;\n    innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {\n      handledResult = innerFrom(selector(err, catchError(selector)(source)));\n      if (innerSub) {\n        innerSub.unsubscribe();\n        innerSub = null;\n        handledResult.subscribe(subscriber);\n      } else {\n        syncUnsub = true;\n      }\n    }));\n    if (syncUnsub) {\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult.subscribe(subscriber);\n    }\n  });\n}","map":{"version":3,"mappings":"AAIA,SAASA,SAAS,QAAQ,yBAAyB;AACnD,SAASC,wBAAwB,QAAQ,sBAAsB;AAC/D,SAASC,OAAO,QAAQ,cAAc;AAoGtC,OAAM,SAAUC,UAAU,CACxBC,QAAgD;EAEhD,OAAOF,OAAO,CAAC,UAACG,MAAM,EAAEC,UAAU;IAChC,IAAIC,QAAQ,GAAwB,IAAI;IACxC,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,aAA6C;IAEjDF,QAAQ,GAAGF,MAAM,CAACK,SAAS,CACzBT,wBAAwB,CAACK,UAAU,EAAEK,SAAS,EAAEA,SAAS,EAAE,UAACC,GAAG;MAC7DH,aAAa,GAAGT,SAAS,CAACI,QAAQ,CAACQ,GAAG,EAAET,UAAU,CAACC,QAAQ,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC;MACtE,IAAIE,QAAQ,EAAE;QACZA,QAAQ,CAACM,WAAW,EAAE;QACtBN,QAAQ,GAAG,IAAI;QACfE,aAAa,CAACC,SAAS,CAACJ,UAAU,CAAC;OACpC,MAAM;QAGLE,SAAS,GAAG,IAAI;;IAEpB,CAAC,CAAC,CACH;IAED,IAAIA,SAAS,EAAE;MAMbD,QAAQ,CAACM,WAAW,EAAE;MACtBN,QAAQ,GAAG,IAAI;MACfE,aAAc,CAACC,SAAS,CAACJ,UAAU,CAAC;;EAExC,CAAC,CAAC;AACJ","names":["innerFrom","createOperatorSubscriber","operate","catchError","selector","source","subscriber","innerSub","syncUnsub","handledResult","subscribe","undefined","err","unsubscribe"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\catchError.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\n\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { Subscription } from '../Subscription';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { operate } from '../util/lift';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function catchError<T, O extends ObservableInput<any>>(\r\n  selector: (err: any, caught: Observable<T>) => O\r\n): OperatorFunction<T, T | ObservedValueOf<O>>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\r\n *\r\n * <span class=\"informal\">\r\n * It only listens to the error channel and ignores notifications.\r\n * Handles errors from the source observable, and maps them to a new observable.\r\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\r\n * </span>\r\n *\r\n * ![](catch.png)\r\n *\r\n * This operator handles errors, but forwards along all other events to the resulting observable.\r\n * If the source observable terminates with an error, it will map that error to a new observable,\r\n * subscribe to it, and forward all of its events to the resulting observable.\r\n *\r\n * ## Examples\r\n *\r\n * Continue with a different Observable when there's an error\r\n *\r\n * ```ts\r\n * import { of, map, catchError } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5)\r\n *   .pipe(\r\n *     map(n => {\r\n *       if (n === 4) {\r\n *         throw 'four!';\r\n *       }\r\n *       return n;\r\n *     }),\r\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, I, II, III, IV, V\r\n * ```\r\n *\r\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\r\n *\r\n * ```ts\r\n * import { of, map, catchError, take } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5)\r\n *   .pipe(\r\n *     map(n => {\r\n *       if (n === 4) {\r\n *         throw 'four!';\r\n *       }\r\n *       return n;\r\n *     }),\r\n *     catchError((err, caught) => caught),\r\n *     take(30)\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, 1, 2, 3, ...\r\n * ```\r\n *\r\n * Throw a new error when the source Observable throws an error\r\n *\r\n * ```ts\r\n * import { of, map, catchError } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5)\r\n *   .pipe(\r\n *     map(n => {\r\n *       if (n === 4) {\r\n *         throw 'four!';\r\n *       }\r\n *       return n;\r\n *     }),\r\n *     catchError(err => {\r\n *       throw 'error in source. Details: ' + err;\r\n *     })\r\n *   )\r\n *   .subscribe({\r\n *     next: x => console.log(x),\r\n *     error: err => console.log(err)\r\n *   });\r\n *   // 1, 2, 3, error in source. Details: four!\r\n * ```\r\n *\r\n * @see {@link onErrorResumeNext}\r\n * @see {@link repeat}\r\n * @see {@link repeatWhen}\r\n * @see {@link retry }\r\n * @see {@link retryWhen}\r\n *\r\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\r\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\r\n * is returned by the `selector` will be used to continue the observable chain.\r\n * @return A function that returns an Observable that originates from either\r\n * the source or the Observable returned by the `selector` function.\r\n */\r\nexport function catchError<T, O extends ObservableInput<any>>(\r\n  selector: (err: any, caught: Observable<T>) => O\r\n): OperatorFunction<T, T | ObservedValueOf<O>> {\r\n  return operate((source, subscriber) => {\r\n    let innerSub: Subscription | null = null;\r\n    let syncUnsub = false;\r\n    let handledResult: Observable<ObservedValueOf<O>>;\r\n\r\n    innerSub = source.subscribe(\r\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\r\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\r\n        if (innerSub) {\r\n          innerSub.unsubscribe();\r\n          innerSub = null;\r\n          handledResult.subscribe(subscriber);\r\n        } else {\r\n          // We don't have an innerSub yet, that means the error was synchronous\r\n          // because the subscribe call hasn't returned yet.\r\n          syncUnsub = true;\r\n        }\r\n      })\r\n    );\r\n\r\n    if (syncUnsub) {\r\n      // We have a synchronous error, we need to make sure to\r\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\r\n      // at the right time, and that finalization occurs at the expected\r\n      // time between the source error and the subscription to the\r\n      // next observable.\r\n      innerSub.unsubscribe();\r\n      innerSub = null;\r\n      handledResult!.subscribe(subscriber);\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}