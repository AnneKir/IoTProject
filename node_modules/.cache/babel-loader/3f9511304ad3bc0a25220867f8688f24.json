{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nvar OperatorSubscriber = function (_super) {\n  __extends(OperatorSubscriber, _super);\n  function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n    var _this = _super.call(this, destination) || this;\n    _this.onFinalize = onFinalize;\n    _this.shouldUnsubscribe = shouldUnsubscribe;\n    _this._next = onNext ? function (value) {\n      try {\n        onNext(value);\n      } catch (err) {\n        destination.error(err);\n      }\n    } : _super.prototype._next;\n    _this._error = onError ? function (err) {\n      try {\n        onError(err);\n      } catch (err) {\n        destination.error(err);\n      } finally {\n        this.unsubscribe();\n      }\n    } : _super.prototype._error;\n    _this._complete = onComplete ? function () {\n      try {\n        onComplete();\n      } catch (err) {\n        destination.error(err);\n      } finally {\n        this.unsubscribe();\n      }\n    } : _super.prototype._complete;\n    return _this;\n  }\n  OperatorSubscriber.prototype.unsubscribe = function () {\n    var _a;\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      var closed_1 = this.closed;\n      _super.prototype.unsubscribe.call(this);\n      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n    }\n  };\n  return OperatorSubscriber;\n}(Subscriber);\nexport { OperatorSubscriber };","map":{"version":3,"mappings":";AAAA,SAASA,UAAU,QAAQ,eAAe;AAc1C,OAAM,SAAUC,wBAAwB,CACtCC,WAA4B,EAC5BC,MAA2B,EAC3BC,UAAuB,EACvBC,OAA4B,EAC5BC,UAAuB;EAEvB,OAAO,IAAIC,kBAAkB,CAACL,WAAW,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAEC,UAAU,CAAC;AACrF;AAMA;EAA2CE;EAiBzC,4BACEN,WAA4B,EAC5BC,MAA2B,EAC3BC,UAAuB,EACvBC,OAA4B,EACpBC,UAAuB,EACvBG,iBAAiC;IAN3C,YAoBEC,kBAAMR,WAAW,CAAC;IAfVS,gBAAU,GAAVL,UAAU;IACVK,uBAAiB,GAAjBF,iBAAiB;IAezBE,KAAI,CAACC,KAAK,GAAGT,MAAM,GACf,UAAuCU,KAAQ;MAC7C,IAAI;QACFV,MAAM,CAACU,KAAK,CAAC;OACd,CAAC,OAAOC,GAAG,EAAE;QACZZ,WAAW,CAACa,KAAK,CAACD,GAAG,CAAC;;IAE1B,CAAC,GACDJ,iBAAME,KAAK;IACfD,KAAI,CAACK,MAAM,GAAGX,OAAO,GACjB,UAAuCS,GAAQ;MAC7C,IAAI;QACFT,OAAO,CAACS,GAAG,CAAC;OACb,CAAC,OAAOA,GAAG,EAAE;QAEZZ,WAAW,CAACa,KAAK,CAACD,GAAG,CAAC;OACvB,SAAS;QAER,IAAI,CAACG,WAAW,EAAE;;IAEtB,CAAC,GACDP,iBAAMM,MAAM;IAChBL,KAAI,CAACO,SAAS,GAAGd,UAAU,GACvB;MACE,IAAI;QACFA,UAAU,EAAE;OACb,CAAC,OAAOU,GAAG,EAAE;QAEZZ,WAAW,CAACa,KAAK,CAACD,GAAG,CAAC;OACvB,SAAS;QAER,IAAI,CAACG,WAAW,EAAE;;IAEtB,CAAC,GACDP,iBAAMQ,SAAS;;EACrB;EAEAX,wCAAW,GAAX;;IACE,IAAI,CAAC,IAAI,CAACE,iBAAiB,IAAI,IAAI,CAACA,iBAAiB,EAAE,EAAE;MAC/C,YAAM,GAAK,IAAI,OAAT;MACdC,iBAAMO,WAAW,WAAE;MAEnB,CAACE,QAAM,KAAI,UAAI,CAACb,UAAU,+CAAf,IAAI,CAAe;;EAElC,CAAC;EACH,yBAAC;AAAD,CAAC,CAnF0CN,UAAU","names":["Subscriber","createOperatorSubscriber","destination","onNext","onComplete","onError","onFinalize","OperatorSubscriber","__extends","shouldUnsubscribe","_super","_this","_next","value","err","error","_error","unsubscribe","_complete","closed_1"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\OperatorSubscriber.ts"],"sourcesContent":["import { Subscriber } from '../Subscriber';\r\n\r\n/**\r\n * Creates an instance of an `OperatorSubscriber`.\r\n * @param destination The downstream subscriber.\r\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\r\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\r\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\r\n * and send to the `destination` error handler.\r\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\r\n * this handler are sent to the `destination` error handler.\r\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\r\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\r\n */\r\nexport function createOperatorSubscriber<T>(\r\n  destination: Subscriber<any>,\r\n  onNext?: (value: T) => void,\r\n  onComplete?: () => void,\r\n  onError?: (err: any) => void,\r\n  onFinalize?: () => void\r\n): Subscriber<T> {\r\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\r\n}\r\n\r\n/**\r\n * A generic helper for allowing operators to be created with a Subscriber and\r\n * use closures to capture necessary state from the operator function itself.\r\n */\r\nexport class OperatorSubscriber<T> extends Subscriber<T> {\r\n  /**\r\n   * Creates an instance of an `OperatorSubscriber`.\r\n   * @param destination The downstream subscriber.\r\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\r\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\r\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\r\n   * and send to the `destination` error handler.\r\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\r\n   * this handler are sent to the `destination` error handler.\r\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\r\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\r\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\r\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\r\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\r\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\r\n   */\r\n  constructor(\r\n    destination: Subscriber<any>,\r\n    onNext?: (value: T) => void,\r\n    onComplete?: () => void,\r\n    onError?: (err: any) => void,\r\n    private onFinalize?: () => void,\r\n    private shouldUnsubscribe?: () => boolean\r\n  ) {\r\n    // It's important - for performance reasons - that all of this class's\r\n    // members are initialized and that they are always initialized in the same\r\n    // order. This will ensure that all OperatorSubscriber instances have the\r\n    // same hidden class in V8. This, in turn, will help keep the number of\r\n    // hidden classes involved in property accesses within the base class as\r\n    // low as possible. If the number of hidden classes involved exceeds four,\r\n    // the property accesses will become megamorphic and performance penalties\r\n    // will be incurred - i.e. inline caches won't be used.\r\n    //\r\n    // The reasons for ensuring all instances have the same hidden class are\r\n    // further discussed in this blog post from Benedikt Meurer:\r\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\r\n    super(destination);\r\n    this._next = onNext\r\n      ? function (this: OperatorSubscriber<T>, value: T) {\r\n          try {\r\n            onNext(value);\r\n          } catch (err) {\r\n            destination.error(err);\r\n          }\r\n        }\r\n      : super._next;\r\n    this._error = onError\r\n      ? function (this: OperatorSubscriber<T>, err: any) {\r\n          try {\r\n            onError(err);\r\n          } catch (err) {\r\n            // Send any errors that occur down stream.\r\n            destination.error(err);\r\n          } finally {\r\n            // Ensure finalization.\r\n            this.unsubscribe();\r\n          }\r\n        }\r\n      : super._error;\r\n    this._complete = onComplete\r\n      ? function (this: OperatorSubscriber<T>) {\r\n          try {\r\n            onComplete();\r\n          } catch (err) {\r\n            // Send any errors that occur down stream.\r\n            destination.error(err);\r\n          } finally {\r\n            // Ensure finalization.\r\n            this.unsubscribe();\r\n          }\r\n        }\r\n      : super._complete;\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\r\n      const { closed } = this;\r\n      super.unsubscribe();\r\n      // Execute additional teardown if we have any and we didn't already do so.\r\n      !closed && this.onFinalize?.();\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}