{"ast":null,"code":"import { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function of() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var scheduler = popScheduler(args);\n  return from(args, scheduler);\n}","map":{"version":3,"mappings":"AAEA,SAASA,YAAY,QAAQ,cAAc;AAC3C,SAASC,IAAI,QAAQ,QAAQ;AA4E7B,OAAM,SAAUC,EAAE;EAAI;OAAA,UAAiC,EAAjCC,qBAAiC,EAAjCA,IAAiC;IAAjCC;;EACpB,IAAMC,SAAS,GAAGL,YAAY,CAACI,IAAI,CAAC;EACpC,OAAOH,IAAI,CAACG,IAAW,EAAEC,SAAS,CAAC;AACrC","names":["popScheduler","from","of","_i","args","scheduler"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\of.ts"],"sourcesContent":["import { SchedulerLike, ValueFromArray } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\n// Devs are more likely to pass null or undefined than they are a scheduler\r\n// without accompanying values. To make things easier for (naughty) devs who\r\n// use the `strictNullChecks: false` TypeScript compiler option, these\r\n// overloads with explicit null and undefined values are included.\r\n\r\nexport function of(value: null): Observable<null>;\r\nexport function of(value: undefined): Observable<undefined>;\r\n\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function of(scheduler: SchedulerLike): Observable<never>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\r\n\r\nexport function of(): Observable<never>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function of<T>(): Observable<T>;\r\nexport function of<T>(value: T): Observable<T>;\r\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\r\n\r\n/**\r\n * Converts the arguments to an observable sequence.\r\n *\r\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\r\n *\r\n * ![](of.png)\r\n *\r\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\r\n * as a separate `next` notification.\r\n *\r\n * ## Examples\r\n *\r\n * Emit the values `10, 20, 30`\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n *\r\n * of(10, 20, 30)\r\n *   .subscribe({\r\n *     next: value => console.log('next:', value),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // Outputs\r\n * // next: 10\r\n * // next: 20\r\n * // next: 30\r\n * // the end\r\n * ```\r\n *\r\n * Emit the array `[1, 2, 3]`\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n *\r\n * of([1, 2, 3])\r\n *   .subscribe({\r\n *     next: value => console.log('next:', value),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // Outputs\r\n * // next: [1, 2, 3]\r\n * // the end\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link range}\r\n *\r\n * @param {...T} values A comma separated list of arguments you want to be emitted\r\n * @return {Observable} An Observable that emits the arguments\r\n * described above and then completes.\r\n */\r\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\r\n  const scheduler = popScheduler(args);\r\n  return from(args as T[], scheduler);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}