{"ast":null,"code":"import { bindCallbackInternals } from './bindCallbackInternals';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}","map":{"version":3,"mappings":"AAGA,SAASA,qBAAqB,QAAQ,yBAAyB;AAsH/D,OAAM,SAAUC,gBAAgB,CAC9BC,YAA4E,EAC5EC,cAA0D,EAC1DC,SAAyB;EAEzB,OAAOJ,qBAAqB,CAAC,IAAI,EAAEE,YAAY,EAAEC,cAAc,EAAEC,SAAS,CAAC;AAC7E","names":["bindCallbackInternals","bindNodeCallback","callbackFunc","resultSelector","scheduler"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\bindNodeCallback.ts"],"sourcesContent":["/* @prettier */\r\nimport { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a Node.js-style callback API to a function that returns an\r\n * Observable.\r\n *\r\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\r\n * callback is expected to be of type `callback(error, result)`.</span>\r\n *\r\n * `bindNodeCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters, but the\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done. The callback function is expected to follow Node.js conventions,\r\n * where the first argument to the callback is an error object, signaling\r\n * whether call was successful. If that object is passed to callback, it means\r\n * something went wrong.\r\n *\r\n * The output of `bindNodeCallback` is a function that takes the same\r\n * parameters as `func`, except the last one (the callback). When the output\r\n * function is called with arguments, it will return an Observable.\r\n * If `func` calls its callback with error parameter present, Observable will\r\n * error with that value as well. If error parameter is not passed, Observable will emit\r\n * second parameter. If there are more parameters (third and so on),\r\n * Observable will emit an array with all arguments, except first error argument.\r\n *\r\n * Note that `func` will not be called at the same time output function is,\r\n * but rather whenever resulting Observable is subscribed. By default call to\r\n * `func` will happen synchronously after subscription, but that can be changed\r\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\r\n * can also control when values from callback will be emitted by Observable.\r\n * To find out more, check out documentation for {@link bindCallback}, where\r\n * {@link SchedulerLike} works exactly the same.\r\n *\r\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\r\n * of returned function, when it is called.\r\n *\r\n * After Observable emits value, it will complete immediately. This means\r\n * even if `func` calls callback again, values from second and consecutive\r\n * calls will never appear on the stream. If you need to handle functions\r\n * that call callbacks multiple times, check out {@link fromEvent} or\r\n * {@link fromEventPattern} instead.\r\n *\r\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\r\n * \"Node.js-style\" callbacks are just a convention, so if you write for\r\n * browsers or any other environment and API you use implements that callback style,\r\n * `bindNodeCallback` can be safely used on that API functions as well.\r\n *\r\n * Remember that Error object passed to callback does not have to be an instance\r\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\r\n * Error parameter of callback function is interpreted as \"present\", when value\r\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\r\n * string or boolean `true`. In all of these cases resulting Observable would error\r\n * with that value. This means usually regular style callbacks will fail very often when\r\n * `bindNodeCallback` is used. If your Observable errors much more often then you\r\n * would expect, check if callback really is called in Node.js-style and, if not,\r\n * switch to {@link bindCallback} instead.\r\n *\r\n * Note that even if error parameter is technically present in callback, but its value\r\n * is falsy, it still won't appear in array emitted by Observable.\r\n *\r\n * ## Examples\r\n * ###  Read a file from the filesystem and get the data as an Observable\r\n * ```ts\r\n * import * as fs from 'fs';\r\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\r\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * ### Use on function calling callback with multiple arguments\r\n * ```ts\r\n * someFunction((err, a, b) => {\r\n *   console.log(err); // null\r\n *   console.log(a); // 5\r\n *   console.log(b); // \"some string\"\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(value => {\r\n *   console.log(value); // [5, \"some string\"]\r\n * });\r\n * ```\r\n *\r\n * ### Use on function calling callback in regular style\r\n * ```ts\r\n * someFunction(a => {\r\n *   console.log(a); // 5\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(\r\n *   value => {}             // never gets called\r\n *   err => console.log(err) // 5\r\n * );\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link from}\r\n *\r\n * @param {function} func Function with a Node.js-style callback as the last parameter.\r\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\r\n * callbacks.\r\n * @return {function(...params: *): Observable} A function which returns the\r\n * Observable that delivers the same values the Node.js callback would\r\n * deliver.\r\n */\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any> {\r\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}