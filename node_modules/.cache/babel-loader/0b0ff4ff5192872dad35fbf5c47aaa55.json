{"ast":null,"code":"import { Observable } from '../../Observable';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\nexport function animationFrames(timestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\nfunction animationFramesFactory(timestampProvider) {\n  return new Observable(function (subscriber) {\n    var provider = timestampProvider || performanceTimestampProvider;\n    var start = provider.now();\n    var id = 0;\n    var run = function () {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame(function (timestamp) {\n          id = 0;\n          var now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start\n          });\n          run();\n        });\n      }\n    };\n    run();\n    return function () {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\nvar DEFAULT_ANIMATION_FRAMES = animationFramesFactory();","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,kBAAkB;AAE7C,SAASC,4BAA4B,QAAQ,8CAA8C;AAC3F,SAASC,sBAAsB,QAAQ,wCAAwC;AAuE/E,OAAM,SAAUC,eAAe,CAACC,iBAAqC;EACnE,OAAOA,iBAAiB,GAAGC,sBAAsB,CAACD,iBAAiB,CAAC,GAAGE,wBAAwB;AACjG;AAMA,SAASD,sBAAsB,CAACD,iBAAqC;EACnE,OAAO,IAAIJ,UAAU,CAAyC,UAACO,UAAU;IAIvE,IAAMC,QAAQ,GAAGJ,iBAAiB,IAAIH,4BAA4B;IAMlE,IAAMQ,KAAK,GAAGD,QAAQ,CAACE,GAAG,EAAE;IAE5B,IAAIC,EAAE,GAAG,CAAC;IACV,IAAMC,GAAG,GAAG;MACV,IAAI,CAACL,UAAU,CAACM,MAAM,EAAE;QACtBF,EAAE,GAAGT,sBAAsB,CAACY,qBAAqB,CAAC,UAACC,SAAuC;UACxFJ,EAAE,GAAG,CAAC;UAQN,IAAMD,GAAG,GAAGF,QAAQ,CAACE,GAAG,EAAE;UAC1BH,UAAU,CAACS,IAAI,CAAC;YACdD,SAAS,EAAEX,iBAAiB,GAAGM,GAAG,GAAGK,SAAS;YAC9CE,OAAO,EAAEP,GAAG,GAAGD;WAChB,CAAC;UACFG,GAAG,EAAE;QACP,CAAC,CAAC;;IAEN,CAAC;IAEDA,GAAG,EAAE;IAEL,OAAO;MACL,IAAID,EAAE,EAAE;QACNT,sBAAsB,CAACgB,oBAAoB,CAACP,EAAE,CAAC;;IAEnD,CAAC;EACH,CAAC,CAAC;AACJ;AAMA,IAAML,wBAAwB,GAAGD,sBAAsB,EAAE","names":["Observable","performanceTimestampProvider","animationFrameProvider","animationFrames","timestampProvider","animationFramesFactory","DEFAULT_ANIMATION_FRAMES","subscriber","provider","start","now","id","run","closed","requestAnimationFrame","timestamp","next","elapsed","cancelAnimationFrame"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\dom\\animationFrames.ts"],"sourcesContent":["import { Observable } from '../../Observable';\r\nimport { TimestampProvider } from '../../types';\r\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\r\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\r\n\r\n/**\r\n * An observable of animation frames\r\n *\r\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\r\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\r\n *\r\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\r\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\r\n * should not be much different or have more overhead than looping over an array of events during\r\n * a single animation frame. However, if for some reason the developer would like to ensure the\r\n * execution of animation-related handlers are all executed during the same task by the engine,\r\n * the `share` operator can be used.\r\n *\r\n * This is useful for setting up animations with RxJS.\r\n *\r\n * ## Examples\r\n *\r\n * Tweening a div to move it on the screen\r\n *\r\n * ```ts\r\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\r\n *\r\n * function tween(start: number, end: number, duration: number) {\r\n *   const diff = end - start;\r\n *   return animationFrames().pipe(\r\n *     // Figure out what percentage of time has passed\r\n *     map(({ elapsed }) => elapsed / duration),\r\n *     // Take the vector while less than 100%\r\n *     takeWhile(v => v < 1),\r\n *     // Finish with 100%\r\n *     endWith(1),\r\n *     // Calculate the distance traveled between start and end\r\n *     map(v => v * diff + start)\r\n *   );\r\n * }\r\n *\r\n * // Setup a div for us to move around\r\n * const div = document.createElement('div');\r\n * document.body.appendChild(div);\r\n * div.style.position = 'absolute';\r\n * div.style.width = '40px';\r\n * div.style.height = '40px';\r\n * div.style.backgroundColor = 'lime';\r\n * div.style.transform = 'translate3d(10px, 0, 0)';\r\n *\r\n * tween(10, 200, 4000).subscribe(x => {\r\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\r\n * });\r\n * ```\r\n *\r\n * Providing a custom timestamp provider\r\n *\r\n * ```ts\r\n * import { animationFrames, TimestampProvider } from 'rxjs';\r\n *\r\n * // A custom timestamp provider\r\n * let now = 0;\r\n * const customTSProvider: TimestampProvider = {\r\n *   now() { return now++; }\r\n * };\r\n *\r\n * const source$ = animationFrames(customTSProvider);\r\n *\r\n * // Log increasing numbers 0...1...2... on every animation frame.\r\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\r\n * ```\r\n *\r\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\r\n */\r\nexport function animationFrames(timestampProvider?: TimestampProvider) {\r\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\r\n}\r\n\r\n/**\r\n * Does the work of creating the observable for `animationFrames`.\r\n * @param timestampProvider The timestamp provider to use to create the observable\r\n */\r\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\r\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\r\n    // If no timestamp provider is specified, use performance.now() - as it\r\n    // will return timestamps 'compatible' with those passed to the run\r\n    // callback and won't be affected by NTP adjustments, etc.\r\n    const provider = timestampProvider || performanceTimestampProvider;\r\n\r\n    // Capture the start time upon subscription, as the run callback can remain\r\n    // queued for a considerable period of time and the elapsed time should\r\n    // represent the time elapsed since subscription - not the time since the\r\n    // first rendered animation frame.\r\n    const start = provider.now();\r\n\r\n    let id = 0;\r\n    const run = () => {\r\n      if (!subscriber.closed) {\r\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\r\n          id = 0;\r\n          // Use the provider's timestamp to calculate the elapsed time. Note that\r\n          // this means - if the caller hasn't passed a provider - that\r\n          // performance.now() will be used instead of the timestamp that was\r\n          // passed to the run callback. The reason for this is that the timestamp\r\n          // passed to the callback can be earlier than the start time, as it\r\n          // represents the time at which the browser decided it would render any\r\n          // queued frames - and that time can be earlier the captured start time.\r\n          const now = provider.now();\r\n          subscriber.next({\r\n            timestamp: timestampProvider ? now : timestamp,\r\n            elapsed: now - start,\r\n          });\r\n          run();\r\n        });\r\n      }\r\n    };\r\n\r\n    run();\r\n\r\n    return () => {\r\n      if (id) {\r\n        animationFrameProvider.cancelAnimationFrame(id);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * In the common case, where the timestamp provided by the rAF API is used,\r\n * we use this shared observable to reduce overhead.\r\n */\r\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\r\n"]},"metadata":{},"sourceType":"module"}