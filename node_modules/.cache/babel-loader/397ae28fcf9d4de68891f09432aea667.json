{"ast":null,"code":"import { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nexport function windowWhen(closingSelector) {\n  return operate(function (source, subscriber) {\n    var window;\n    var closingSubscriber;\n    var handleError = function handleError(err) {\n      window.error(err);\n      subscriber.error(err);\n    };\n    var openWindow = function openWindow() {\n      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();\n      window === null || window === void 0 ? void 0 : window.complete();\n      window = new Subject();\n      subscriber.next(window.asObservable());\n      var closingNotifier;\n      try {\n        closingNotifier = innerFrom(closingSelector());\n      } catch (err) {\n        handleError(err);\n        return;\n      }\n      closingNotifier.subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));\n    };\n    openWindow();\n    source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n      return window.next(value);\n    }, function () {\n      window.complete();\n      subscriber.complete();\n    }, handleError, function () {\n      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();\n      window = null;\n    }));\n  });\n}","map":{"version":3,"mappings":"AAEA,SAASA,OAAO,QAAQ,YAAY;AAEpC,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,wBAAwB,QAAQ,sBAAsB;AAC/D,SAASC,SAAS,QAAQ,yBAAyB;AA8CnD,OAAM,SAAUC,UAAU,CAAIC,eAA2C;EACvE,OAAOJ,OAAO,CAAC,UAACK,MAAM,EAAEC,UAAU;IAChC,IAAIC,MAAyB;IAC7B,IAAIC,iBAA8C;IAMlD,IAAMC,WAAW,GAAG,SAAdA,WAAW,CAAIC,GAAQ;MAC3BH,MAAO,CAACI,KAAK,CAACD,GAAG,CAAC;MAClBJ,UAAU,CAACK,KAAK,CAACD,GAAG,CAAC;IACvB,CAAC;IAQD,IAAME,UAAU,GAAG,SAAbA,UAAU,GAAG;MAGjBJ,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,CAAEK,WAAW,EAAE;MAGhCN,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEO,QAAQ,EAAE;MAGlBP,MAAM,GAAG,IAAIR,OAAO,EAAK;MACzBO,UAAU,CAACS,IAAI,CAACR,MAAM,CAACS,YAAY,EAAE,CAAC;MAGtC,IAAIC,eAAgC;MACpC,IAAI;QACFA,eAAe,GAAGf,SAAS,CAACE,eAAe,EAAE,CAAC;OAC/C,CAAC,OAAOM,GAAG,EAAE;QACZD,WAAW,CAACC,GAAG,CAAC;QAChB;;MAOFO,eAAe,CAACC,SAAS,CAAEV,iBAAiB,GAAGP,wBAAwB,CAACK,UAAU,EAAEM,UAAU,EAAEA,UAAU,EAAEH,WAAW,CAAC,CAAE;IAC5H,CAAC;IAGDG,UAAU,EAAE;IAGZP,MAAM,CAACa,SAAS,CACdjB,wBAAwB,CACtBK,UAAU,EACV,UAACa,KAAK;MAAK,aAAO,CAACJ,IAAI,CAACI,KAAK,CAAC;IAAnB,CAAmB,EAC9B;MAEEZ,MAAO,CAACO,QAAQ,EAAE;MAClBR,UAAU,CAACQ,QAAQ,EAAE;IACvB,CAAC,EACDL,WAAW,EACX;MAGED,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,CAAEK,WAAW,EAAE;MAChCN,MAAM,GAAG,IAAK;IAChB,CAAC,CACF,CACF;EACH,CAAC,CAAC;AACJ","names":["Subject","operate","createOperatorSubscriber","innerFrom","windowWhen","closingSelector","source","subscriber","window","closingSubscriber","handleError","err","error","openWindow","unsubscribe","complete","next","asObservable","closingNotifier","subscribe","value"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\windowWhen.ts"],"sourcesContent":["import { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { ObservableInput, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable using a\r\n * factory function of closing Observables to determine when to start a new\r\n * window.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowWhen.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits connected, non-overlapping windows.\r\n * It emits the current window and opens a new one whenever the Observable\r\n * produced by the specified `closingSelector` function emits an item. The first\r\n * window is opened immediately when subscribing to the output Observable.\r\n *\r\n * ## Example\r\n *\r\n * Emit only the first two clicks events in every window of [1-5] random seconds\r\n *\r\n * ```ts\r\n * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\r\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowCount}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link bufferWhen}\r\n *\r\n * @param {function(): Observable} closingSelector A function that takes no\r\n * arguments and returns an Observable that signals (on either `next` or\r\n * `complete`) when to close the previous window and start a new one.\r\n * @return A function that returns an Observable of windows, which in turn are\r\n * Observables.\r\n */\r\nexport function windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>> {\r\n  return operate((source, subscriber) => {\r\n    let window: Subject<T> | null;\r\n    let closingSubscriber: Subscriber<any> | undefined;\r\n\r\n    /**\r\n     * When we get an error, we have to notify both the\r\n     * destination subscriber and the window.\r\n     */\r\n    const handleError = (err: any) => {\r\n      window!.error(err);\r\n      subscriber.error(err);\r\n    };\r\n\r\n    /**\r\n     * Called every time we need to open a window.\r\n     * Recursive, as it will start the closing notifier, which\r\n     * inevitably *should* call openWindow -- but may not if\r\n     * it is a \"never\" observable.\r\n     */\r\n    const openWindow = () => {\r\n      // We need to clean up our closing subscription,\r\n      // we only cared about the first next or complete notification.\r\n      closingSubscriber?.unsubscribe();\r\n\r\n      // Close our window before starting a new one.\r\n      window?.complete();\r\n\r\n      // Start the new window.\r\n      window = new Subject<T>();\r\n      subscriber.next(window.asObservable());\r\n\r\n      // Get our closing notifier.\r\n      let closingNotifier: Observable<any>;\r\n      try {\r\n        closingNotifier = innerFrom(closingSelector());\r\n      } catch (err) {\r\n        handleError(err);\r\n        return;\r\n      }\r\n\r\n      // Subscribe to the closing notifier, be sure\r\n      // to capture the subscriber (aka Subscription)\r\n      // so we can clean it up when we close the window\r\n      // and open a new one.\r\n      closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\r\n    };\r\n\r\n    // Start the first window.\r\n    openWindow();\r\n\r\n    // Subscribe to the source\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => window!.next(value),\r\n        () => {\r\n          // The source completed, close the window and complete.\r\n          window!.complete();\r\n          subscriber.complete();\r\n        },\r\n        handleError,\r\n        () => {\r\n          // Be sure to clean up our closing subscription\r\n          // when this tears down.\r\n          closingSubscriber?.unsubscribe();\r\n          window = null!;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}