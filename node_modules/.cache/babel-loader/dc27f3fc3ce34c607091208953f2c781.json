{"ast":null,"code":"import { __generator } from \"tslib\";\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nimport { defer } from './defer';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {\n  var _a, _b;\n  var resultSelector;\n  var initialState;\n  if (arguments.length === 1) {\n    _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity : _b, scheduler = _a.scheduler;\n  } else {\n    initialState = initialStateOrOptions;\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\n      resultSelector = identity;\n      scheduler = resultSelectorOrScheduler;\n    } else {\n      resultSelector = resultSelectorOrScheduler;\n    }\n  }\n  function gen() {\n    var state;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          state = initialState;\n          _a.label = 1;\n        case 1:\n          if (!(!condition || condition(state))) return [3, 4];\n          return [4, resultSelector(state)];\n        case 2:\n          _a.sent();\n          _a.label = 3;\n        case 3:\n          state = iterate(state);\n          return [3, 1];\n        case 4:\n          return [2];\n      }\n    });\n  }\n  return defer(scheduler ? function () {\n    return scheduleIterable(gen(), scheduler);\n  } : gen);\n}","map":{"version":3,"mappings":";AACA,SAASA,QAAQ,QAAQ,kBAAkB;AAE3C,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASC,KAAK,QAAQ,SAAS;AAC/B,SAASC,gBAAgB,QAAQ,+BAA+B;AAuUhE,OAAM,SAAUC,QAAQ,CACtBC,qBAAgD,EAChDC,SAA4B,EAC5BC,OAAwB,EACxBC,yBAA4D,EAC5DC,SAAyB;;EAEzB,IAAIC,cAAgC;EACpC,IAAIC,YAAe;EAInB,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;IAGzBC,KAMGT,qBAA8C,EALhDM,YAAY,oBACZL,SAAS,iBACTC,OAAO,eACPQ,sBAA6C,EAA7CL,cAAc,mBAAGV,QAA4B,OAC7CS,SAAS;GAEZ,MAAM;IAGLE,YAAY,GAAGN,qBAA0B;IACzC,IAAI,CAACG,yBAAyB,IAAIP,WAAW,CAACO,yBAAyB,CAAC,EAAE;MACxEE,cAAc,GAAGV,QAA4B;MAC7CS,SAAS,GAAGD,yBAA0C;KACvD,MAAM;MACLE,cAAc,GAAGF,yBAA6C;;;EAKlE,SAAUQ,GAAG;;;;;UACFC,KAAK,GAAGN,YAAY;;;gBAAE,CAACL,SAAS,IAAIA,SAAS,CAACW,KAAK,CAAC;UAC3D,WAAMP,cAAc,CAACO,KAAK,CAAC;;UAA3BH,SAA2B;;;UADkCG,KAAK,GAAGV,OAAQ,CAACU,KAAK,CAAC;;;;;;;EAMxF,OAAOf,KAAK,CACTO,SAAS,GAGN;IAAM,uBAAgB,CAACO,GAAG,EAAE,EAAEP,SAAU,CAAC;EAAnC,CAAmC,GAGzCO,GAAG,CACR;AACH","names":["identity","isScheduler","defer","scheduleIterable","generate","initialStateOrOptions","condition","iterate","resultSelectorOrScheduler","scheduler","resultSelector","initialState","arguments","length","_a","_b","gen","state"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\generate.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { identity } from '../util/identity';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { defer } from './defer';\r\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\r\n\r\ntype ConditionFunc<S> = (state: S) => boolean;\r\ntype IterateFunc<S> = (state: S) => S;\r\ntype ResultFunc<S, T> = (state: S) => T;\r\n\r\nexport interface GenerateBaseOptions<S> {\r\n  /**\r\n   * Initial state.\r\n   */\r\n  initialState: S;\r\n  /**\r\n   * Condition function that accepts state and returns boolean.\r\n   * When it returns false, the generator stops.\r\n   * If not specified, a generator never stops.\r\n   */\r\n  condition?: ConditionFunc<S>;\r\n  /**\r\n   * Iterate function that accepts state and returns new state.\r\n   */\r\n  iterate: IterateFunc<S>;\r\n  /**\r\n   * SchedulerLike to use for generation process.\r\n   * By default, a generator starts immediately.\r\n   */\r\n  scheduler?: SchedulerLike;\r\n}\r\n\r\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\r\n  /**\r\n   * Result selection function that accepts state and returns a value to emit.\r\n   */\r\n  resultSelector: ResultFunc<S, T>;\r\n}\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Produces sequence of numbers\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * ```\r\n *\r\n * Use `asapScheduler`\r\n *\r\n * ```ts\r\n * import { generate, asapScheduler } from 'rxjs';\r\n *\r\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 2\r\n * // 3\r\n * // 5\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param {S} initialState Initial state.\r\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\r\n * @param {function (state: S): S} iterate Iteration step function.\r\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\r\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\r\n * @returns {Observable<T>} The generated sequence.\r\n * @deprecated Instead of passing separate arguments, use the options argument. Signatures taking separate arguments will be removed in v8.\r\n */\r\nexport function generate<T, S>(\r\n  initialState: S,\r\n  condition: ConditionFunc<S>,\r\n  iterate: IterateFunc<S>,\r\n  resultSelector: ResultFunc<S, T>,\r\n  scheduler?: SchedulerLike\r\n): Observable<T>;\r\n\r\n/**\r\n * Generates an Observable by running a state-driven loop\r\n * that emits an element on each iteration.\r\n *\r\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\r\n *\r\n * ![](generate.png)\r\n *\r\n * `generate` allows you to create a stream of values generated with a loop very similar to\r\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\r\n * is a function that accepts this value and tests if some condition still holds. If it does,\r\n * then the loop continues, if not, it stops. The third value is a function which takes the\r\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\r\n * are direct equivalents of three expressions in a traditional for loop: the first expression\r\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\r\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\r\n * will be modified on every step (for example, the index will be incremented by one).\r\n *\r\n * Return value of a `generate` operator is an Observable that on each loop iteration\r\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\r\n * emits the currently stored value (initial value at the first iteration) and finally updates\r\n * that value with iterate function. If at some point the condition returns false, then the Observable\r\n * completes at that moment.\r\n *\r\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\r\n * to immediately map the value that would normally be emitted by an Observable.\r\n *\r\n * If you find three anonymous functions in `generate` call hard to read, you can provide\r\n * a single object to the operator instead where the object has the properties: `initialState`,\r\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\r\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\r\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\r\n * condition always holds, or in other words the resulting Observable will never complete.\r\n *\r\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\r\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\r\n * function or not). In case of a single-parameter call, you can provide it as a\r\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\r\n * the next iteration of the loop will happen and therefore when the next value will be emitted\r\n * by the Observable. For example, to ensure that each value is pushed to the Observer\r\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\r\n * by default (when no scheduler is passed) values are simply emitted synchronously.\r\n *\r\n *\r\n * ## Examples\r\n *\r\n * Use with condition and iterate functions\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1);\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use with condition, iterate and resultSelector functions\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use with options object\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition(value) { return value < 3; },\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use options object without condition function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!') // This will never run\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 3000\r\n * // ...and never stops.\r\n * ```\r\n *\r\n * @see {@link from}\r\n *\r\n * @param {S} initialState Initial state.\r\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\r\n * @param {function (state: S): S} iterate Iteration step function.\r\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\r\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\r\n * @return {Observable<T>} The generated sequence.\r\n * @deprecated Instead of passing separate arguments, use the options argument. Signatures taking separate arguments will be removed in v8.\r\n */\r\nexport function generate<S>(\r\n  initialState: S,\r\n  condition: ConditionFunc<S>,\r\n  iterate: IterateFunc<S>,\r\n  scheduler?: SchedulerLike\r\n): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Use options object with condition function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 3,\r\n *   iterate: x => x + 1\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\r\n * @returns {Observable<S>} The generated sequence.\r\n */\r\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition, result selector and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Use options object with condition and iterate function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 3,\r\n *   iterate: x => x + 1,\r\n *   resultSelector: x => x\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\r\n * @returns {Observable<T>} The generated sequence.\r\n */\r\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\r\n\r\nexport function generate<T, S>(\r\n  initialStateOrOptions: S | GenerateOptions<T, S>,\r\n  condition?: ConditionFunc<S>,\r\n  iterate?: IterateFunc<S>,\r\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): Observable<T> {\r\n  let resultSelector: ResultFunc<S, T>;\r\n  let initialState: S;\r\n\r\n  // TODO: Remove this as we move away from deprecated signatures\r\n  // and move towards a configuration object argument.\r\n  if (arguments.length === 1) {\r\n    // If we only have one argument, we can assume it is a configuration object.\r\n    // Note that folks not using TypeScript may trip over this.\r\n    ({\r\n      initialState,\r\n      condition,\r\n      iterate,\r\n      resultSelector = identity as ResultFunc<S, T>,\r\n      scheduler,\r\n    } = initialStateOrOptions as GenerateOptions<T, S>);\r\n  } else {\r\n    // Deprecated arguments path. Figure out what the user\r\n    // passed and set it here.\r\n    initialState = initialStateOrOptions as S;\r\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\r\n      resultSelector = identity as ResultFunc<S, T>;\r\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\r\n    } else {\r\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\r\n    }\r\n  }\r\n\r\n  // The actual generator used to \"generate\" values.\r\n  function* gen() {\r\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\r\n      yield resultSelector(state);\r\n    }\r\n  }\r\n\r\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\r\n  return defer(\r\n    (scheduler\r\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\r\n        // happens on the scheduler.\r\n        () => scheduleIterable(gen(), scheduler!)\r\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\r\n        // `defer` and executing it will return the generator (which is iterable).\r\n        gen) as () => ObservableInput<T>\r\n  );\r\n}\r\n"]},"metadata":{},"sourceType":"module"}