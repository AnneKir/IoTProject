{"ast":null,"code":"import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return concatAll()(from(args, popScheduler(args)));\n}","map":{"version":3,"mappings":"AAEA,SAASA,SAAS,QAAQ,wBAAwB;AAClD,SAASC,YAAY,QAAQ,cAAc;AAC3C,SAASC,IAAI,QAAQ,QAAQ;AA4G7B,OAAM,SAAUC,MAAM;EAAC;OAAA,UAAc,EAAdC,qBAAc,EAAdA,IAAc;IAAdC;;EACrB,OAAOL,SAAS,EAAE,CAACE,IAAI,CAACG,IAAI,EAAEJ,YAAY,CAACI,IAAI,CAAC,CAAC,CAAC;AACpD","names":["concatAll","popScheduler","from","concat","_i","args"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\concat.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { ObservableInputTuple, SchedulerLike } from '../types';\r\nimport { concatAll } from '../operators/concatAll';\r\nimport { popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\r\nexport function concat<T extends readonly unknown[]>(\r\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\r\n): Observable<T[number]>;\r\n\r\n/**\r\n * Creates an output Observable which sequentially emits all values from the first given\r\n * Observable and then moves on to the next.\r\n *\r\n * <span class=\"informal\">Concatenates multiple Observables together by\r\n * sequentially emitting their values, one Observable after the other.</span>\r\n *\r\n * ![](concat.png)\r\n *\r\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\r\n * merging their results into the output Observable. You can pass either an array of\r\n * Observables, or put them directly as arguments. Passing an empty array will result\r\n * in Observable that completes immediately.\r\n *\r\n * `concat` will subscribe to first input Observable and emit all its values, without\r\n * changing or affecting them in any way. When that Observable completes, it will\r\n * subscribe to then next Observable passed and, again, emit its values. This will be\r\n * repeated, until the operator runs out of Observables. When last input Observable completes,\r\n * `concat` will complete as well. At any given moment only one Observable passed to operator\r\n * emits values. If you would like to emit values from passed Observables concurrently, check out\r\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\r\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\r\n *\r\n * Note that if some input Observable never completes, `concat` will also never complete\r\n * and Observables following the one that did not complete will never be subscribed. On the other\r\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\r\n * invisible for `concat`, which will just move on to the next Observable.\r\n *\r\n * If any Observable in chain errors, instead of passing control to the next Observable,\r\n * `concat` will error immediately as well. Observables that would be subscribed after\r\n * the one that emitted error, never will.\r\n *\r\n * If you pass to `concat` the same Observable many times, its stream of values\r\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\r\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\r\n * you can always use {@link repeat}.\r\n *\r\n * ## Examples\r\n *\r\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\r\n *\r\n * ```ts\r\n * import { interval, take, range, concat } from 'rxjs';\r\n *\r\n * const timer = interval(1000).pipe(take(4));\r\n * const sequence = range(1, 10);\r\n * const result = concat(timer, sequence);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // results in:\r\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\r\n * ```\r\n *\r\n * Concatenate 3 Observables\r\n *\r\n * ```ts\r\n * import { interval, take, concat } from 'rxjs';\r\n *\r\n * const timer1 = interval(1000).pipe(take(10));\r\n * const timer2 = interval(2000).pipe(take(6));\r\n * const timer3 = interval(500).pipe(take(10));\r\n *\r\n * const result = concat(timer1, timer2, timer3);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // results in the following:\r\n * // (Prints to console sequentially)\r\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\r\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\r\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\r\n * ```\r\n *\r\n * Concatenate the same Observable to repeat it\r\n *\r\n * ```ts\r\n * import { interval, take, concat } from 'rxjs';\r\n *\r\n * const timer = interval(1000).pipe(take(2));\r\n *\r\n * concat(timer, timer) // concatenating the same Observable!\r\n *   .subscribe({\r\n *     next: value => console.log(value),\r\n *     complete: () => console.log('...and it is done!')\r\n *   });\r\n *\r\n * // Logs:\r\n * // 0 after 1s\r\n * // 1 after 2s\r\n * // 0 after 3s\r\n * // 1 after 4s\r\n * // '...and it is done!' also after 4s\r\n * ```\r\n *\r\n * @see {@link concatAll}\r\n * @see {@link concatMap}\r\n * @see {@link concatMapTo}\r\n * @see {@link startWith}\r\n * @see {@link endWith}\r\n *\r\n * @param args Input Observables to concatenate.\r\n */\r\nexport function concat(...args: any[]): Observable<unknown> {\r\n  return concatAll()(from(args, popScheduler(args)));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}