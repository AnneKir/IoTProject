{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nvar Subscriber = function (_super) {\n  __extends(Subscriber, _super);\n  function Subscriber(destination) {\n    var _this = _super.call(this) || this;\n    _this.isStopped = false;\n    if (destination) {\n      _this.destination = destination;\n      if (isSubscription(destination)) {\n        destination.add(_this);\n      }\n    } else {\n      _this.destination = EMPTY_OBSERVER;\n    }\n    return _this;\n  }\n  Subscriber.create = function (next, error, complete) {\n    return new SafeSubscriber(next, error, complete);\n  };\n  Subscriber.prototype.next = function (value) {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value);\n    }\n  };\n  Subscriber.prototype.error = function (err) {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  };\n  Subscriber.prototype.complete = function () {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  };\n  Subscriber.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      this.isStopped = true;\n      _super.prototype.unsubscribe.call(this);\n      this.destination = null;\n    }\n  };\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n  Subscriber.prototype._error = function (err) {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  };\n  Subscriber.prototype._complete = function () {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  };\n  return Subscriber;\n}(Subscription);\nexport { Subscriber };\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n  return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = function () {\n  function ConsumerObserver(partialObserver) {\n    this.partialObserver = partialObserver;\n  }\n  ConsumerObserver.prototype.next = function (value) {\n    var partialObserver = this.partialObserver;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  };\n  ConsumerObserver.prototype.error = function (err) {\n    var partialObserver = this.partialObserver;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  };\n  ConsumerObserver.prototype.complete = function () {\n    var partialObserver = this.partialObserver;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  };\n  return ConsumerObserver;\n}();\nvar SafeSubscriber = function (_super) {\n  __extends(SafeSubscriber, _super);\n  function SafeSubscriber(observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n    var partialObserver;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      partialObserver = {\n        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,\n        error: error !== null && error !== void 0 ? error : undefined,\n        complete: complete !== null && complete !== void 0 ? complete : undefined\n      };\n    } else {\n      var context_1;\n      if (_this && config.useDeprecatedNextContext) {\n        context_1 = Object.create(observerOrNext);\n        context_1.unsubscribe = function () {\n          return _this.unsubscribe();\n        };\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context_1),\n          error: observerOrNext.error && bind(observerOrNext.error, context_1),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)\n        };\n      } else {\n        partialObserver = observerOrNext;\n      }\n    }\n    _this.destination = new ConsumerObserver(partialObserver);\n    return _this;\n  }\n  return SafeSubscriber;\n}(Subscriber);\nexport { SafeSubscriber };\nfunction handleUnhandledError(error) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    reportUnhandledError(error);\n  }\n}\nfunction defaultErrorHandler(err) {\n  throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n  var onStoppedNotification = config.onStoppedNotification;\n  onStoppedNotification && timeoutProvider.setTimeout(function () {\n    return onStoppedNotification(notification, subscriber);\n  });\n}\nexport var EMPTY_OBSERVER = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop\n};","map":{"version":3,"mappings":"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","names":["isFunction","isSubscription","Subscription","config","reportUnhandledError","noop","nextNotification","errorNotification","COMPLETE_NOTIFICATION","timeoutProvider","captureError","__extends","destination","_super","_this","add","EMPTY_OBSERVER","Subscriber","next","error","complete","SafeSubscriber","value","isStopped","handleStoppedNotification","_next","err","_error","_complete","closed","unsubscribe","_bind","Function","prototype","bind","fn","thisArg","call","partialObserver","ConsumerObserver","handleUnhandledError","observerOrNext","undefined","context_1","useDeprecatedNextContext","Object","create","useDeprecatedSynchronousErrorHandling","defaultErrorHandler","notification","subscriber","onStoppedNotification","setTimeout"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\Subscriber.ts"],"sourcesContent":["import { isFunction } from './util/isFunction';\r\nimport { Observer, ObservableNotification } from './types';\r\nimport { isSubscription, Subscription } from './Subscription';\r\nimport { config } from './config';\r\nimport { reportUnhandledError } from './util/reportUnhandledError';\r\nimport { noop } from './util/noop';\r\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\r\nimport { timeoutProvider } from './scheduler/timeoutProvider';\r\nimport { captureError } from './util/errorContext';\r\n\r\n/**\r\n * Implements the {@link Observer} interface and extends the\r\n * {@link Subscription} class. While the {@link Observer} is the public API for\r\n * consuming the values of an {@link Observable}, all Observers get converted to\r\n * a Subscriber, in order to provide Subscription-like capabilities such as\r\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\r\n * implementing operators, but it is rarely used as a public API.\r\n *\r\n * @class Subscriber<T>\r\n */\r\nexport class Subscriber<T> extends Subscription implements Observer<T> {\r\n  /**\r\n   * A static factory for a Subscriber, given a (potentially partial) definition\r\n   * of an Observer.\r\n   * @param next The `next` callback of an Observer.\r\n   * @param error The `error` callback of an\r\n   * Observer.\r\n   * @param complete The `complete` callback of an\r\n   * Observer.\r\n   * @return A Subscriber wrapping the (partially defined)\r\n   * Observer represented by the given arguments.\r\n   * @nocollapse\r\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\r\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\r\n   * If you have a specific use case, please file an issue.\r\n   */\r\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\r\n    return new SafeSubscriber(next, error, complete);\r\n  }\r\n\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  protected isStopped: boolean = false;\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\r\n\r\n  /**\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\r\n   */\r\n  constructor(destination?: Subscriber<any> | Observer<any>) {\r\n    super();\r\n    if (destination) {\r\n      this.destination = destination;\r\n      // Automatically chain subscriptions together here.\r\n      // if destination is a Subscription, then it is a Subscriber.\r\n      if (isSubscription(destination)) {\r\n        destination.add(this);\r\n      }\r\n    } else {\r\n      this.destination = EMPTY_OBSERVER;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The {@link Observer} callback to receive notifications of type `next` from\r\n   * the Observable, with a value. The Observable may call this method 0 or more\r\n   * times.\r\n   * @param {T} [value] The `next` value.\r\n   * @return {void}\r\n   */\r\n  next(value?: T): void {\r\n    if (this.isStopped) {\r\n      handleStoppedNotification(nextNotification(value), this);\r\n    } else {\r\n      this._next(value!);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The {@link Observer} callback to receive notifications of type `error` from\r\n   * the Observable, with an attached `Error`. Notifies the Observer that\r\n   * the Observable has experienced an error condition.\r\n   * @param {any} [err] The `error` exception.\r\n   * @return {void}\r\n   */\r\n  error(err?: any): void {\r\n    if (this.isStopped) {\r\n      handleStoppedNotification(errorNotification(err), this);\r\n    } else {\r\n      this.isStopped = true;\r\n      this._error(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The {@link Observer} callback to receive a valueless notification of type\r\n   * `complete` from the Observable. Notifies the Observer that the Observable\r\n   * has finished sending push-based notifications.\r\n   * @return {void}\r\n   */\r\n  complete(): void {\r\n    if (this.isStopped) {\r\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\r\n    } else {\r\n      this.isStopped = true;\r\n      this._complete();\r\n    }\r\n  }\r\n\r\n  unsubscribe(): void {\r\n    if (!this.closed) {\r\n      this.isStopped = true;\r\n      super.unsubscribe();\r\n      this.destination = null!;\r\n    }\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    this.destination.next(value);\r\n  }\r\n\r\n  protected _error(err: any): void {\r\n    try {\r\n      this.destination.error(err);\r\n    } finally {\r\n      this.unsubscribe();\r\n    }\r\n  }\r\n\r\n  protected _complete(): void {\r\n    try {\r\n      this.destination.complete();\r\n    } finally {\r\n      this.unsubscribe();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This bind is captured here because we want to be able to have\r\n * compatibility with monoid libraries that tend to use a method named\r\n * `bind`. In particular, a library called Monio requires this.\r\n */\r\nconst _bind = Function.prototype.bind;\r\n\r\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\r\n  return _bind.call(fn, thisArg);\r\n}\r\n\r\n/**\r\n * Internal optimization only, DO NOT EXPOSE.\r\n * @internal\r\n */\r\nclass ConsumerObserver<T> implements Observer<T> {\r\n  constructor(private partialObserver: Partial<Observer<T>>) {}\r\n\r\n  next(value: T): void {\r\n    const { partialObserver } = this;\r\n    if (partialObserver.next) {\r\n      try {\r\n        partialObserver.next(value);\r\n      } catch (error) {\r\n        handleUnhandledError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  error(err: any): void {\r\n    const { partialObserver } = this;\r\n    if (partialObserver.error) {\r\n      try {\r\n        partialObserver.error(err);\r\n      } catch (error) {\r\n        handleUnhandledError(error);\r\n      }\r\n    } else {\r\n      handleUnhandledError(err);\r\n    }\r\n  }\r\n\r\n  complete(): void {\r\n    const { partialObserver } = this;\r\n    if (partialObserver.complete) {\r\n      try {\r\n        partialObserver.complete();\r\n      } catch (error) {\r\n        handleUnhandledError(error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class SafeSubscriber<T> extends Subscriber<T> {\r\n  constructor(\r\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\r\n    error?: ((e?: any) => void) | null,\r\n    complete?: (() => void) | null\r\n  ) {\r\n    super();\r\n\r\n    let partialObserver: Partial<Observer<T>>;\r\n    if (isFunction(observerOrNext) || !observerOrNext) {\r\n      // The first argument is a function, not an observer. The next\r\n      // two arguments *could* be observers, or they could be empty.\r\n      partialObserver = {\r\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\r\n        error: error ?? undefined,\r\n        complete: complete ?? undefined,\r\n      };\r\n    } else {\r\n      // The first argument is a partial observer.\r\n      let context: any;\r\n      if (this && config.useDeprecatedNextContext) {\r\n        // This is a deprecated path that made `this.unsubscribe()` available in\r\n        // next handler functions passed to subscribe. This only exists behind a flag\r\n        // now, as it is *very* slow.\r\n        context = Object.create(observerOrNext);\r\n        context.unsubscribe = () => this.unsubscribe();\r\n        partialObserver = {\r\n          next: observerOrNext.next && bind(observerOrNext.next, context),\r\n          error: observerOrNext.error && bind(observerOrNext.error, context),\r\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\r\n        };\r\n      } else {\r\n        // The \"normal\" path. Just use the partial observer directly.\r\n        partialObserver = observerOrNext;\r\n      }\r\n    }\r\n\r\n    // Wrap the partial observer to ensure it's a full observer, and\r\n    // make sure proper error handling is accounted for.\r\n    this.destination = new ConsumerObserver(partialObserver);\r\n  }\r\n}\r\n\r\nfunction handleUnhandledError(error: any) {\r\n  if (config.useDeprecatedSynchronousErrorHandling) {\r\n    captureError(error);\r\n  } else {\r\n    // Ideal path, we report this as an unhandled error,\r\n    // which is thrown on a new call stack.\r\n    reportUnhandledError(error);\r\n  }\r\n}\r\n\r\n/**\r\n * An error handler used when no error handler was supplied\r\n * to the SafeSubscriber -- meaning no error handler was supplied\r\n * do the `subscribe` call on our observable.\r\n * @param err The error to handle\r\n */\r\nfunction defaultErrorHandler(err: any) {\r\n  throw err;\r\n}\r\n\r\n/**\r\n * A handler for notifications that cannot be sent to a stopped subscriber.\r\n * @param notification The notification being sent\r\n * @param subscriber The stopped subscriber\r\n */\r\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\r\n  const { onStoppedNotification } = config;\r\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\r\n}\r\n\r\n/**\r\n * The observer used as a stub for subscriptions where the user did not\r\n * pass any arguments to `subscribe`. Comes with the default error handling\r\n * behavior.\r\n */\r\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\r\n  closed: true,\r\n  next: noop,\r\n  error: defaultErrorHandler,\r\n  complete: noop,\r\n};\r\n"]},"metadata":{},"sourceType":"module"}