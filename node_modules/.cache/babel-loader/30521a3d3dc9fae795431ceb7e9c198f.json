{"ast":null,"code":"import { Observable } from '../Observable';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\nexport function timer(dueTime, intervalOrScheduler, scheduler) {\n  if (dueTime === void 0) {\n    dueTime = 0;\n  }\n  if (scheduler === void 0) {\n    scheduler = asyncScheduler;\n  }\n  var intervalDuration = -1;\n  if (intervalOrScheduler != null) {\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n  return new Observable(function (subscriber) {\n    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;\n    if (due < 0) {\n      due = 0;\n    }\n    var n = 0;\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        subscriber.next(n++);\n        if (0 <= intervalDuration) {\n          this.schedule(undefined, intervalDuration);\n        } else {\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAE1C,SAASC,KAAK,IAAIC,cAAc,QAAQ,oBAAoB;AAC5D,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASC,WAAW,QAAQ,gBAAgB;AAgI5C,OAAM,SAAUC,KAAK,CACnBC,OAA0B,EAC1BC,mBAA4C,EAC5CC,SAAyC;EAFzC;IAAAF,WAA0B;EAAA;EAE1B;IAAAE,0BAAyC;EAAA;EAIzC,IAAIC,gBAAgB,GAAG,CAAC,CAAC;EAEzB,IAAIF,mBAAmB,IAAI,IAAI,EAAE;IAI/B,IAAIJ,WAAW,CAACI,mBAAmB,CAAC,EAAE;MACpCC,SAAS,GAAGD,mBAAmB;KAChC,MAAM;MAGLE,gBAAgB,GAAGF,mBAAmB;;;EAI1C,OAAO,IAAIP,UAAU,CAAC,UAACU,UAAU;IAI/B,IAAIC,GAAG,GAAGP,WAAW,CAACE,OAAO,CAAC,GAAG,CAACA,OAAO,GAAGE,SAAU,CAACI,GAAG,EAAE,GAAGN,OAAO;IAEtE,IAAIK,GAAG,GAAG,CAAC,EAAE;MAEXA,GAAG,GAAG,CAAC;;IAIT,IAAIE,CAAC,GAAG,CAAC;IAGT,OAAOL,SAAS,CAACM,QAAQ,CAAC;MACxB,IAAI,CAACJ,UAAU,CAACK,MAAM,EAAE;QAEtBL,UAAU,CAACM,IAAI,CAACH,CAAC,EAAE,CAAC;QAEpB,IAAI,CAAC,IAAIJ,gBAAgB,EAAE;UAGzB,IAAI,CAACK,QAAQ,CAACG,SAAS,EAAER,gBAAgB,CAAC;SAC3C,MAAM;UAELC,UAAU,CAACQ,QAAQ,EAAE;;;IAG3B,CAAC,EAAEP,GAAG,CAAC;EACT,CAAC,CAAC;AACJ","names":["Observable","async","asyncScheduler","isScheduler","isValidDate","timer","dueTime","intervalOrScheduler","scheduler","intervalDuration","subscriber","due","now","n","schedule","closed","next","undefined","complete"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\timer.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { async as asyncScheduler } from '../scheduler/async';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { isValidDate } from '../util/isDate';\r\n\r\n/**\r\n * Creates an observable that will wait for a specified time period, or exact date, before\r\n * emitting the number 0.\r\n *\r\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\r\n *\r\n * This observable is useful for creating delays in code, or racing against other values\r\n * for ad-hoc timeouts.\r\n *\r\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\r\n * create a different behavior.\r\n *\r\n * ## Examples\r\n *\r\n * Wait 3 seconds and start another observable\r\n *\r\n * You might want to use `timer` to delay subscription to an\r\n * observable by a set amount of time. Here we use a timer with\r\n * {@link concatMapTo} or {@link concatMap} in order to wait\r\n * a few seconds and start a subscription to a source.\r\n *\r\n * ```ts\r\n * import { of, timer, concatMap } from 'rxjs';\r\n *\r\n * // This could be any observable\r\n * const source = of(1, 2, 3);\r\n *\r\n * timer(3000)\r\n *   .pipe(concatMap(() => source))\r\n *   .subscribe(console.log);\r\n * ```\r\n *\r\n * Take all values until the start of the next minute\r\n *\r\n * Using a `Date` as the trigger for the first emission, you can\r\n * do things like wait until midnight to fire an event, or in this case,\r\n * wait until a new minute starts (chosen so the example wouldn't take\r\n * too long to run) in order to stop watching a stream. Leveraging\r\n * {@link takeUntil}.\r\n *\r\n * ```ts\r\n * import { interval, takeUntil, timer } from 'rxjs';\r\n *\r\n * // Build a Date object that marks the\r\n * // next minute.\r\n * const currentDate = new Date();\r\n * const startOfNextMinute = new Date(\r\n *   currentDate.getFullYear(),\r\n *   currentDate.getMonth(),\r\n *   currentDate.getDate(),\r\n *   currentDate.getHours(),\r\n *   currentDate.getMinutes() + 1\r\n * );\r\n *\r\n * // This could be any observable stream\r\n * const source = interval(1000);\r\n *\r\n * const result = source.pipe(\r\n *   takeUntil(timer(startOfNextMinute))\r\n * );\r\n *\r\n * result.subscribe(console.log);\r\n * ```\r\n *\r\n * ### Known Limitations\r\n *\r\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\r\n *\r\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\r\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\r\n * should occur will be incorrect. In this case, it would be best to do your own calculations\r\n * ahead of time, and pass a `number` in as the `dueTime`.\r\n *\r\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\r\n * If a `Date`, the exact time at which to emit.\r\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\r\n\r\n/**\r\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\r\n * on each interval after words.\r\n *\r\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\r\n * create a different behavior.\r\n *\r\n * ## Example\r\n *\r\n * ### Start an interval that starts right away\r\n *\r\n * Since {@link interval} waits for the passed delay before starting,\r\n * sometimes that's not ideal. You may want to start an interval immediately.\r\n * `timer` works well for this. Here we have both side-by-side so you can\r\n * see them in comparison.\r\n *\r\n * Note that this observable will never complete.\r\n *\r\n * ```ts\r\n * import { timer, interval } from 'rxjs';\r\n *\r\n * timer(0, 1000).subscribe(n => console.log('timer', n));\r\n * interval(1000).subscribe(n => console.log('interval', n));\r\n * ```\r\n *\r\n * ### Known Limitations\r\n *\r\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\r\n *\r\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\r\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\r\n * should occur will be incorrect. In this case, it would be best to do your own calculations\r\n * ahead of time, and pass a `number` in as the `startDue`.\r\n * @param startDue If a `number`, is the time to wait before starting the interval.\r\n * If a `Date`, is the exact time at which to start the interval.\r\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\r\n * negative number here will result in immediate completion after the first value is emitted, as though\r\n * no `intervalDuration` was passed at all.\r\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\r\n\r\n/**\r\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\r\n */\r\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\r\n\r\nexport function timer(\r\n  dueTime: number | Date = 0,\r\n  intervalOrScheduler?: number | SchedulerLike,\r\n  scheduler: SchedulerLike = asyncScheduler\r\n): Observable<number> {\r\n  // Since negative intervalDuration is treated as though no\r\n  // interval was specified at all, we start with a negative number.\r\n  let intervalDuration = -1;\r\n\r\n  if (intervalOrScheduler != null) {\r\n    // If we have a second argument, and it's a scheduler,\r\n    // override the scheduler we had defaulted. Otherwise,\r\n    // it must be an interval.\r\n    if (isScheduler(intervalOrScheduler)) {\r\n      scheduler = intervalOrScheduler;\r\n    } else {\r\n      // Note that this *could* be negative, in which case\r\n      // it's like not passing an intervalDuration at all.\r\n      intervalDuration = intervalOrScheduler;\r\n    }\r\n  }\r\n\r\n  return new Observable((subscriber) => {\r\n    // If a valid date is passed, calculate how long to wait before\r\n    // executing the first value... otherwise, if it's a number just schedule\r\n    // that many milliseconds (or scheduler-specified unit size) in the future.\r\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\r\n\r\n    if (due < 0) {\r\n      // Ensure we don't schedule in the future.\r\n      due = 0;\r\n    }\r\n\r\n    // The incrementing value we emit.\r\n    let n = 0;\r\n\r\n    // Start the timer.\r\n    return scheduler.schedule(function () {\r\n      if (!subscriber.closed) {\r\n        // Emit the next value and increment.\r\n        subscriber.next(n++);\r\n\r\n        if (0 <= intervalDuration) {\r\n          // If we have a interval after the initial timer,\r\n          // reschedule with the period.\r\n          this.schedule(undefined, intervalDuration);\r\n        } else {\r\n          // We didn't have an interval. So just complete.\r\n          subscriber.complete();\r\n        }\r\n      }\r\n    }, due);\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}