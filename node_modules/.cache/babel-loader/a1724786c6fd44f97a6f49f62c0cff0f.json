{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nvar VirtualTimeScheduler = function (_super) {\n  __extends(VirtualTimeScheduler, _super);\n  function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {\n    if (schedulerActionCtor === void 0) {\n      schedulerActionCtor = VirtualAction;\n    }\n    if (maxFrames === void 0) {\n      maxFrames = Infinity;\n    }\n    var _this = _super.call(this, schedulerActionCtor, function () {\n      return _this.frame;\n    }) || this;\n    _this.maxFrames = maxFrames;\n    _this.frame = 0;\n    _this.index = -1;\n    return _this;\n  }\n  VirtualTimeScheduler.prototype.flush = function () {\n    var _a = this,\n      actions = _a.actions,\n      maxFrames = _a.maxFrames;\n    var error;\n    var action;\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  };\n  VirtualTimeScheduler.frameTimeFactor = 10;\n  return VirtualTimeScheduler;\n}(AsyncScheduler);\nexport { VirtualTimeScheduler };\nvar VirtualAction = function (_super) {\n  __extends(VirtualAction, _super);\n  function VirtualAction(scheduler, work, index) {\n    if (index === void 0) {\n      index = scheduler.index += 1;\n    }\n    var _this = _super.call(this, scheduler, work) || this;\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.index = index;\n    _this.active = true;\n    _this.index = scheduler.index = index;\n    return _this;\n  }\n  VirtualAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return _super.prototype.schedule.call(this, state, delay);\n      }\n      this.active = false;\n      var action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      return Subscription.EMPTY;\n    }\n  };\n  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    this.delay = scheduler.frame + delay;\n    var actions = scheduler.actions;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return 1;\n  };\n  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    return undefined;\n  };\n  VirtualAction.prototype._execute = function (state, delay) {\n    if (this.active === true) {\n      return _super.prototype._execute.call(this, state, delay);\n    }\n  };\n  VirtualAction.sortActions = function (a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n  return VirtualAction;\n}(AsyncAction);\nexport { VirtualAction };","map":{"version":3,"mappings":"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","names":["AsyncAction","Subscription","AsyncScheduler","__extends","schedulerActionCtor","maxFrames","VirtualAction","_super","frame","_this","VirtualTimeScheduler","actions","error","action","delay","shift","execute","state","unsubscribe","scheduler","work","index","Number","isFinite","id","schedule","active","add","EMPTY","push","sort","sortActions","undefined","_execute","a","b"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\scheduler\\VirtualTimeScheduler.ts"],"sourcesContent":["import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class VirtualTimeScheduler extends AsyncScheduler {\r\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\r\n  static frameTimeFactor = 10;\r\n\r\n  /**\r\n   * The current frame for the state of the virtual scheduler instance. The difference\r\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\r\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\r\n   * that means `10` virtual time units have passed.\r\n   */\r\n  public frame: number = 0;\r\n\r\n  /**\r\n   * Used internally to examine the current virtual action index being processed.\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   */\r\n  public index: number = -1;\r\n\r\n  /**\r\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\r\n   * this constructor is likely to change in the long run.\r\n   *\r\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\r\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\r\n   */\r\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\r\n    super(schedulerActionCtor, () => this.frame);\r\n  }\r\n\r\n  /**\r\n   * Prompt the Scheduler to execute all of its queued actions, therefore\r\n   * clearing its queue.\r\n   * @return {void}\r\n   */\r\n  public flush(): void {\r\n    const { actions, maxFrames } = this;\r\n    let error: any;\r\n    let action: AsyncAction<any> | undefined;\r\n\r\n    while ((action = actions[0]) && action.delay <= maxFrames) {\r\n      actions.shift();\r\n      this.frame = action.delay;\r\n\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      while ((action = actions.shift())) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport class VirtualAction<T> extends AsyncAction<T> {\r\n  protected active: boolean = true;\r\n\r\n  constructor(\r\n    protected scheduler: VirtualTimeScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\r\n    protected index: number = (scheduler.index += 1)\r\n  ) {\r\n    super(scheduler, work);\r\n    this.index = scheduler.index = index;\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (Number.isFinite(delay)) {\r\n      if (!this.id) {\r\n        return super.schedule(state, delay);\r\n      }\r\n      this.active = false;\r\n      // If an action is rescheduled, we save allocations by mutating its state,\r\n      // pushing it to the end of the scheduler queue, and recycling the action.\r\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\r\n      // must be immutable so they can be inspected later.\r\n      const action = new VirtualAction(this.scheduler, this.work);\r\n      this.add(action);\r\n      return action.schedule(state, delay);\r\n    } else {\r\n      // If someone schedules something with Infinity, it'll never happen. So we\r\n      // don't even schedule it.\r\n      return Subscription.EMPTY;\r\n    }\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\r\n    this.delay = scheduler.frame + delay;\r\n    const { actions } = scheduler;\r\n    actions.push(this);\r\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\r\n    return 1;\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\r\n    return undefined;\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    if (this.active === true) {\r\n      return super._execute(state, delay);\r\n    }\r\n  }\r\n\r\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\r\n    if (a.delay === b.delay) {\r\n      if (a.index === b.index) {\r\n        return 0;\r\n      } else if (a.index > b.index) {\r\n        return 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    } else if (a.delay > b.delay) {\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}