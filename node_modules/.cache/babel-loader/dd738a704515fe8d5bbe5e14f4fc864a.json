{"ast":null,"code":"import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n  var buffer = [];\n  var active = 0;\n  var index = 0;\n  var isComplete = false;\n  var checkComplete = function checkComplete() {\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n  var outerNext = function outerNext(value) {\n    return active < concurrent ? doInnerSub(value) : buffer.push(value);\n  };\n  var doInnerSub = function doInnerSub(value) {\n    expand && subscriber.next(value);\n    active++;\n    var innerComplete = false;\n    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {\n      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n      if (expand) {\n        outerNext(innerValue);\n      } else {\n        subscriber.next(innerValue);\n      }\n    }, function () {\n      innerComplete = true;\n    }, undefined, function () {\n      if (innerComplete) {\n        try {\n          active--;\n          var _loop_1 = function _loop_1() {\n            var bufferedValue = buffer.shift();\n            if (innerSubScheduler) {\n              executeSchedule(subscriber, innerSubScheduler, function () {\n                return doInnerSub(bufferedValue);\n              });\n            } else {\n              doInnerSub(bufferedValue);\n            }\n          };\n          while (buffer.length && active < concurrent) {\n            _loop_1();\n          }\n          checkComplete();\n        } catch (err) {\n          subscriber.error(err);\n        }\n      }\n    }));\n  };\n  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {\n    isComplete = true;\n    checkComplete();\n  }));\n  return function () {\n    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n  };\n}","map":{"version":3,"mappings":"AACA,SAASA,SAAS,QAAQ,yBAAyB;AAGnD,SAASC,eAAe,QAAQ,yBAAyB;AACzD,SAASC,wBAAwB,QAAQ,sBAAsB;AAe/D,OAAM,SAAUC,cAAc,CAC5BC,MAAqB,EACrBC,UAAyB,EACzBC,OAAwD,EACxDC,UAAkB,EAClBC,YAAsC,EACtCC,MAAgB,EAChBC,iBAAiC,EACjCC,mBAAgC;EAGhC,IAAMC,MAAM,GAAQ,EAAE;EAEtB,IAAIC,MAAM,GAAG,CAAC;EAEd,IAAIC,KAAK,GAAG,CAAC;EAEb,IAAIC,UAAU,GAAG,KAAK;EAKtB,IAAMC,aAAa,GAAG,SAAhBA,aAAa,GAAG;IAIpB,IAAID,UAAU,IAAI,CAACH,MAAM,CAACK,MAAM,IAAI,CAACJ,MAAM,EAAE;MAC3CR,UAAU,CAACa,QAAQ,EAAE;;EAEzB,CAAC;EAGD,IAAMC,SAAS,GAAG,SAAZA,SAAS,CAAIC,KAAQ;IAAK,OAACP,MAAM,GAAGN,UAAU,GAAGc,UAAU,CAACD,KAAK,CAAC,GAAGR,MAAM,CAACU,IAAI,CAACF,KAAK,CAAC;EAA7D,CAA8D;EAE9F,IAAMC,UAAU,GAAG,SAAbA,UAAU,CAAID,KAAQ;IAI1BX,MAAM,IAAIJ,UAAU,CAACkB,IAAI,CAACH,KAAY,CAAC;IAIvCP,MAAM,EAAE;IAKR,IAAIW,aAAa,GAAG,KAAK;IAGzBxB,SAAS,CAACM,OAAO,CAACc,KAAK,EAAEN,KAAK,EAAE,CAAC,CAAC,CAACW,SAAS,CAC1CvB,wBAAwB,CACtBG,UAAU,EACV,UAACqB,UAAU;MAGTlB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAGkB,UAAU,CAAC;MAE1B,IAAIjB,MAAM,EAAE;QAGVU,SAAS,CAACO,UAAiB,CAAC;OAC7B,MAAM;QAELrB,UAAU,CAACkB,IAAI,CAACG,UAAU,CAAC;;IAE/B,CAAC,EACD;MAGEF,aAAa,GAAG,IAAI;IACtB,CAAC,EAEDG,SAAS,EACT;MAIE,IAAIH,aAAa,EAAE;QAKjB,IAAI;UAIFX,MAAM,EAAE;;YAMN,IAAMe,aAAa,GAAGhB,MAAM,CAACiB,KAAK,EAAG;YAIrC,IAAInB,iBAAiB,EAAE;cACrBT,eAAe,CAACI,UAAU,EAAEK,iBAAiB,EAAE;gBAAM,iBAAU,CAACkB,aAAa,CAAC;cAAzB,CAAyB,CAAC;aAChF,MAAM;cACLP,UAAU,CAACO,aAAa,CAAC;;;UAR7B,OAAOhB,MAAM,CAACK,MAAM,IAAIJ,MAAM,GAAGN,UAAU;;;UAY3CS,aAAa,EAAE;SAChB,CAAC,OAAOc,GAAG,EAAE;UACZzB,UAAU,CAAC0B,KAAK,CAACD,GAAG,CAAC;;;IAG3B,CAAC,CACF,CACF;EACH,CAAC;EAGD1B,MAAM,CAACqB,SAAS,CACdvB,wBAAwB,CAACG,UAAU,EAAEc,SAAS,EAAE;IAE9CJ,UAAU,GAAG,IAAI;IACjBC,aAAa,EAAE;EACjB,CAAC,CAAC,CACH;EAID,OAAO;IACLL,mBAAmB,aAAnBA,mBAAmB,uBAAnBA,mBAAmB,EAAI;EACzB,CAAC;AACH","names":["innerFrom","executeSchedule","createOperatorSubscriber","mergeInternals","source","subscriber","project","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","active","index","isComplete","checkComplete","length","complete","outerNext","value","doInnerSub","push","next","innerComplete","subscribe","innerValue","undefined","bufferedValue","shift","err","error"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\mergeInternals.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * A process embodying the general \"merge\" strategy. This is used in\r\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\r\n * @param source The original source observable\r\n * @param subscriber The consumer subscriber\r\n * @param project The projection function to get our inner sources\r\n * @param concurrent The number of concurrent inner subscriptions\r\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\r\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\r\n * in that it recurses, and the inner subscription must be schedule-able.\r\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\r\n * this is to support the expand strategy, mostly, and should be deprecated\r\n */\r\nexport function mergeInternals<T, R>(\r\n  source: Observable<T>,\r\n  subscriber: Subscriber<R>,\r\n  project: (value: T, index: number) => ObservableInput<R>,\r\n  concurrent: number,\r\n  onBeforeNext?: (innerValue: R) => void,\r\n  expand?: boolean,\r\n  innerSubScheduler?: SchedulerLike,\r\n  additionalFinalizer?: () => void\r\n) {\r\n  // Buffered values, in the event of going over our concurrency limit\r\n  const buffer: T[] = [];\r\n  // The number of active inner subscriptions.\r\n  let active = 0;\r\n  // An index to pass to our accumulator function\r\n  let index = 0;\r\n  // Whether or not the outer source has completed.\r\n  let isComplete = false;\r\n\r\n  /**\r\n   * Checks to see if we can complete our result or not.\r\n   */\r\n  const checkComplete = () => {\r\n    // If the outer has completed, and nothing is left in the buffer,\r\n    // and we don't have any active inner subscriptions, then we can\r\n    // Emit the state and complete.\r\n    if (isComplete && !buffer.length && !active) {\r\n      subscriber.complete();\r\n    }\r\n  };\r\n\r\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\r\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\r\n\r\n  const doInnerSub = (value: T) => {\r\n    // If we're expanding, we need to emit the outer values and the inner values\r\n    // as the inners will \"become outers\" in a way as they are recursively fed\r\n    // back to the projection mechanism.\r\n    expand && subscriber.next(value as any);\r\n\r\n    // Increment the number of active subscriptions so we can track it\r\n    // against our concurrency limit later.\r\n    active++;\r\n\r\n    // A flag used to show that the inner observable completed.\r\n    // This is checked during finalization to see if we should\r\n    // move to the next item in the buffer, if there is on.\r\n    let innerComplete = false;\r\n\r\n    // Start our inner subscription.\r\n    innerFrom(project(value, index++)).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (innerValue) => {\r\n          // `mergeScan` has additional handling here. For example\r\n          // taking the inner value and updating state.\r\n          onBeforeNext?.(innerValue);\r\n\r\n          if (expand) {\r\n            // If we're expanding, then just recurse back to our outer\r\n            // handler. It will emit the value first thing.\r\n            outerNext(innerValue as any);\r\n          } else {\r\n            // Otherwise, emit the inner value.\r\n            subscriber.next(innerValue);\r\n          }\r\n        },\r\n        () => {\r\n          // Flag that we have completed, so we know to check the buffer\r\n          // during finalization.\r\n          innerComplete = true;\r\n        },\r\n        // Errors are passed to the destination.\r\n        undefined,\r\n        () => {\r\n          // During finalization, if the inner completed (it wasn't errored or\r\n          // cancelled), then we want to try the next item in the buffer if\r\n          // there is one.\r\n          if (innerComplete) {\r\n            // We have to wrap this in a try/catch because it happens during\r\n            // finalization, possibly asynchronously, and we want to pass\r\n            // any errors that happen (like in a projection function) to\r\n            // the outer Subscriber.\r\n            try {\r\n              // INNER SOURCE COMPLETE\r\n              // Decrement the active count to ensure that the next time\r\n              // we try to call `doInnerSub`, the number is accurate.\r\n              active--;\r\n              // If we have more values in the buffer, try to process those\r\n              // Note that this call will increment `active` ahead of the\r\n              // next conditional, if there were any more inner subscriptions\r\n              // to start.\r\n              while (buffer.length && active < concurrent) {\r\n                const bufferedValue = buffer.shift()!;\r\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\r\n                // for when we want to start our inner subscription. Otherwise, we just start\r\n                // are next inner subscription.\r\n                if (innerSubScheduler) {\r\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\r\n                } else {\r\n                  doInnerSub(bufferedValue);\r\n                }\r\n              }\r\n              // Check to see if we can complete, and complete if so.\r\n              checkComplete();\r\n            } catch (err) {\r\n              subscriber.error(err);\r\n            }\r\n          }\r\n        }\r\n      )\r\n    );\r\n  };\r\n\r\n  // Subscribe to our source observable.\r\n  source.subscribe(\r\n    createOperatorSubscriber(subscriber, outerNext, () => {\r\n      // Outer completed, make a note of it, and check to see if we can complete everything.\r\n      isComplete = true;\r\n      checkComplete();\r\n    })\r\n  );\r\n\r\n  // Additional finalization (for when the destination is torn down).\r\n  // Other finalization is added implicitly via subscription above.\r\n  return () => {\r\n    additionalFinalizer?.();\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}