{"ast":null,"code":"import { asyncScheduler } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport var TimeoutError = createErrorClass(function (_super) {\n  return function TimeoutErrorImpl(info) {\n    if (info === void 0) {\n      info = null;\n    }\n    _super(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    this.info = info;\n  };\n});\nexport function timeout(config, schedulerArg) {\n  var _a = isValidDate(config) ? {\n      first: config\n    } : typeof config === 'number' ? {\n      each: config\n    } : config,\n    first = _a.first,\n    each = _a.each,\n    _b = _a.with,\n    _with = _b === void 0 ? timeoutErrorFactory : _b,\n    _c = _a.scheduler,\n    scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c,\n    _d = _a.meta,\n    meta = _d === void 0 ? null : _d;\n  if (first == null && each == null) {\n    throw new TypeError('No timeout provided.');\n  }\n  return operate(function (source, subscriber) {\n    var originalSourceSubscription;\n    var timerSubscription;\n    var lastValue = null;\n    var seen = 0;\n    var startTimer = function (delay) {\n      timerSubscription = executeSchedule(subscriber, scheduler, function () {\n        try {\n          originalSourceSubscription.unsubscribe();\n          innerFrom(_with({\n            meta: meta,\n            lastValue: lastValue,\n            seen: seen\n          })).subscribe(subscriber);\n        } catch (err) {\n          subscriber.error(err);\n        }\n      }, delay);\n    };\n    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n      seen++;\n      subscriber.next(lastValue = value);\n      each > 0 && startTimer(each);\n    }, undefined, undefined, function () {\n      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {\n        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n      }\n      lastValue = null;\n    }));\n    !seen && startTimer(first != null ? typeof first === 'number' ? first : +first - scheduler.now() : each);\n  });\n}\nfunction timeoutErrorFactory(info) {\n  throw new TimeoutError(info);\n}","map":{"version":3,"mappings":"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","names":["asyncScheduler","isValidDate","operate","innerFrom","createErrorClass","createOperatorSubscriber","executeSchedule","TimeoutError","_super","TimeoutErrorImpl","info","message","name","timeout","config","schedulerArg","first","each","_b","_with","timeoutErrorFactory","_c","scheduler","_d","meta","TypeError","source","subscriber","originalSourceSubscription","timerSubscription","lastValue","seen","startTimer","delay","unsubscribe","subscribe","err","error","value","next","undefined","closed","now"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\timeout.ts"],"sourcesContent":["import { asyncScheduler } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\nimport { isValidDate } from '../util/isDate';\r\nimport { Subscription } from '../Subscription';\r\nimport { operate } from '../util/lift';\r\nimport { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createErrorClass } from '../util/createErrorClass';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\r\n  /**\r\n   * The time allowed between values from the source before timeout is triggered.\r\n   */\r\n  each?: number;\r\n\r\n  /**\r\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\r\n   * by which the first value must arrive from the source before timeout is triggered.\r\n   */\r\n  first?: number | Date;\r\n\r\n  /**\r\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\r\n   */\r\n  scheduler?: SchedulerLike;\r\n\r\n  /**\r\n   * A factory used to create observable to switch to when timeout occurs. Provides\r\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\r\n   * exact time triggered the timeout.\r\n   */\r\n  with?: (info: TimeoutInfo<T, M>) => O;\r\n\r\n  /**\r\n   * Optional additional metadata you can provide to code that handles\r\n   * the timeout, will be provided through the {@link TimeoutError}.\r\n   * This can be used to help identify the source of a timeout or pass along\r\n   * other information related to the timeout.\r\n   */\r\n  meta?: M;\r\n}\r\n\r\nexport interface TimeoutInfo<T, M = unknown> {\r\n  /** Optional metadata that was provided to the timeout configuration. */\r\n  readonly meta: M;\r\n  /** The number of messages seen before the timeout */\r\n  readonly seen: number;\r\n  /** The last message seen */\r\n  readonly lastValue: T | null;\r\n}\r\n\r\n/**\r\n * An error emitted when a timeout occurs.\r\n */\r\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\r\n  /**\r\n   * The information provided to the error by the timeout\r\n   * operation that created the error. Will be `null` if\r\n   * used directly in non-RxJS code with an empty constructor.\r\n   * (Note that using this constructor directly is not recommended,\r\n   * you should create your own errors)\r\n   */\r\n  info: TimeoutInfo<T, M> | null;\r\n}\r\n\r\nexport interface TimeoutErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\r\n}\r\n\r\n/**\r\n * An error thrown by the {@link timeout} operator.\r\n *\r\n * Provided so users can use as a type and do quality comparisons.\r\n * We recommend you do not subclass this or create instances of this class directly.\r\n * If you have need of a error representing a timeout, you should\r\n * create your own error class and use that.\r\n *\r\n * @see {@link timeout}\r\n *\r\n * @class TimeoutError\r\n */\r\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\r\n      _super(this);\r\n      this.message = 'Timeout has occurred';\r\n      this.name = 'TimeoutError';\r\n      this.info = info;\r\n    }\r\n);\r\n\r\n/**\r\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\r\n * does not push values within the specified time parameters.\r\n *\r\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\r\n *\r\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\r\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\r\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\r\n * the settings in `first` and `each`.\r\n *\r\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\r\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\r\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\r\n * against the time period provided by `each`, if it was provided.\r\n *\r\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\r\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\r\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\r\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\r\n *\r\n * ## Examples\r\n *\r\n * Emit a custom error if there is too much time between values\r\n *\r\n * ```ts\r\n * import { interval, timeout, throwError } from 'rxjs';\r\n *\r\n * class CustomTimeoutError extends Error {\r\n *   constructor() {\r\n *     super('It was too slow');\r\n *     this.name = 'CustomTimeoutError';\r\n *   }\r\n * }\r\n *\r\n * const slow$ = interval(900);\r\n *\r\n * slow$.pipe(\r\n *   timeout({\r\n *     each: 1000,\r\n *     with: () => throwError(() => new CustomTimeoutError())\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * Switch to a faster observable if your source is slow.\r\n *\r\n * ```ts\r\n * import { interval, timeout } from 'rxjs';\r\n *\r\n * const slow$ = interval(900);\r\n * const fast$ = interval(500);\r\n *\r\n * slow$.pipe(\r\n *   timeout({\r\n *     each: 1000,\r\n *     with: () => fast$,\r\n *   })\r\n * )\r\n * .subscribe(console.log);\r\n * ```\r\n * @param config The configuration for the timeout.\r\n */\r\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\r\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\r\n): OperatorFunction<T, T | ObservedValueOf<O>>;\r\n\r\n/**\r\n * Returns an observable that will error or switch to a different observable if the source does not push values\r\n * within the specified time parameters.\r\n *\r\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\r\n *\r\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\r\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\r\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\r\n * the settings in `first` and `each`.\r\n *\r\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\r\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\r\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\r\n * against the time period provided by `each`, if it was provided.\r\n *\r\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\r\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\r\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\r\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\r\n *\r\n * ### Handling TimeoutErrors\r\n *\r\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\r\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\r\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\r\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\r\n *\r\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\r\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\r\n *\r\n * ## Examples\r\n *\r\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\r\n *\r\n * ```ts\r\n * import { interval, timeout } from 'rxjs';\r\n *\r\n * // A random interval that lasts between 0 and 10 seconds per tick\r\n * const source$ = interval(Math.round(Math.random() * 10_000));\r\n *\r\n * source$.pipe(\r\n *   timeout({ first: 5_000 })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\r\n * and subscription.\r\n *\r\n * ```ts\r\n * import { timer, timeout, expand } from 'rxjs';\r\n *\r\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\r\n *\r\n * // An observable that waits a random amount of time between each delivered value\r\n * const source$ = timer(getRandomTime())\r\n *   .pipe(expand(() => timer(getRandomTime())));\r\n *\r\n * source$\r\n *   .pipe(timeout({ each: 5_000 }))\r\n *   .subscribe({\r\n *     next: console.log,\r\n *     error: console.error\r\n *   });\r\n * ```\r\n *\r\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\r\n * 5 seconds between any two values after the first.\r\n *\r\n * ```ts\r\n * import { timer, timeout, expand } from 'rxjs';\r\n *\r\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\r\n *\r\n * // An observable that waits a random amount of time between each delivered value\r\n * const source$ = timer(getRandomTime())\r\n *   .pipe(expand(() => timer(getRandomTime())));\r\n *\r\n * source$\r\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\r\n *   .subscribe({\r\n *     next: console.log,\r\n *     error: console.error\r\n *   });\r\n * ```\r\n */\r\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\r\n\r\n/**\r\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\r\n * This is functionally the same as `timeout({ first: someDate })`.\r\n *\r\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @param first The date to at which the resulting observable will timeout if the source observable\r\n * does not emit at least one value.\r\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\r\n * This is functionally the same as `timeout({ each: milliseconds })`.\r\n *\r\n * <span class=\"informal\">Errors if it waits too long between any value</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @param each The time allowed between each pushed value from the source before the resulting observable\r\n * will timeout.\r\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n *\r\n * Errors if Observable does not emit a value in given time span.\r\n *\r\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @see {@link timeoutWith}\r\n *\r\n * @return A function that returns an Observable that mirrors behaviour of the\r\n * source Observable, unless timeout happens when it throws an error.\r\n */\r\nexport function timeout<T, O extends ObservableInput<any>, M>(\r\n  config: number | Date | TimeoutConfig<T, O, M>,\r\n  schedulerArg?: SchedulerLike\r\n): OperatorFunction<T, T | ObservedValueOf<O>> {\r\n  // Intentionally terse code.\r\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\r\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\r\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\r\n  // we destructure that into what we're going to use, setting important defaults as we do.\r\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\r\n  // it will default to the `asyncScheduler`.\r\n  const {\r\n    first,\r\n    each,\r\n    with: _with = timeoutErrorFactory,\r\n    scheduler = schedulerArg ?? asyncScheduler,\r\n    meta = null!,\r\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\r\n\r\n  if (first == null && each == null) {\r\n    // Ensure timeout was provided at runtime.\r\n    throw new TypeError('No timeout provided.');\r\n  }\r\n\r\n  return operate((source, subscriber) => {\r\n    // This subscription encapsulates our subscription to the\r\n    // source for this operator. We're capturing it separately,\r\n    // because if there is a `with` observable to fail over to,\r\n    // we want to unsubscribe from our original subscription, and\r\n    // hand of the subscription to that one.\r\n    let originalSourceSubscription: Subscription;\r\n    // The subscription for our timeout timer. This changes\r\n    // every time we get a new value.\r\n    let timerSubscription: Subscription;\r\n    // A bit of state we pass to our with and error factories to\r\n    // tell what the last value we saw was.\r\n    let lastValue: T | null = null;\r\n    // A bit of state we pass to the with and error factories to\r\n    // tell how many values we have seen so far.\r\n    let seen = 0;\r\n    const startTimer = (delay: number) => {\r\n      timerSubscription = executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          try {\r\n            originalSourceSubscription.unsubscribe();\r\n            innerFrom(\r\n              _with!({\r\n                meta,\r\n                lastValue,\r\n                seen,\r\n              })\r\n            ).subscribe(subscriber);\r\n          } catch (err) {\r\n            subscriber.error(err);\r\n          }\r\n        },\r\n        delay\r\n      );\r\n    };\r\n\r\n    originalSourceSubscription = source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // clear the timer so we can emit and start another one.\r\n          timerSubscription?.unsubscribe();\r\n          seen++;\r\n          // Emit\r\n          subscriber.next((lastValue = value));\r\n          // null | undefined are both < 0. Thanks, JavaScript.\r\n          each! > 0 && startTimer(each!);\r\n        },\r\n        undefined,\r\n        undefined,\r\n        () => {\r\n          if (!timerSubscription?.closed) {\r\n            timerSubscription?.unsubscribe();\r\n          }\r\n          // Be sure not to hold the last value in memory after unsubscription\r\n          // it could be quite large.\r\n          lastValue = null;\r\n        }\r\n      )\r\n    );\r\n\r\n    // Intentionally terse code.\r\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\r\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\r\n    // If `first` was provided, and it's a number, then use it.\r\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\r\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\r\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\r\n  });\r\n}\r\n\r\n/**\r\n * The default function to use to emit an error when timeout occurs and a `with` function\r\n * is not specified.\r\n * @param info The information about the timeout to pass along to the error\r\n */\r\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\r\n  throw new TimeoutError(info);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}