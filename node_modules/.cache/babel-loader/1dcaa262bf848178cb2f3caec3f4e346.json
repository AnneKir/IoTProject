{"ast":null,"code":"import { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\nexport function firstValueFrom(source, config) {\n  var hasConfig = typeof config === 'object';\n  return new Promise(function (resolve, reject) {\n    var subscriber = new SafeSubscriber({\n      next: function (value) {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: function () {\n        if (hasConfig) {\n          resolve(config.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      }\n    });\n    source.subscribe(subscriber);\n  });\n}","map":{"version":3,"mappings":"AACA,SAASA,UAAU,QAAQ,mBAAmB;AAC9C,SAASC,cAAc,QAAQ,cAAc;AAqD7C,OAAM,SAAUC,cAAc,CAAOC,MAAqB,EAAEC,MAAgC;EAC1F,IAAMC,SAAS,GAAG,OAAOD,MAAM,KAAK,QAAQ;EAC5C,OAAO,IAAIE,OAAO,CAAQ,UAACC,OAAO,EAAEC,MAAM;IACxC,IAAMC,UAAU,GAAG,IAAIR,cAAc,CAAI;MACvCS,IAAI,EAAE,UAACC,KAAK;QACVJ,OAAO,CAACI,KAAK,CAAC;QACdF,UAAU,CAACG,WAAW,EAAE;MAC1B,CAAC;MACDC,KAAK,EAAEL,MAAM;MACbM,QAAQ,EAAE;QACR,IAAIT,SAAS,EAAE;UACbE,OAAO,CAACH,MAAO,CAACW,YAAY,CAAC;SAC9B,MAAM;UACLP,MAAM,CAAC,IAAIR,UAAU,EAAE,CAAC;;MAE5B;KACD,CAAC;IACFG,MAAM,CAACa,SAAS,CAACP,UAAU,CAAC;EAC9B,CAAC,CAAC;AACJ","names":["EmptyError","SafeSubscriber","firstValueFrom","source","config","hasConfig","Promise","resolve","reject","subscriber","next","value","unsubscribe","error","complete","defaultValue","subscribe"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\firstValueFrom.ts"],"sourcesContent":["import { Observable } from './Observable';\r\nimport { EmptyError } from './util/EmptyError';\r\nimport { SafeSubscriber } from './Subscriber';\r\n\r\nexport interface FirstValueFromConfig<T> {\r\n  defaultValue: T;\r\n}\r\n\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\r\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\r\n\r\n/**\r\n * Converts an observable to a promise by subscribing to the observable,\r\n * and returning a promise that will resolve as soon as the first value\r\n * arrives from the observable. The subscription will then be closed.\r\n *\r\n * If the observable stream completes before any values were emitted, the\r\n * returned promise will reject with {@link EmptyError} or will resolve\r\n * with the default value if a default was specified.\r\n *\r\n * If the observable stream emits an error, the returned promise will reject\r\n * with that error.\r\n *\r\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\r\n * *OR* complete. If the source observable does not emit one value or complete, you will\r\n * end up with a promise that is hung up, and potentially all of the state of an\r\n * async function hanging out in memory. To avoid this situation, look into adding\r\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\r\n * amongst others.\r\n *\r\n * ## Example\r\n *\r\n * Wait for the first value from a stream and emit it from a promise in\r\n * an async function\r\n *\r\n * ```ts\r\n * import { interval, firstValueFrom } from 'rxjs';\r\n *\r\n * async function execute() {\r\n *   const source$ = interval(2000);\r\n *   const firstNumber = await firstValueFrom(source$);\r\n *   console.log(`The first number is ${ firstNumber }`);\r\n * }\r\n *\r\n * execute();\r\n *\r\n * // Expected output:\r\n * // 'The first number is 0'\r\n * ```\r\n *\r\n * @see {@link lastValueFrom}\r\n *\r\n * @param source the observable to convert to a promise\r\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\r\n */\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\r\n  const hasConfig = typeof config === 'object';\r\n  return new Promise<T | D>((resolve, reject) => {\r\n    const subscriber = new SafeSubscriber<T>({\r\n      next: (value) => {\r\n        resolve(value);\r\n        subscriber.unsubscribe();\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        if (hasConfig) {\r\n          resolve(config!.defaultValue);\r\n        } else {\r\n          reject(new EmptyError());\r\n        }\r\n      },\r\n    });\r\n    source.subscribe(subscriber);\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}