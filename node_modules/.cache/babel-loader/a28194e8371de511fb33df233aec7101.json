{"ast":null,"code":"const protocol = require('./constants');\nconst empty = Buffer.allocUnsafe(0);\nconst zeroBuf = Buffer.from([0]);\nconst numbers = require('./numbers');\nconst nextTick = require('process-nextick-args').nextTick;\nconst debug = require('debug')('mqtt-packet:writeToStream');\nconst numCache = numbers.cache;\nconst generateNumber = numbers.generateNumber;\nconst generateCache = numbers.generateCache;\nconst genBufVariableByteInt = numbers.genBufVariableByteInt;\nconst generate4ByteBuffer = numbers.generate4ByteBuffer;\nlet writeNumber = writeNumberCached;\nlet toGenerate = true;\nfunction generate(packet, stream, opts) {\n  debug('generate called');\n  if (stream.cork) {\n    stream.cork();\n    nextTick(uncork, stream);\n  }\n  if (toGenerate) {\n    toGenerate = false;\n    generateCache();\n  }\n  debug('generate: packet.cmd: %s', packet.cmd);\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts);\n    case 'connack':\n      return connack(packet, stream, opts);\n    case 'publish':\n      return publish(packet, stream, opts);\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts);\n    case 'subscribe':\n      return subscribe(packet, stream, opts);\n    case 'suback':\n      return suback(packet, stream, opts);\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts);\n    case 'unsuback':\n      return unsuback(packet, stream, opts);\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts);\n    case 'disconnect':\n      return disconnect(packet, stream, opts);\n    case 'auth':\n      return auth(packet, stream, opts);\n    default:\n      stream.emit('error', new Error('Unknown command'));\n      return false;\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get() {\n    return writeNumber === writeNumberCached;\n  },\n  set(value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n      writeNumber = writeNumberCached;\n    } else {\n      toGenerate = false;\n      writeNumber = writeNumberGenerated;\n    }\n  }\n});\nfunction uncork(stream) {\n  stream.uncork();\n}\nfunction connect(packet, stream, opts) {\n  const settings = packet || {};\n  const protocolId = settings.protocolId || 'MQTT';\n  let protocolVersion = settings.protocolVersion || 4;\n  const will = settings.will;\n  let clean = settings.clean;\n  const keepalive = settings.keepalive || 0;\n  const clientId = settings.clientId || '';\n  const username = settings.username;\n  const password = settings.password;\n  /* mqtt5 new oprions */\n  const properties = settings.properties;\n  if (clean === undefined) clean = true;\n  let length = 0;\n\n  // Must be a string and non-falsy\n  if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n    stream.emit('error', new Error('Invalid protocolId'));\n    return false;\n  } else length += protocolId.length + 2;\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'));\n    return false;\n  } else length += 1;\n\n  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2;\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n      return false;\n    }\n    if (clean * 1 === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n      return false;\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'));\n    return false;\n  } else length += 2;\n\n  // Connect flags\n  length += 1;\n\n  // Properties\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'));\n      return false;\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'));\n      return false;\n    } else {\n      length += Buffer.byteLength(will.topic) + 2;\n    }\n\n    // Payload\n    length += 2; // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload);\n        } else {\n          length += will.payload.length;\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'));\n        return false;\n      }\n    }\n    // will properties\n    var willProperties = {};\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties);\n      if (!willProperties) {\n        return false;\n      }\n      length += willProperties.length;\n    }\n  }\n\n  // Username\n  let providedUsername = false;\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true;\n      length += Buffer.byteLength(username) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid username'));\n      return false;\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'));\n      return false;\n    }\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid password'));\n      return false;\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER);\n\n  // Generate length\n  writeVarByteInt(stream, length);\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId);\n  if (settings.bridgeMode) {\n    protocolVersion += 128;\n  }\n  stream.write(protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3);\n\n  // Connect flags\n  let flags = 0;\n  flags |= username != null ? protocol.USERNAME_MASK : 0;\n  flags |= password != null ? protocol.PASSWORD_MASK : 0;\n  flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n  flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n  flags |= will ? protocol.WILL_FLAG_MASK : 0;\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n  stream.write(Buffer.from([flags]));\n\n  // Keepalive\n  writeNumber(stream, keepalive);\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write();\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId);\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write();\n    }\n    writeString(stream, will.topic);\n    writeStringOrBuffer(stream, will.payload);\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username);\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password);\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true;\n}\nfunction connack(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode;\n  const properties = settings.properties;\n  let length = 2; // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'));\n    return false;\n  }\n  // mqtt5 properties\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n  stream.write(protocol.CONNACK_HEADER);\n  // length\n  writeVarByteInt(stream, length);\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n  stream.write(Buffer.from([rc]));\n  if (propertiesData != null) {\n    propertiesData.write();\n  }\n  return true;\n}\nfunction publish(packet, stream, opts) {\n  debug('publish: packet: %o', packet);\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const qos = settings.qos || 0;\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0;\n  const topic = settings.topic;\n  const payload = settings.payload || empty;\n  const id = settings.messageId;\n  const properties = settings.properties;\n  let length = 0;\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n    stream.emit('error', new Error('Invalid topic'));\n    return false;\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length;\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else if (qos) length += 2;\n\n  // mqtt5 properties\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);\n\n  // Remaining length\n  writeVarByteInt(stream, length);\n\n  // Topic\n  writeNumber(stream, byteLength(topic));\n  stream.write(topic);\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id);\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write();\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload);\n  return stream.write(payload);\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const type = settings.cmd || 'puback';\n  const id = settings.messageId;\n  const dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n  let qos = 0;\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 3 : 2;\n  if (type === 'pubrel') qos = 1;\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  }\n\n  // properies mqtt 5\n  let propertiesData = null;\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n      if (!propertiesData) {\n        return false;\n      }\n      length += propertiesData.length;\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0]);\n\n  // Length\n  writeVarByteInt(stream, length);\n\n  // Message ID\n  writeNumber(stream, id);\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n  return true;\n}\nfunction subscribe(packet, stream, opts) {\n  debug('subscribe: packet: ');\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const id = settings.messageId;\n  const subs = settings.subscriptions;\n  const properties = settings.properties;\n  let length = 0;\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2;\n\n  // properies mqtt 5\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic;\n      const iqos = subs[i].qos;\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n        return false;\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n        return false;\n      }\n      if (version === 5) {\n        const nl = subs[i].nl || false;\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n          return false;\n        }\n        const rap = subs[i].rap || false;\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n          return false;\n        }\n        const rh = subs[i].rh || 0;\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n          return false;\n        }\n      }\n      length += Buffer.byteLength(itopic) + 2 + 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'));\n    return false;\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER);\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n  // Generate length\n  writeVarByteInt(stream, length);\n\n  // Generate message ID\n  writeNumber(stream, id);\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n  let result = true;\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic;\n    const jqos = sub.qos;\n    const jnl = +sub.nl;\n    const jrap = +sub.rap;\n    const jrh = sub.rh;\n    let joptions;\n\n    // Write topic string\n    writeString(stream, jtopic);\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]));\n  }\n  return result;\n}\nfunction suback(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const granted = settings.granted;\n  const properties = settings.properties;\n  let length = 0;\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2;\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'));\n        return false;\n      }\n      length += 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'));\n    return false;\n  }\n\n  // properies mqtt 5\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER);\n\n  // Length\n  writeVarByteInt(stream, length);\n\n  // Message ID\n  writeNumber(stream, id);\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n  return stream.write(Buffer.from(granted));\n}\nfunction unsubscribe(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const unsubs = settings.unsubscriptions;\n  const properties = settings.properties;\n  let length = 0;\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else {\n    length += 2;\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'));\n        return false;\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'));\n    return false;\n  }\n  // properies mqtt 5\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n  // Length\n  writeVarByteInt(stream, length);\n\n  // Message ID\n  writeNumber(stream, id);\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  // Unsubs\n  let result = true;\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j]);\n  }\n  return result;\n}\nfunction unsuback(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const granted = settings.granted;\n  const properties = settings.properties;\n  const type = settings.cmd;\n  const qos = 0;\n  let length = 2;\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n        length += 1;\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'));\n      return false;\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0]);\n\n  // Length\n  writeVarByteInt(stream, length);\n\n  // Message ID\n  writeNumber(stream, id);\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted));\n  }\n  return true;\n}\nfunction emptyPacket(packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd]);\n}\nfunction disconnect(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 1 : 0;\n\n  // properies mqtt 5\n  let propertiesData = null;\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n    if (!propertiesData) {\n      return false;\n    }\n    length += propertiesData.length;\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]));\n\n  // Length\n  writeVarByteInt(stream, length);\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n  return true;\n}\nfunction auth(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 1 : 0;\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'));\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n  if (!propertiesData) {\n    return false;\n  }\n  length += propertiesData.length;\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]));\n\n  // Length\n  writeVarByteInt(stream, length);\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]));\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n  return true;\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {};\nfunction writeVarByteInt(stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`));\n    return false;\n  }\n  let buffer = varByteIntCache[num];\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num);\n    if (num < 16384) varByteIntCache[num] = buffer;\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer);\n  return stream.write(buffer);\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString(stream, string) {\n  const strlen = Buffer.byteLength(string);\n  writeNumber(stream, strlen);\n  debug('writeString: %s', string);\n  return stream.write(string, 'utf8');\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair(stream, name, value) {\n  writeString(stream, name);\n  writeString(stream, value);\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached(stream, number) {\n  debug('writeNumberCached: number: %d', number);\n  debug('writeNumberCached: %o', numCache[number]);\n  return stream.write(numCache[number]);\n}\nfunction writeNumberGenerated(stream, number) {\n  const generatedNumber = generateNumber(number);\n  debug('writeNumberGenerated: %o', generatedNumber);\n  return stream.write(generatedNumber);\n}\nfunction write4ByteNumber(stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number);\n  debug('write4ByteNumber: %o', generated4ByteBuffer);\n  return stream.write(generated4ByteBuffer);\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer(stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite);\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length);\n    stream.write(toWrite);\n  } else writeNumber(stream, 0);\n}\nfunction getProperties(stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write() {\n        writeProperties(stream, {}, 0);\n      }\n    };\n  }\n  let propertiesLength = 0;\n  function getLengthProperty(name, value) {\n    const type = protocol.propertiesTypes[name];\n    let length = 0;\n    switch (type) {\n      case 'byte':\n        {\n          if (typeof value !== 'boolean') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + 1;\n          break;\n        }\n      case 'int8':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + 1;\n          break;\n        }\n      case 'binary':\n        {\n          if (value && value === null) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + Buffer.byteLength(value) + 2;\n          break;\n        }\n      case 'int16':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + 2;\n          break;\n        }\n      case 'int32':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + 4;\n          break;\n        }\n      case 'var':\n        {\n          // var byte integer is max 24 bits packed in 32 bits\n          if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + Buffer.byteLength(genBufVariableByteInt(value));\n          break;\n        }\n      case 'string':\n        {\n          if (typeof value !== 'string') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += 1 + 2 + Buffer.byteLength(value.toString());\n          break;\n        }\n      case 'pair':\n        {\n          if (typeof value !== 'object') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n          length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n            const currentValue = value[name];\n            if (Array.isArray(currentValue)) {\n              result += currentValue.reduce((currentLength, value) => {\n                currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString());\n                return currentLength;\n              }, 0);\n            } else {\n              result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n            }\n            return result;\n          }, 0);\n          break;\n        }\n      default:\n        {\n          stream.emit('error', new Error(`Invalid property ${name}: ${value}`));\n          return false;\n        }\n    }\n    return length;\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0;\n      let propValueLength = 0;\n      const propValue = properties[propName];\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex]);\n          if (!propValueLength) {\n            return false;\n          }\n          propLength += propValueLength;\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue);\n        if (!propValueLength) {\n          return false;\n        }\n        propLength = propValueLength;\n      }\n      if (!propLength) return false;\n      propertiesLength += propLength;\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write() {\n      writeProperties(stream, properties, propertiesLength);\n    }\n  };\n}\nfunction getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties'];\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n  let propertiesData = getProperties(stream, properties);\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift();\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp];\n        propertiesData = getProperties(stream, properties);\n      } else {\n        return false;\n      }\n    }\n  }\n  return propertiesData;\n}\nfunction writeProperty(stream, propName, value) {\n  const type = protocol.propertiesTypes[propName];\n  switch (type) {\n    case 'byte':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([+value]));\n        break;\n      }\n    case 'int8':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([value]));\n        break;\n      }\n    case 'binary':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeStringOrBuffer(stream, value);\n        break;\n      }\n    case 'int16':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeNumber(stream, value);\n        break;\n      }\n    case 'int32':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        write4ByteNumber(stream, value);\n        break;\n      }\n    case 'var':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeVarByteInt(stream, value);\n        break;\n      }\n    case 'string':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeString(stream, value);\n        break;\n      }\n    case 'pair':\n      {\n        Object.getOwnPropertyNames(value).forEach(name => {\n          const currentValue = value[name];\n          if (Array.isArray(currentValue)) {\n            currentValue.forEach(value => {\n              stream.write(Buffer.from([protocol.properties[propName]]));\n              writeStringPair(stream, name.toString(), value.toString());\n            });\n          } else {\n            stream.write(Buffer.from([protocol.properties[propName]]));\n            writeStringPair(stream, name.toString(), currentValue.toString());\n          }\n        });\n        break;\n      }\n    default:\n      {\n        stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`));\n        return false;\n      }\n  }\n}\nfunction writeProperties(stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength);\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName];\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex]);\n        }\n      } else {\n        writeProperty(stream, propName, value);\n      }\n    }\n  }\n}\nfunction byteLength(bufOrString) {\n  if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n}\nfunction isStringOrBuffer(field) {\n  return typeof field === 'string' || field instanceof Buffer;\n}\nmodule.exports = generate;","map":{"version":3,"names":["protocol","require","empty","Buffer","allocUnsafe","zeroBuf","from","numbers","nextTick","debug","numCache","cache","generateNumber","generateCache","genBufVariableByteInt","generate4ByteBuffer","writeNumber","writeNumberCached","toGenerate","generate","packet","stream","opts","cork","uncork","cmd","connect","connack","publish","confirmation","subscribe","suback","unsubscribe","unsuback","emptyPacket","disconnect","auth","emit","Error","Object","defineProperty","get","set","value","keys","length","writeNumberGenerated","settings","protocolId","protocolVersion","will","clean","keepalive","clientId","username","password","properties","undefined","isBuffer","byteLength","propertiesData","getProperties","topic","payload","willProperties","providedUsername","isStringOrBuffer","write","CONNECT_HEADER","writeVarByteInt","writeStringOrBuffer","bridgeMode","VERSION131","VERSION132","VERSION4","VERSION5","VERSION3","flags","USERNAME_MASK","PASSWORD_MASK","retain","WILL_RETAIN_MASK","qos","WILL_QOS_SHIFT","WILL_FLAG_MASK","CLEAN_SESSION_MASK","writeString","version","rc","reasonCode","returnCode","CONNACK_HEADER","sessionPresent","SESSIONPRESENT_HEADER","RETAIN_MASK","id","messageId","PUBLISH_HEADER","dup","type","DUP_MASK","getPropertiesByMaximumPacketSize","ACKS","subs","subscriptions","i","itopic","iqos","nl","rap","rh","SUBSCRIBE_HEADER","result","sub","jtopic","jqos","jnl","jrap","jrh","joptions","SUBSCRIBE_OPTIONS_QOS","SUBSCRIBE_OPTIONS_NL","SUBSCRIBE_OPTIONS_RAP","SUBSCRIBE_OPTIONS_RH","granted","SUBACK_HEADER","unsubs","unsubscriptions","UNSUBSCRIBE_HEADER","j","EMPTY","codes","varByteIntCache","num","VARBYTEINT_MAX","buffer","string","strlen","writeStringPair","name","number","generatedNumber","write4ByteNumber","generated4ByteBuffer","toWrite","writeProperties","propertiesLength","getLengthProperty","propertiesTypes","toString","getOwnPropertyNames","reduce","currentValue","Array","isArray","currentLength","propName","propLength","propValueLength","propValue","valueIndex","propertiesLengthLength","mayEmptyProps","maximumPacketSize","currentMayEmptyProp","shift","writeProperty","forEach","prototype","hasOwnProperty","call","bufOrString","field","module","exports"],"sources":["C:/Users/Amali/Desktop/Building_the_IoT_w._P2P_and_Cloud_Computing/IoTProject/node_modules/mqtt-packet/writeToStream.js"],"sourcesContent":["const protocol = require('./constants')\nconst empty = Buffer.allocUnsafe(0)\nconst zeroBuf = Buffer.from([0])\nconst numbers = require('./numbers')\nconst nextTick = require('process-nextick-args').nextTick\nconst debug = require('debug')('mqtt-packet:writeToStream')\n\nconst numCache = numbers.cache\nconst generateNumber = numbers.generateNumber\nconst generateCache = numbers.generateCache\nconst genBufVariableByteInt = numbers.genBufVariableByteInt\nconst generate4ByteBuffer = numbers.generate4ByteBuffer\nlet writeNumber = writeNumberCached\nlet toGenerate = true\n\nfunction generate (packet, stream, opts) {\n  debug('generate called')\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n  debug('generate: packet.cmd: %s', packet.cmd)\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts)\n    case 'connack':\n      return connack(packet, stream, opts)\n    case 'publish':\n      return publish(packet, stream, opts)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts)\n    case 'subscribe':\n      return subscribe(packet, stream, opts)\n    case 'suback':\n      return suback(packet, stream, opts)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts)\n    case 'unsuback':\n      return unsuback(packet, stream, opts)\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts)\n    case 'disconnect':\n      return disconnect(packet, stream, opts)\n    case 'auth':\n      return auth(packet, stream, opts)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get () {\n    return writeNumber === writeNumberCached\n  },\n  set (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (packet, stream, opts) {\n  const settings = packet || {}\n  const protocolId = settings.protocolId || 'MQTT'\n  let protocolVersion = settings.protocolVersion || 4\n  const will = settings.will\n  let clean = settings.clean\n  const keepalive = settings.keepalive || 0\n  const clientId = settings.clientId || ''\n  const username = settings.username\n  const password = settings.password\n  /* mqtt5 new oprions */\n  const properties = settings.properties\n\n  if (clean === undefined) clean = true\n\n  let length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // Properties\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    length += 2 // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload)\n        } else {\n          length += will.payload.length\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    }\n    // will properties\n    var willProperties = {}\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties)\n      if (!willProperties) { return false }\n      length += willProperties.length\n    }\n  }\n\n  // Username\n  let providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128\n  }\n\n  stream.write(\n    protocolVersion === 131\n      ? protocol.VERSION131\n      : protocolVersion === 132\n        ? protocol.VERSION132\n        : protocolVersion === 4\n          ? protocol.VERSION4\n          : protocolVersion === 5\n            ? protocol.VERSION5\n            : protocol.VERSION3\n  )\n\n  // Connect flags\n  let flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write()\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write()\n    }\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode\n  const properties = settings.properties\n  let length = 2 // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  // length\n  writeVarByteInt(stream, length)\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  stream.write(Buffer.from([rc]))\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction publish (packet, stream, opts) {\n  debug('publish: packet: %o', packet)\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const qos = settings.qos || 0\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0\n  const topic = settings.topic\n  const payload = settings.payload || empty\n  const id = settings.messageId\n  const properties = settings.properties\n\n  let length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeVarByteInt(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload)\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const type = settings.cmd || 'puback'\n  const id = settings.messageId\n  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  let qos = 0\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 3 : 2\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n      if (!propertiesData) { return false }\n      length += propertiesData.length\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction subscribe (packet, stream, opts) {\n  debug('subscribe: packet: ')\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const id = settings.messageId\n  const subs = settings.subscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic\n      const iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))\n          return false\n        }\n        const rap = subs[i].rap || false\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))\n          return false\n        }\n        const rh = subs[i].rh || 0\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))\n          return false\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  let result = true\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic\n    const jqos = sub.qos\n    const jnl = +sub.nl\n    const jrap = +sub.rap\n    const jrh = sub.rh\n    let joptions\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]))\n  }\n\n  return result\n}\n\nfunction suback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const granted = settings.granted\n  const properties = settings.properties\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const unsubs = settings.unsubscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // Unsubs\n  let result = true\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction unsuback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const granted = settings.granted\n  const properties = settings.properties\n  const type = settings.cmd\n  const qos = 0\n\n  let length = 2\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'))\n          return false\n        }\n        length += 1\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'))\n      return false\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted))\n  }\n  return true\n}\n\nfunction emptyPacket (packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd])\n}\n\nfunction disconnect (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return true\n}\n\nfunction auth (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n  if (!propertiesData) { return false }\n  length += propertiesData.length\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]))\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {}\nfunction writeVarByteInt (stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`))\n    return false\n  }\n\n  let buffer = varByteIntCache[num]\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num)\n    if (num < 16384) varByteIntCache[num] = buffer\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer)\n  return stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  const strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  debug('writeString: %s', string)\n  return stream.write(string, 'utf8')\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair (stream, name, value) {\n  writeString(stream, name)\n  writeString(stream, value)\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  debug('writeNumberCached: number: %d', number)\n  debug('writeNumberCached: %o', numCache[number])\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  const generatedNumber = generateNumber(number)\n  debug('writeNumberGenerated: %o', generatedNumber)\n  return stream.write(generatedNumber)\n}\nfunction write4ByteNumber (stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number)\n  debug('write4ByteNumber: %o', generated4ByteBuffer)\n  return stream.write(generated4ByteBuffer)\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction getProperties (stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write () {\n        writeProperties(stream, {}, 0)\n      }\n    }\n  }\n  let propertiesLength = 0\n  function getLengthProperty (name, value) {\n    const type = protocol.propertiesTypes[name]\n    let length = 0\n    switch (type) {\n      case 'byte': {\n        if (typeof value !== 'boolean') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'int8': {\n        if (typeof value !== 'number' || value < 0 || value > 0xff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'binary': {\n        if (value && value === null) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(value) + 2\n        break\n      }\n      case 'int16': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2\n        break\n      }\n      case 'int32': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 4\n        break\n      }\n      case 'var': {\n        // var byte integer is max 24 bits packed in 32 bits\n        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))\n        break\n      }\n      case 'string': {\n        if (typeof value !== 'string') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2 + Buffer.byteLength(value.toString())\n        break\n      }\n      case 'pair': {\n        if (typeof value !== 'object') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n          const currentValue = value[name]\n          if (Array.isArray(currentValue)) {\n            result += currentValue.reduce((currentLength, value) => {\n              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())\n              return currentLength\n            }, 0)\n          } else {\n            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())\n          }\n          return result\n        }, 0)\n        break\n      }\n      default: {\n        stream.emit('error', new Error(`Invalid property ${name}: ${value}`))\n        return false\n      }\n    }\n    return length\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0\n      let propValueLength = 0\n      const propValue = properties[propName]\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex])\n          if (!propValueLength) { return false }\n          propLength += propValueLength\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue)\n        if (!propValueLength) { return false }\n        propLength = propValueLength\n      }\n      if (!propLength) return false\n      propertiesLength += propLength\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))\n\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write () {\n      writeProperties(stream, properties, propertiesLength)\n    }\n  }\n}\n\nfunction getPropertiesByMaximumPacketSize (stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties']\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0\n\n  let propertiesData = getProperties(stream, properties)\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift()\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp]\n        propertiesData = getProperties(stream, properties)\n      } else {\n        return false\n      }\n    }\n  }\n  return propertiesData\n}\n\nfunction writeProperty (stream, propName, value) {\n  const type = protocol.propertiesTypes[propName]\n  switch (type) {\n    case 'byte': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([+value]))\n      break\n    }\n    case 'int8': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([value]))\n      break\n    }\n    case 'binary': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeStringOrBuffer(stream, value)\n      break\n    }\n    case 'int16': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeNumber(stream, value)\n      break\n    }\n    case 'int32': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      write4ByteNumber(stream, value)\n      break\n    }\n    case 'var': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeVarByteInt(stream, value)\n      break\n    }\n    case 'string': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeString(stream, value)\n      break\n    }\n    case 'pair': {\n      Object.getOwnPropertyNames(value).forEach(name => {\n        const currentValue = value[name]\n        if (Array.isArray(currentValue)) {\n          currentValue.forEach(value => {\n            stream.write(Buffer.from([protocol.properties[propName]]))\n            writeStringPair(stream, name.toString(), value.toString())\n          })\n        } else {\n          stream.write(Buffer.from([protocol.properties[propName]]))\n          writeStringPair(stream, name.toString(), currentValue.toString())\n        }\n      })\n      break\n    }\n    default: {\n      stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`))\n      return false\n    }\n  }\n}\n\nfunction writeProperties (stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength)\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName]\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex])\n        }\n      } else {\n        writeProperty(stream, propName, value)\n      }\n    }\n  }\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;AACvC,MAAMC,KAAK,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;AACnC,MAAMC,OAAO,GAAGF,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAChC,MAAMC,OAAO,GAAGN,OAAO,CAAC,WAAW,CAAC;AACpC,MAAMO,QAAQ,GAAGP,OAAO,CAAC,sBAAsB,CAAC,CAACO,QAAQ;AACzD,MAAMC,KAAK,GAAGR,OAAO,CAAC,OAAO,CAAC,CAAC,2BAA2B,CAAC;AAE3D,MAAMS,QAAQ,GAAGH,OAAO,CAACI,KAAK;AAC9B,MAAMC,cAAc,GAAGL,OAAO,CAACK,cAAc;AAC7C,MAAMC,aAAa,GAAGN,OAAO,CAACM,aAAa;AAC3C,MAAMC,qBAAqB,GAAGP,OAAO,CAACO,qBAAqB;AAC3D,MAAMC,mBAAmB,GAAGR,OAAO,CAACQ,mBAAmB;AACvD,IAAIC,WAAW,GAAGC,iBAAiB;AACnC,IAAIC,UAAU,GAAG,IAAI;AAErB,SAASC,QAAQ,CAAEC,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACvCb,KAAK,CAAC,iBAAiB,CAAC;EACxB,IAAIY,MAAM,CAACE,IAAI,EAAE;IACfF,MAAM,CAACE,IAAI,EAAE;IACbf,QAAQ,CAACgB,MAAM,EAAEH,MAAM,CAAC;EAC1B;EAEA,IAAIH,UAAU,EAAE;IACdA,UAAU,GAAG,KAAK;IAClBL,aAAa,EAAE;EACjB;EACAJ,KAAK,CAAC,0BAA0B,EAAEW,MAAM,CAACK,GAAG,CAAC;EAC7C,QAAQL,MAAM,CAACK,GAAG;IAChB,KAAK,SAAS;MACZ,OAAOC,OAAO,CAACN,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACtC,KAAK,SAAS;MACZ,OAAOK,OAAO,CAACP,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACtC,KAAK,SAAS;MACZ,OAAOM,OAAO,CAACR,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACtC,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,SAAS;MACZ,OAAOO,YAAY,CAACT,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IAC3C,KAAK,WAAW;MACd,OAAOQ,SAAS,CAACV,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACxC,KAAK,QAAQ;MACX,OAAOS,MAAM,CAACX,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACrC,KAAK,aAAa;MAChB,OAAOU,WAAW,CAACZ,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IAC1C,KAAK,UAAU;MACb,OAAOW,QAAQ,CAACb,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACvC,KAAK,SAAS;IACd,KAAK,UAAU;MACb,OAAOY,WAAW,CAACd,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IAC1C,KAAK,YAAY;MACf,OAAOa,UAAU,CAACf,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACzC,KAAK,MAAM;MACT,OAAOc,IAAI,CAAChB,MAAM,EAAEC,MAAM,EAAEC,IAAI,CAAC;IACnC;MACED,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,iBAAiB,CAAC,CAAC;MAClD,OAAO,KAAK;EAAA;AAElB;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,cAAc,CAACrB,QAAQ,EAAE,cAAc,EAAE;EAC9CsB,GAAG,GAAI;IACL,OAAOzB,WAAW,KAAKC,iBAAiB;EAC1C,CAAC;EACDyB,GAAG,CAAEC,KAAK,EAAE;IACV,IAAIA,KAAK,EAAE;MACT,IAAI,CAACjC,QAAQ,IAAI6B,MAAM,CAACK,IAAI,CAAClC,QAAQ,CAAC,CAACmC,MAAM,KAAK,CAAC,EAAE3B,UAAU,GAAG,IAAI;MACtEF,WAAW,GAAGC,iBAAiB;IACjC,CAAC,MAAM;MACLC,UAAU,GAAG,KAAK;MAClBF,WAAW,GAAG8B,oBAAoB;IACpC;EACF;AACF,CAAC,CAAC;AAEF,SAAStB,MAAM,CAAEH,MAAM,EAAE;EACvBA,MAAM,CAACG,MAAM,EAAE;AACjB;AAEA,SAASE,OAAO,CAAEN,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACtC,MAAMyB,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM4B,UAAU,GAAGD,QAAQ,CAACC,UAAU,IAAI,MAAM;EAChD,IAAIC,eAAe,GAAGF,QAAQ,CAACE,eAAe,IAAI,CAAC;EACnD,MAAMC,IAAI,GAAGH,QAAQ,CAACG,IAAI;EAC1B,IAAIC,KAAK,GAAGJ,QAAQ,CAACI,KAAK;EAC1B,MAAMC,SAAS,GAAGL,QAAQ,CAACK,SAAS,IAAI,CAAC;EACzC,MAAMC,QAAQ,GAAGN,QAAQ,CAACM,QAAQ,IAAI,EAAE;EACxC,MAAMC,QAAQ,GAAGP,QAAQ,CAACO,QAAQ;EAClC,MAAMC,QAAQ,GAAGR,QAAQ,CAACQ,QAAQ;EAClC;EACA,MAAMC,UAAU,GAAGT,QAAQ,CAACS,UAAU;EAEtC,IAAIL,KAAK,KAAKM,SAAS,EAAEN,KAAK,GAAG,IAAI;EAErC,IAAIN,MAAM,GAAG,CAAC;;EAEd;EACA,IAAI,CAACG,UAAU,IACX,OAAOA,UAAU,KAAK,QAAQ,IAAI,CAAC7C,MAAM,CAACuD,QAAQ,CAACV,UAAU,CAAE,EAAE;IACnE3B,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;IACrD,OAAO,KAAK;EACd,CAAC,MAAMO,MAAM,IAAIG,UAAU,CAACH,MAAM,GAAG,CAAC;;EAEtC;EACA,IAAII,eAAe,KAAK,CAAC,IAAIA,eAAe,KAAK,CAAC,IAAIA,eAAe,KAAK,CAAC,EAAE;IAC3E5B,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC3D,OAAO,KAAK;EACd,CAAC,MAAMO,MAAM,IAAI,CAAC;;EAElB;EACA,IAAI,CAAC,OAAOQ,QAAQ,KAAK,QAAQ,IAAIlD,MAAM,CAACuD,QAAQ,CAACL,QAAQ,CAAC,MAC1DA,QAAQ,IAAIJ,eAAe,IAAI,CAAC,CAAC,KAAKI,QAAQ,IAAIF,KAAK,CAAC,EAAE;IAC5DN,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACN,QAAQ,CAAC,GAAG,CAAC;EAC3C,CAAC,MAAM;IACL,IAAIJ,eAAe,GAAG,CAAC,EAAE;MACvB5B,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,wCAAwC,CAAC,CAAC;MACzE,OAAO,KAAK;IACd;IACA,IAAKa,KAAK,GAAG,CAAC,KAAM,CAAC,EAAE;MACrB9B,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,iDAAiD,CAAC,CAAC;MAClF,OAAO,KAAK;IACd;EACF;;EAEA;EACA,IAAI,OAAOc,SAAS,KAAK,QAAQ,IAC7BA,SAAS,GAAG,CAAC,IACbA,SAAS,GAAG,KAAK,IACjBA,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;IACvB/B,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd,CAAC,MAAMO,MAAM,IAAI,CAAC;;EAElB;EACAA,MAAM,IAAI,CAAC;;EAEX;EACA,IAAII,eAAe,KAAK,CAAC,EAAE;IACzB,IAAIW,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;IACtD,IAAI,CAACI,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACA,IAAIK,IAAI,EAAE;IACR;IACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC5B7B,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,cAAc,CAAC,CAAC;MAC/C,OAAO,KAAK;IACd;IACA;IACA,IAAI,CAACY,IAAI,CAACY,KAAK,IAAI,OAAOZ,IAAI,CAACY,KAAK,KAAK,QAAQ,EAAE;MACjDzC,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;MACrD,OAAO,KAAK;IACd,CAAC,MAAM;MACLO,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACT,IAAI,CAACY,KAAK,CAAC,GAAG,CAAC;IAC7C;;IAEA;IACAjB,MAAM,IAAI,CAAC,EAAC;IACZ,IAAIK,IAAI,CAACa,OAAO,EAAE;MAChB,IAAIb,IAAI,CAACa,OAAO,CAAClB,MAAM,IAAI,CAAC,EAAE;QAC5B,IAAI,OAAOK,IAAI,CAACa,OAAO,KAAK,QAAQ,EAAE;UACpClB,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACT,IAAI,CAACa,OAAO,CAAC;QAC3C,CAAC,MAAM;UACLlB,MAAM,IAAIK,IAAI,CAACa,OAAO,CAAClB,MAAM;QAC/B;MACF,CAAC,MAAM;QACLxB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,sBAAsB,CAAC,CAAC;QACvD,OAAO,KAAK;MACd;IACF;IACA;IACA,IAAI0B,cAAc,GAAG,CAAC,CAAC;IACvB,IAAIf,eAAe,KAAK,CAAC,EAAE;MACzBe,cAAc,GAAGH,aAAa,CAACxC,MAAM,EAAE6B,IAAI,CAACM,UAAU,CAAC;MACvD,IAAI,CAACQ,cAAc,EAAE;QAAE,OAAO,KAAK;MAAC;MACpCnB,MAAM,IAAImB,cAAc,CAACnB,MAAM;IACjC;EACF;;EAEA;EACA,IAAIoB,gBAAgB,GAAG,KAAK;EAC5B,IAAIX,QAAQ,IAAI,IAAI,EAAE;IACpB,IAAIY,gBAAgB,CAACZ,QAAQ,CAAC,EAAE;MAC9BW,gBAAgB,GAAG,IAAI;MACvBpB,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACL,QAAQ,CAAC,GAAG,CAAC;IAC3C,CAAC,MAAM;MACLjC,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,kBAAkB,CAAC,CAAC;MACnD,OAAO,KAAK;IACd;EACF;;EAEA;EACA,IAAIiB,QAAQ,IAAI,IAAI,EAAE;IACpB,IAAI,CAACU,gBAAgB,EAAE;MACrB5C,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,sCAAsC,CAAC,CAAC;MACvE,OAAO,KAAK;IACd;IAEA,IAAI4B,gBAAgB,CAACX,QAAQ,CAAC,EAAE;MAC9BV,MAAM,IAAIc,UAAU,CAACJ,QAAQ,CAAC,GAAG,CAAC;IACpC,CAAC,MAAM;MACLlC,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,kBAAkB,CAAC,CAAC;MACnD,OAAO,KAAK;IACd;EACF;;EAEA;EACAjB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAACoE,cAAc,CAAC;;EAErC;EACAC,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACAyB,mBAAmB,CAACjD,MAAM,EAAE2B,UAAU,CAAC;EAEvC,IAAID,QAAQ,CAACwB,UAAU,EAAE;IACvBtB,eAAe,IAAI,GAAG;EACxB;EAEA5B,MAAM,CAAC8C,KAAK,CACVlB,eAAe,KAAK,GAAG,GACnBjD,QAAQ,CAACwE,UAAU,GACnBvB,eAAe,KAAK,GAAG,GACrBjD,QAAQ,CAACyE,UAAU,GACnBxB,eAAe,KAAK,CAAC,GACnBjD,QAAQ,CAAC0E,QAAQ,GACjBzB,eAAe,KAAK,CAAC,GACnBjD,QAAQ,CAAC2E,QAAQ,GACjB3E,QAAQ,CAAC4E,QAAQ,CAC5B;;EAED;EACA,IAAIC,KAAK,GAAG,CAAC;EACbA,KAAK,IAAKvB,QAAQ,IAAI,IAAI,GAAItD,QAAQ,CAAC8E,aAAa,GAAG,CAAC;EACxDD,KAAK,IAAKtB,QAAQ,IAAI,IAAI,GAAIvD,QAAQ,CAAC+E,aAAa,GAAG,CAAC;EACxDF,KAAK,IAAK3B,IAAI,IAAIA,IAAI,CAAC8B,MAAM,GAAIhF,QAAQ,CAACiF,gBAAgB,GAAG,CAAC;EAC9DJ,KAAK,IAAK3B,IAAI,IAAIA,IAAI,CAACgC,GAAG,GAAIhC,IAAI,CAACgC,GAAG,IAAIlF,QAAQ,CAACmF,cAAc,GAAG,CAAC;EACrEN,KAAK,IAAI3B,IAAI,GAAGlD,QAAQ,CAACoF,cAAc,GAAG,CAAC;EAC3CP,KAAK,IAAI1B,KAAK,GAAGnD,QAAQ,CAACqF,kBAAkB,GAAG,CAAC;EAEhDhE,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACuE,KAAK,CAAC,CAAC,CAAC;;EAElC;EACA7D,WAAW,CAACK,MAAM,EAAE+B,SAAS,CAAC;;EAE9B;EACA,IAAIH,eAAe,KAAK,CAAC,EAAE;IACzBW,cAAc,CAACO,KAAK,EAAE;EACxB;;EAEA;EACAG,mBAAmB,CAACjD,MAAM,EAAEgC,QAAQ,CAAC;;EAErC;EACA,IAAIH,IAAI,EAAE;IACR,IAAID,eAAe,KAAK,CAAC,EAAE;MACzBe,cAAc,CAACG,KAAK,EAAE;IACxB;IACAmB,WAAW,CAACjE,MAAM,EAAE6B,IAAI,CAACY,KAAK,CAAC;IAC/BQ,mBAAmB,CAACjD,MAAM,EAAE6B,IAAI,CAACa,OAAO,CAAC;EAC3C;;EAEA;EACA,IAAIT,QAAQ,IAAI,IAAI,EAAE;IACpBgB,mBAAmB,CAACjD,MAAM,EAAEiC,QAAQ,CAAC;EACvC;EACA,IAAIC,QAAQ,IAAI,IAAI,EAAE;IACpBe,mBAAmB,CAACjD,MAAM,EAAEkC,QAAQ,CAAC;EACvC;EACA;EACA;EACA,OAAO,IAAI;AACb;AAEA,SAAS5B,OAAO,CAAEP,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACtC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAMoE,EAAE,GAAGD,OAAO,KAAK,CAAC,GAAGxC,QAAQ,CAAC0C,UAAU,GAAG1C,QAAQ,CAAC2C,UAAU;EACpE,MAAMlC,UAAU,GAAGT,QAAQ,CAACS,UAAU;EACtC,IAAIX,MAAM,GAAG,CAAC,EAAC;;EAEf;EACA,IAAI,OAAO2C,EAAE,KAAK,QAAQ,EAAE;IAC1BnE,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACtD,OAAO,KAAK;EACd;EACA;EACA,IAAIsB,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;IAClD,IAAI,CAACI,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;EAEAxB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAAC2F,cAAc,CAAC;EACrC;EACAtB,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;EAC/BxB,MAAM,CAAC8C,KAAK,CAACpB,QAAQ,CAAC6C,cAAc,GAAG5F,QAAQ,CAAC6F,qBAAqB,GAAGxF,OAAO,CAAC;EAEhFgB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACkF,EAAE,CAAC,CAAC,CAAC;EAC/B,IAAI5B,cAAc,IAAI,IAAI,EAAE;IAC1BA,cAAc,CAACO,KAAK,EAAE;EACxB;EACA,OAAO,IAAI;AACb;AAEA,SAASvC,OAAO,CAAER,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACtCb,KAAK,CAAC,qBAAqB,EAAEW,MAAM,CAAC;EACpC,MAAMmE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM8D,GAAG,GAAGnC,QAAQ,CAACmC,GAAG,IAAI,CAAC;EAC7B,MAAMF,MAAM,GAAGjC,QAAQ,CAACiC,MAAM,GAAGhF,QAAQ,CAAC8F,WAAW,GAAG,CAAC;EACzD,MAAMhC,KAAK,GAAGf,QAAQ,CAACe,KAAK;EAC5B,MAAMC,OAAO,GAAGhB,QAAQ,CAACgB,OAAO,IAAI7D,KAAK;EACzC,MAAM6F,EAAE,GAAGhD,QAAQ,CAACiD,SAAS;EAC7B,MAAMxC,UAAU,GAAGT,QAAQ,CAACS,UAAU;EAEtC,IAAIX,MAAM,GAAG,CAAC;;EAEd;EACA,IAAI,OAAOiB,KAAK,KAAK,QAAQ,EAAEjB,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACG,KAAK,CAAC,GAAG,CAAC,MAChE,IAAI3D,MAAM,CAACuD,QAAQ,CAACI,KAAK,CAAC,EAAEjB,MAAM,IAAIiB,KAAK,CAACjB,MAAM,GAAG,CAAC,MACtD;IACHxB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,eAAe,CAAC,CAAC;IAChD,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAACnC,MAAM,CAACuD,QAAQ,CAACK,OAAO,CAAC,EAAElB,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACI,OAAO,CAAC,MAC9DlB,MAAM,IAAIkB,OAAO,CAAClB,MAAM;;EAE7B;EACA,IAAIqC,GAAG,IAAI,OAAOa,EAAE,KAAK,QAAQ,EAAE;IACjC1E,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd,CAAC,MAAM,IAAI4C,GAAG,EAAErC,MAAM,IAAI,CAAC;;EAE3B;EACA,IAAIe,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;IAClD,IAAI,CAACI,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACAxB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAACiG,cAAc,CAACf,GAAG,CAAC,CAACnC,QAAQ,CAACmD,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAClB,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;EAEhF;EACAX,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA7B,WAAW,CAACK,MAAM,EAAEsC,UAAU,CAACG,KAAK,CAAC,CAAC;EACtCzC,MAAM,CAAC8C,KAAK,CAACL,KAAK,CAAC;;EAEnB;EACA,IAAIoB,GAAG,GAAG,CAAC,EAAElE,WAAW,CAACK,MAAM,EAAE0E,EAAE,CAAC;;EAEpC;EACA,IAAInC,cAAc,IAAI,IAAI,EAAE;IAC1BA,cAAc,CAACO,KAAK,EAAE;EACxB;;EAEA;EACA1D,KAAK,CAAC,sBAAsB,EAAEsD,OAAO,CAAC;EACtC,OAAO1C,MAAM,CAAC8C,KAAK,CAACJ,OAAO,CAAC;AAC9B;;AAEA;AACA,SAASlC,YAAY,CAAET,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAC3C,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM+E,IAAI,GAAGpD,QAAQ,CAACtB,GAAG,IAAI,QAAQ;EACrC,MAAMsE,EAAE,GAAGhD,QAAQ,CAACiD,SAAS;EAC7B,MAAME,GAAG,GAAInD,QAAQ,CAACmD,GAAG,IAAIC,IAAI,KAAK,QAAQ,GAAInG,QAAQ,CAACoG,QAAQ,GAAG,CAAC;EACvE,IAAIlB,GAAG,GAAG,CAAC;EACX,MAAMO,UAAU,GAAG1C,QAAQ,CAAC0C,UAAU;EACtC,MAAMjC,UAAU,GAAGT,QAAQ,CAACS,UAAU;EACtC,IAAIX,MAAM,GAAG0C,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;EAElC,IAAIY,IAAI,KAAK,QAAQ,EAAEjB,GAAG,GAAG,CAAC;;EAE9B;EACA,IAAI,OAAOa,EAAE,KAAK,QAAQ,EAAE;IAC1B1E,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd;;EAEA;EACA,IAAIsB,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB;IACA,IAAI,OAAO/B,UAAU,KAAK,QAAQ,EAAE;MAClCI,cAAc,GAAGyC,gCAAgC,CAAChF,MAAM,EAAEmC,UAAU,EAAElC,IAAI,EAAEuB,MAAM,CAAC;MACnF,IAAI,CAACe,cAAc,EAAE;QAAE,OAAO,KAAK;MAAC;MACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;IACjC;EACF;;EAEA;EACAxB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAACsG,IAAI,CAACH,IAAI,CAAC,CAACjB,GAAG,CAAC,CAACgB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;EAE9C;EACA7B,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA7B,WAAW,CAACK,MAAM,EAAE0E,EAAE,CAAC;;EAEvB;EACA,IAAIR,OAAO,KAAK,CAAC,EAAE;IACjBlE,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACmF,UAAU,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA,IAAI7B,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;EACA,OAAO,IAAI;AACb;AAEA,SAASrC,SAAS,CAAEV,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxCb,KAAK,CAAC,qBAAqB,CAAC;EAC5B,MAAM8E,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM8E,GAAG,GAAGnD,QAAQ,CAACmD,GAAG,GAAGlG,QAAQ,CAACoG,QAAQ,GAAG,CAAC;EAChD,MAAML,EAAE,GAAGhD,QAAQ,CAACiD,SAAS;EAC7B,MAAMO,IAAI,GAAGxD,QAAQ,CAACyD,aAAa;EACnC,MAAMhD,UAAU,GAAGT,QAAQ,CAACS,UAAU;EAEtC,IAAIX,MAAM,GAAG,CAAC;;EAEd;EACA,IAAI,OAAOkD,EAAE,KAAK,QAAQ,EAAE;IAC1B1E,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd,CAAC,MAAMO,MAAM,IAAI,CAAC;;EAElB;EACA,IAAIe,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;IAClD,IAAI,CAACI,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACA,IAAI,OAAO0D,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAAC1D,MAAM,EAAE;IAC3C,KAAK,IAAI4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAAC1D,MAAM,EAAE4D,CAAC,IAAI,CAAC,EAAE;MACvC,MAAMC,MAAM,GAAGH,IAAI,CAACE,CAAC,CAAC,CAAC3C,KAAK;MAC5B,MAAM6C,IAAI,GAAGJ,IAAI,CAACE,CAAC,CAAC,CAACvB,GAAG;MAExB,IAAI,OAAOwB,MAAM,KAAK,QAAQ,EAAE;QAC9BrF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,uCAAuC,CAAC,CAAC;QACxE,OAAO,KAAK;MACd;MACA,IAAI,OAAOqE,IAAI,KAAK,QAAQ,EAAE;QAC5BtF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,qCAAqC,CAAC,CAAC;QACtE,OAAO,KAAK;MACd;MAEA,IAAIiD,OAAO,KAAK,CAAC,EAAE;QACjB,MAAMqB,EAAE,GAAGL,IAAI,CAACE,CAAC,CAAC,CAACG,EAAE,IAAI,KAAK;QAC9B,IAAI,OAAOA,EAAE,KAAK,SAAS,EAAE;UAC3BvF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,0CAA0C,CAAC,CAAC;UAC3E,OAAO,KAAK;QACd;QACA,MAAMuE,GAAG,GAAGN,IAAI,CAACE,CAAC,CAAC,CAACI,GAAG,IAAI,KAAK;QAChC,IAAI,OAAOA,GAAG,KAAK,SAAS,EAAE;UAC5BxF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,qDAAqD,CAAC,CAAC;UACtF,OAAO,KAAK;QACd;QACA,MAAMwE,EAAE,GAAGP,IAAI,CAACE,CAAC,CAAC,CAACK,EAAE,IAAI,CAAC;QAC1B,IAAI,OAAOA,EAAE,KAAK,QAAQ,IAAIA,EAAE,GAAG,CAAC,EAAE;UACpCzF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,iDAAiD,CAAC,CAAC;UAClF,OAAO,KAAK;QACd;MACF;MAEAO,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAAC+C,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;IAC7C;EACF,CAAC,MAAM;IACLrF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,uBAAuB,CAAC,CAAC;IACxD,OAAO,KAAK;EACd;;EAEA;EACA7B,KAAK,CAAC,kCAAkC,EAAET,QAAQ,CAAC+G,gBAAgB,CAAC;EACpE1F,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAAC+G,gBAAgB,CAAC,CAAC,CAAC,CAACb,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;EAE1D;EACA7B,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA7B,WAAW,CAACK,MAAM,EAAE0E,EAAE,CAAC;;EAEvB;EACA,IAAInC,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;EAEA,IAAI6C,MAAM,GAAG,IAAI;;EAEjB;EACA,KAAK,MAAMC,GAAG,IAAIV,IAAI,EAAE;IACtB,MAAMW,MAAM,GAAGD,GAAG,CAACnD,KAAK;IACxB,MAAMqD,IAAI,GAAGF,GAAG,CAAC/B,GAAG;IACpB,MAAMkC,GAAG,GAAG,CAACH,GAAG,CAACL,EAAE;IACnB,MAAMS,IAAI,GAAG,CAACJ,GAAG,CAACJ,GAAG;IACrB,MAAMS,GAAG,GAAGL,GAAG,CAACH,EAAE;IAClB,IAAIS,QAAQ;;IAEZ;IACAjC,WAAW,CAACjE,MAAM,EAAE6F,MAAM,CAAC;;IAE3B;IACAK,QAAQ,GAAGvH,QAAQ,CAACwH,qBAAqB,CAACL,IAAI,CAAC;IAC/C,IAAI5B,OAAO,KAAK,CAAC,EAAE;MACjBgC,QAAQ,IAAIH,GAAG,GAAGpH,QAAQ,CAACyH,oBAAoB,GAAG,CAAC;MACnDF,QAAQ,IAAIF,IAAI,GAAGrH,QAAQ,CAAC0H,qBAAqB,GAAG,CAAC;MACrDH,QAAQ,IAAID,GAAG,GAAGtH,QAAQ,CAAC2H,oBAAoB,CAACL,GAAG,CAAC,GAAG,CAAC;IAC1D;IACA;IACAN,MAAM,GAAG3F,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACiH,QAAQ,CAAC,CAAC,CAAC;EAChD;EAEA,OAAOP,MAAM;AACf;AAEA,SAASjF,MAAM,CAAEX,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACrC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM2E,EAAE,GAAGhD,QAAQ,CAACiD,SAAS;EAC7B,MAAM4B,OAAO,GAAG7E,QAAQ,CAAC6E,OAAO;EAChC,MAAMpE,UAAU,GAAGT,QAAQ,CAACS,UAAU;EACtC,IAAIX,MAAM,GAAG,CAAC;;EAEd;EACA,IAAI,OAAOkD,EAAE,KAAK,QAAQ,EAAE;IAC1B1E,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd,CAAC,MAAMO,MAAM,IAAI,CAAC;;EAElB;EACA,IAAI,OAAO+E,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAAC/E,MAAM,EAAE;IACjD,KAAK,IAAI4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,OAAO,CAAC/E,MAAM,EAAE4D,CAAC,IAAI,CAAC,EAAE;MAC1C,IAAI,OAAOmB,OAAO,CAACnB,CAAC,CAAC,KAAK,QAAQ,EAAE;QAClCpF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;QACrD,OAAO,KAAK;MACd;MACAO,MAAM,IAAI,CAAC;IACb;EACF,CAAC,MAAM;IACLxB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;IACrD,OAAO,KAAK;EACd;;EAEA;EACA,IAAIsB,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGyC,gCAAgC,CAAChF,MAAM,EAAEmC,UAAU,EAAElC,IAAI,EAAEuB,MAAM,CAAC;IACnF,IAAI,CAACe,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACAxB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAAC6H,aAAa,CAAC;;EAEpC;EACAxD,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA7B,WAAW,CAACK,MAAM,EAAE0E,EAAE,CAAC;;EAEvB;EACA,IAAInC,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;EAEA,OAAO9C,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAACsH,OAAO,CAAC,CAAC;AAC3C;AAEA,SAAS5F,WAAW,CAAEZ,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAC1C,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM2E,EAAE,GAAGhD,QAAQ,CAACiD,SAAS;EAC7B,MAAME,GAAG,GAAGnD,QAAQ,CAACmD,GAAG,GAAGlG,QAAQ,CAACoG,QAAQ,GAAG,CAAC;EAChD,MAAM0B,MAAM,GAAG/E,QAAQ,CAACgF,eAAe;EACvC,MAAMvE,UAAU,GAAGT,QAAQ,CAACS,UAAU;EAEtC,IAAIX,MAAM,GAAG,CAAC;;EAEd;EACA,IAAI,OAAOkD,EAAE,KAAK,QAAQ,EAAE;IAC1B1E,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd,CAAC,MAAM;IACLO,MAAM,IAAI,CAAC;EACb;EACA;EACA,IAAI,OAAOiF,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACjF,MAAM,EAAE;IAC/C,KAAK,IAAI4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,MAAM,CAACjF,MAAM,EAAE4D,CAAC,IAAI,CAAC,EAAE;MACzC,IAAI,OAAOqB,MAAM,CAACrB,CAAC,CAAC,KAAK,QAAQ,EAAE;QACjCpF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC1D,OAAO,KAAK;MACd;MACAO,MAAM,IAAI1C,MAAM,CAACwD,UAAU,CAACmE,MAAM,CAACrB,CAAC,CAAC,CAAC,GAAG,CAAC;IAC5C;EACF,CAAC,MAAM;IACLpF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC1D,OAAO,KAAK;EACd;EACA;EACA,IAAIsB,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;IAClD,IAAI,CAACI,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACAxB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAACgI,kBAAkB,CAAC,CAAC,CAAC,CAAC9B,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;EAE5D;EACA7B,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA7B,WAAW,CAACK,MAAM,EAAE0E,EAAE,CAAC;;EAEvB;EACA,IAAInC,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;;EAEA;EACA,IAAI6C,MAAM,GAAG,IAAI;EACjB,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACjF,MAAM,EAAEoF,CAAC,EAAE,EAAE;IACtCjB,MAAM,GAAG1B,WAAW,CAACjE,MAAM,EAAEyG,MAAM,CAACG,CAAC,CAAC,CAAC;EACzC;EAEA,OAAOjB,MAAM;AACf;AAEA,SAAS/E,QAAQ,CAAEb,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACvC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAM2E,EAAE,GAAGhD,QAAQ,CAACiD,SAAS;EAC7B,MAAME,GAAG,GAAGnD,QAAQ,CAACmD,GAAG,GAAGlG,QAAQ,CAACoG,QAAQ,GAAG,CAAC;EAChD,MAAMwB,OAAO,GAAG7E,QAAQ,CAAC6E,OAAO;EAChC,MAAMpE,UAAU,GAAGT,QAAQ,CAACS,UAAU;EACtC,MAAM2C,IAAI,GAAGpD,QAAQ,CAACtB,GAAG;EACzB,MAAMyD,GAAG,GAAG,CAAC;EAEb,IAAIrC,MAAM,GAAG,CAAC;;EAEd;EACA,IAAI,OAAOkD,EAAE,KAAK,QAAQ,EAAE;IAC1B1E,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd;;EAEA;EACA,IAAIiD,OAAO,KAAK,CAAC,EAAE;IACjB,IAAI,OAAOqC,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAAC/E,MAAM,EAAE;MACjD,KAAK,IAAI4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,OAAO,CAAC/E,MAAM,EAAE4D,CAAC,IAAI,CAAC,EAAE;QAC1C,IAAI,OAAOmB,OAAO,CAACnB,CAAC,CAAC,KAAK,QAAQ,EAAE;UAClCpF,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;UACrD,OAAO,KAAK;QACd;QACAO,MAAM,IAAI,CAAC;MACb;IACF,CAAC,MAAM;MACLxB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;MACrD,OAAO,KAAK;IACd;EACF;;EAEA;EACA,IAAIsB,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGyC,gCAAgC,CAAChF,MAAM,EAAEmC,UAAU,EAAElC,IAAI,EAAEuB,MAAM,CAAC;IACnF,IAAI,CAACe,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACAxB,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAACsG,IAAI,CAACH,IAAI,CAAC,CAACjB,GAAG,CAAC,CAACgB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;EAE9C;EACA7B,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA7B,WAAW,CAACK,MAAM,EAAE0E,EAAE,CAAC;;EAEvB;EACA,IAAInC,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;;EAEA;EACA,IAAIoB,OAAO,KAAK,CAAC,EAAE;IACjBlE,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAACsH,OAAO,CAAC,CAAC;EACpC;EACA,OAAO,IAAI;AACb;AAEA,SAAS1F,WAAW,CAAEd,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAC1C,OAAOD,MAAM,CAAC8C,KAAK,CAACnE,QAAQ,CAACkI,KAAK,CAAC9G,MAAM,CAACK,GAAG,CAAC,CAAC;AACjD;AAEA,SAASU,UAAU,CAAEf,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACzC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAMqE,UAAU,GAAG1C,QAAQ,CAAC0C,UAAU;EACtC,MAAMjC,UAAU,GAAGT,QAAQ,CAACS,UAAU;EACtC,IAAIX,MAAM,GAAG0C,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;;EAElC;EACA,IAAI3B,cAAc,GAAG,IAAI;EACzB,IAAI2B,OAAO,KAAK,CAAC,EAAE;IACjB3B,cAAc,GAAGyC,gCAAgC,CAAChF,MAAM,EAAEmC,UAAU,EAAElC,IAAI,EAAEuB,MAAM,CAAC;IACnF,IAAI,CAACe,cAAc,EAAE;MAAE,OAAO,KAAK;IAAC;IACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;EACjC;;EAEA;EACAxB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACmI,KAAK,CAAChG,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC;;EAE3D;EACAkC,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACA,IAAI0C,OAAO,KAAK,CAAC,EAAE;IACjBlE,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACmF,UAAU,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA,IAAI7B,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;EAEA,OAAO,IAAI;AACb;AAEA,SAAS/B,IAAI,CAAEhB,MAAM,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACnC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAe,GAAG,CAAC;EAC/C,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,CAAC,CAAC;EAC7B,MAAMqE,UAAU,GAAG1C,QAAQ,CAAC0C,UAAU;EACtC,MAAMjC,UAAU,GAAGT,QAAQ,CAACS,UAAU;EACtC,IAAIX,MAAM,GAAG0C,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;EAElC,IAAIA,OAAO,KAAK,CAAC,EAAElE,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,sCAAsC,CAAC,CAAC;;EAE1F;EACA,MAAMsB,cAAc,GAAGyC,gCAAgC,CAAChF,MAAM,EAAEmC,UAAU,EAAElC,IAAI,EAAEuB,MAAM,CAAC;EACzF,IAAI,CAACe,cAAc,EAAE;IAAE,OAAO,KAAK;EAAC;EACpCf,MAAM,IAAIe,cAAc,CAACf,MAAM;;EAE/B;EACAxB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACmI,KAAK,CAAC/F,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC;;EAErD;EACAiC,eAAe,CAAChD,MAAM,EAAEwB,MAAM,CAAC;;EAE/B;EACAxB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACmF,UAAU,CAAC,CAAC,CAAC;;EAEvC;EACA,IAAI7B,cAAc,KAAK,IAAI,EAAE;IAC3BA,cAAc,CAACO,KAAK,EAAE;EACxB;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMiE,eAAe,GAAG,CAAC,CAAC;AAC1B,SAAS/D,eAAe,CAAEhD,MAAM,EAAEgH,GAAG,EAAE;EACrC,IAAIA,GAAG,GAAGrI,QAAQ,CAACsI,cAAc,EAAE;IACjCjH,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,kCAAiC+F,GAAI,EAAC,CAAC,CAAC;IACxE,OAAO,KAAK;EACd;EAEA,IAAIE,MAAM,GAAGH,eAAe,CAACC,GAAG,CAAC;EAEjC,IAAI,CAACE,MAAM,EAAE;IACXA,MAAM,GAAGzH,qBAAqB,CAACuH,GAAG,CAAC;IACnC,IAAIA,GAAG,GAAG,KAAK,EAAED,eAAe,CAACC,GAAG,CAAC,GAAGE,MAAM;EAChD;EACA9H,KAAK,CAAC,wCAAwC,EAAE8H,MAAM,CAAC;EACvD,OAAOlH,MAAM,CAAC8C,KAAK,CAACoE,MAAM,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASjD,WAAW,CAAEjE,MAAM,EAAEmH,MAAM,EAAE;EACpC,MAAMC,MAAM,GAAGtI,MAAM,CAACwD,UAAU,CAAC6E,MAAM,CAAC;EACxCxH,WAAW,CAACK,MAAM,EAAEoH,MAAM,CAAC;EAE3BhI,KAAK,CAAC,iBAAiB,EAAE+H,MAAM,CAAC;EAChC,OAAOnH,MAAM,CAAC8C,KAAK,CAACqE,MAAM,EAAE,MAAM,CAAC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,eAAe,CAAErH,MAAM,EAAEsH,IAAI,EAAEhG,KAAK,EAAE;EAC7C2C,WAAW,CAACjE,MAAM,EAAEsH,IAAI,CAAC;EACzBrD,WAAW,CAACjE,MAAM,EAAEsB,KAAK,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1B,iBAAiB,CAAEI,MAAM,EAAEuH,MAAM,EAAE;EAC1CnI,KAAK,CAAC,+BAA+B,EAAEmI,MAAM,CAAC;EAC9CnI,KAAK,CAAC,uBAAuB,EAAEC,QAAQ,CAACkI,MAAM,CAAC,CAAC;EAChD,OAAOvH,MAAM,CAAC8C,KAAK,CAACzD,QAAQ,CAACkI,MAAM,CAAC,CAAC;AACvC;AACA,SAAS9F,oBAAoB,CAAEzB,MAAM,EAAEuH,MAAM,EAAE;EAC7C,MAAMC,eAAe,GAAGjI,cAAc,CAACgI,MAAM,CAAC;EAC9CnI,KAAK,CAAC,0BAA0B,EAAEoI,eAAe,CAAC;EAClD,OAAOxH,MAAM,CAAC8C,KAAK,CAAC0E,eAAe,CAAC;AACtC;AACA,SAASC,gBAAgB,CAAEzH,MAAM,EAAEuH,MAAM,EAAE;EACzC,MAAMG,oBAAoB,GAAGhI,mBAAmB,CAAC6H,MAAM,CAAC;EACxDnI,KAAK,CAAC,sBAAsB,EAAEsI,oBAAoB,CAAC;EACnD,OAAO1H,MAAM,CAAC8C,KAAK,CAAC4E,oBAAoB,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzE,mBAAmB,CAAEjD,MAAM,EAAE2H,OAAO,EAAE;EAC7C,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC/B1D,WAAW,CAACjE,MAAM,EAAE2H,OAAO,CAAC;EAC9B,CAAC,MAAM,IAAIA,OAAO,EAAE;IAClBhI,WAAW,CAACK,MAAM,EAAE2H,OAAO,CAACnG,MAAM,CAAC;IACnCxB,MAAM,CAAC8C,KAAK,CAAC6E,OAAO,CAAC;EACvB,CAAC,MAAMhI,WAAW,CAACK,MAAM,EAAE,CAAC,CAAC;AAC/B;AAEA,SAASwC,aAAa,CAAExC,MAAM,EAAEmC,UAAU,EAAE;EAC1C;EACA,IAAI,OAAOA,UAAU,KAAK,QAAQ,IAAIA,UAAU,CAACX,MAAM,IAAI,IAAI,EAAE;IAC/D,OAAO;MACLA,MAAM,EAAE,CAAC;MACTsB,KAAK,GAAI;QACP8E,eAAe,CAAC5H,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAChC;IACF,CAAC;EACH;EACA,IAAI6H,gBAAgB,GAAG,CAAC;EACxB,SAASC,iBAAiB,CAAER,IAAI,EAAEhG,KAAK,EAAE;IACvC,MAAMwD,IAAI,GAAGnG,QAAQ,CAACoJ,eAAe,CAACT,IAAI,CAAC;IAC3C,IAAI9F,MAAM,GAAG,CAAC;IACd,QAAQsD,IAAI;MACV,KAAK,MAAM;QAAE;UACX,IAAI,OAAOxD,KAAK,KAAK,SAAS,EAAE;YAC9BtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG,CAAC;UACf;QACF;MACA,KAAK,MAAM;QAAE;UACX,IAAI,OAAOF,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,IAAI,EAAE;YAC1DtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG,CAAC;UACf;QACF;MACA,KAAK,QAAQ;QAAE;UACb,IAAIF,KAAK,IAAIA,KAAK,KAAK,IAAI,EAAE;YAC3BtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG1C,MAAM,CAACwD,UAAU,CAAChB,KAAK,CAAC,GAAG,CAAC;UAC1C;QACF;MACA,KAAK,OAAO;QAAE;UACZ,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,MAAM,EAAE;YAC5DtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG,CAAC;UACf;QACF;MACA,KAAK,OAAO;QAAE;UACZ,IAAI,OAAOF,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,UAAU,EAAE;YAChEtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG,CAAC;UACf;QACF;MACA,KAAK,KAAK;QAAE;UACV;UACA,IAAI,OAAOF,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,UAAU,EAAE;YAChEtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG1C,MAAM,CAACwD,UAAU,CAAC7C,qBAAqB,CAAC6B,KAAK,CAAC,CAAC;UAC7D;QACF;MACA,KAAK,QAAQ;QAAE;UACb,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;YAC7BtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG1C,MAAM,CAACwD,UAAU,CAAChB,KAAK,CAAC0G,QAAQ,EAAE,CAAC;UACrD;QACF;MACA,KAAK,MAAM;QAAE;UACX,IAAI,OAAO1G,KAAK,KAAK,QAAQ,EAAE;YAC7BtB,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,WAAUqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;YAC5D,OAAO,KAAK;UACd;UACAE,MAAM,IAAIN,MAAM,CAAC+G,mBAAmB,CAAC3G,KAAK,CAAC,CAAC4G,MAAM,CAAC,CAACvC,MAAM,EAAE2B,IAAI,KAAK;YACnE,MAAMa,YAAY,GAAG7G,KAAK,CAACgG,IAAI,CAAC;YAChC,IAAIc,KAAK,CAACC,OAAO,CAACF,YAAY,CAAC,EAAE;cAC/BxC,MAAM,IAAIwC,YAAY,CAACD,MAAM,CAAC,CAACI,aAAa,EAAEhH,KAAK,KAAK;gBACtDgH,aAAa,IAAI,CAAC,GAAG,CAAC,GAAGxJ,MAAM,CAACwD,UAAU,CAACgF,IAAI,CAACU,QAAQ,EAAE,CAAC,GAAG,CAAC,GAAGlJ,MAAM,CAACwD,UAAU,CAAChB,KAAK,CAAC0G,QAAQ,EAAE,CAAC;gBACrG,OAAOM,aAAa;cACtB,CAAC,EAAE,CAAC,CAAC;YACP,CAAC,MAAM;cACL3C,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG7G,MAAM,CAACwD,UAAU,CAACgF,IAAI,CAACU,QAAQ,EAAE,CAAC,GAAG,CAAC,GAAGlJ,MAAM,CAACwD,UAAU,CAAChB,KAAK,CAACgG,IAAI,CAAC,CAACU,QAAQ,EAAE,CAAC;YACtG;YACA,OAAOrC,MAAM;UACf,CAAC,EAAE,CAAC,CAAC;UACL;QACF;MACA;QAAS;UACP3F,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,oBAAmBqG,IAAK,KAAIhG,KAAM,EAAC,CAAC,CAAC;UACrE,OAAO,KAAK;QACd;IAAC;IAEH,OAAOE,MAAM;EACf;EACA,IAAIW,UAAU,EAAE;IACd,KAAK,MAAMoG,QAAQ,IAAIpG,UAAU,EAAE;MACjC,IAAIqG,UAAU,GAAG,CAAC;MAClB,IAAIC,eAAe,GAAG,CAAC;MACvB,MAAMC,SAAS,GAAGvG,UAAU,CAACoG,QAAQ,CAAC;MACtC,IAAIH,KAAK,CAACC,OAAO,CAACK,SAAS,CAAC,EAAE;QAC5B,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGD,SAAS,CAAClH,MAAM,EAAEmH,UAAU,EAAE,EAAE;UACpEF,eAAe,GAAGX,iBAAiB,CAACS,QAAQ,EAAEG,SAAS,CAACC,UAAU,CAAC,CAAC;UACpE,IAAI,CAACF,eAAe,EAAE;YAAE,OAAO,KAAK;UAAC;UACrCD,UAAU,IAAIC,eAAe;QAC/B;MACF,CAAC,MAAM;QACLA,eAAe,GAAGX,iBAAiB,CAACS,QAAQ,EAAEG,SAAS,CAAC;QACxD,IAAI,CAACD,eAAe,EAAE;UAAE,OAAO,KAAK;QAAC;QACrCD,UAAU,GAAGC,eAAe;MAC9B;MACA,IAAI,CAACD,UAAU,EAAE,OAAO,KAAK;MAC7BX,gBAAgB,IAAIW,UAAU;IAChC;EACF;EACA,MAAMI,sBAAsB,GAAG9J,MAAM,CAACwD,UAAU,CAAC7C,qBAAqB,CAACoI,gBAAgB,CAAC,CAAC;EAEzF,OAAO;IACLrG,MAAM,EAAEoH,sBAAsB,GAAGf,gBAAgB;IACjD/E,KAAK,GAAI;MACP8E,eAAe,CAAC5H,MAAM,EAAEmC,UAAU,EAAE0F,gBAAgB,CAAC;IACvD;EACF,CAAC;AACH;AAEA,SAAS7C,gCAAgC,CAAEhF,MAAM,EAAEmC,UAAU,EAAElC,IAAI,EAAEuB,MAAM,EAAE;EAC3E,MAAMqH,aAAa,GAAG,CAAC,cAAc,EAAE,gBAAgB,CAAC;EACxD,MAAMC,iBAAiB,GAAG7I,IAAI,IAAIA,IAAI,CAACkC,UAAU,IAAIlC,IAAI,CAACkC,UAAU,CAAC2G,iBAAiB,GAAG7I,IAAI,CAACkC,UAAU,CAAC2G,iBAAiB,GAAG,CAAC;EAE9H,IAAIvG,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;EACtD,IAAI2G,iBAAiB,EAAE;IACrB,OAAOtH,MAAM,GAAGe,cAAc,CAACf,MAAM,GAAGsH,iBAAiB,EAAE;MACzD,MAAMC,mBAAmB,GAAGF,aAAa,CAACG,KAAK,EAAE;MACjD,IAAID,mBAAmB,IAAI5G,UAAU,CAAC4G,mBAAmB,CAAC,EAAE;QAC1D,OAAO5G,UAAU,CAAC4G,mBAAmB,CAAC;QACtCxG,cAAc,GAAGC,aAAa,CAACxC,MAAM,EAAEmC,UAAU,CAAC;MACpD,CAAC,MAAM;QACL,OAAO,KAAK;MACd;IACF;EACF;EACA,OAAOI,cAAc;AACvB;AAEA,SAAS0G,aAAa,CAAEjJ,MAAM,EAAEuI,QAAQ,EAAEjH,KAAK,EAAE;EAC/C,MAAMwD,IAAI,GAAGnG,QAAQ,CAACoJ,eAAe,CAACQ,QAAQ,CAAC;EAC/C,QAAQzD,IAAI;IACV,KAAK,MAAM;MAAE;QACX9E,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1DvI,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAAC,CAACqC,KAAK,CAAC,CAAC,CAAC;QACnC;MACF;IACA,KAAK,MAAM;MAAE;QACXtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1DvI,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACqC,KAAK,CAAC,CAAC,CAAC;QAClC;MACF;IACA,KAAK,QAAQ;MAAE;QACbtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1DtF,mBAAmB,CAACjD,MAAM,EAAEsB,KAAK,CAAC;QAClC;MACF;IACA,KAAK,OAAO;MAAE;QACZtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1D5I,WAAW,CAACK,MAAM,EAAEsB,KAAK,CAAC;QAC1B;MACF;IACA,KAAK,OAAO;MAAE;QACZtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1Dd,gBAAgB,CAACzH,MAAM,EAAEsB,KAAK,CAAC;QAC/B;MACF;IACA,KAAK,KAAK;MAAE;QACVtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1DvF,eAAe,CAAChD,MAAM,EAAEsB,KAAK,CAAC;QAC9B;MACF;IACA,KAAK,QAAQ;MAAE;QACbtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1DtE,WAAW,CAACjE,MAAM,EAAEsB,KAAK,CAAC;QAC1B;MACF;IACA,KAAK,MAAM;MAAE;QACXJ,MAAM,CAAC+G,mBAAmB,CAAC3G,KAAK,CAAC,CAAC4H,OAAO,CAAC5B,IAAI,IAAI;UAChD,MAAMa,YAAY,GAAG7G,KAAK,CAACgG,IAAI,CAAC;UAChC,IAAIc,KAAK,CAACC,OAAO,CAACF,YAAY,CAAC,EAAE;YAC/BA,YAAY,CAACe,OAAO,CAAC5H,KAAK,IAAI;cAC5BtB,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;cAC1DlB,eAAe,CAACrH,MAAM,EAAEsH,IAAI,CAACU,QAAQ,EAAE,EAAE1G,KAAK,CAAC0G,QAAQ,EAAE,CAAC;YAC5D,CAAC,CAAC;UACJ,CAAC,MAAM;YACLhI,MAAM,CAAC8C,KAAK,CAAChE,MAAM,CAACG,IAAI,CAAC,CAACN,QAAQ,CAACwD,UAAU,CAACoG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1DlB,eAAe,CAACrH,MAAM,EAAEsH,IAAI,CAACU,QAAQ,EAAE,EAAEG,YAAY,CAACH,QAAQ,EAAE,CAAC;UACnE;QACF,CAAC,CAAC;QACF;MACF;IACA;MAAS;QACPhI,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAE,oBAAmBsH,QAAS,WAAUjH,KAAM,EAAC,CAAC,CAAC;QAC/E,OAAO,KAAK;MACd;EAAC;AAEL;AAEA,SAASsG,eAAe,CAAE5H,MAAM,EAAEmC,UAAU,EAAE0F,gBAAgB,EAAE;EAC9D;EACA7E,eAAe,CAAChD,MAAM,EAAE6H,gBAAgB,CAAC;EACzC,KAAK,MAAMU,QAAQ,IAAIpG,UAAU,EAAE;IACjC,IAAIjB,MAAM,CAACiI,SAAS,CAACC,cAAc,CAACC,IAAI,CAAClH,UAAU,EAAEoG,QAAQ,CAAC,IAAIpG,UAAU,CAACoG,QAAQ,CAAC,KAAK,IAAI,EAAE;MAC/F,MAAMjH,KAAK,GAAGa,UAAU,CAACoG,QAAQ,CAAC;MAClC,IAAIH,KAAK,CAACC,OAAO,CAAC/G,KAAK,CAAC,EAAE;QACxB,KAAK,IAAIqH,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGrH,KAAK,CAACE,MAAM,EAAEmH,UAAU,EAAE,EAAE;UAChEM,aAAa,CAACjJ,MAAM,EAAEuI,QAAQ,EAAEjH,KAAK,CAACqH,UAAU,CAAC,CAAC;QACpD;MACF,CAAC,MAAM;QACLM,aAAa,CAACjJ,MAAM,EAAEuI,QAAQ,EAAEjH,KAAK,CAAC;MACxC;IACF;EACF;AACF;AAEA,SAASgB,UAAU,CAAEgH,WAAW,EAAE;EAChC,IAAI,CAACA,WAAW,EAAE,OAAO,CAAC,MACrB,IAAIA,WAAW,YAAYxK,MAAM,EAAE,OAAOwK,WAAW,CAAC9H,MAAM,MAC5D,OAAO1C,MAAM,CAACwD,UAAU,CAACgH,WAAW,CAAC;AAC5C;AAEA,SAASzG,gBAAgB,CAAE0G,KAAK,EAAE;EAChC,OAAO,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAYzK,MAAM;AAC7D;AAEA0K,MAAM,CAACC,OAAO,GAAG3J,QAAQ"},"metadata":{},"sourceType":"script"}