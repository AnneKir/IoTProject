{"ast":null,"code":"import { asyncScheduler } from '../scheduler/async';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function debounceTime(dueTime, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = asyncScheduler;\n  }\n  return operate(function (source, subscriber) {\n    var activeTask = null;\n    var lastValue = null;\n    var lastTime = null;\n    var emit = function emit() {\n      if (activeTask) {\n        activeTask.unsubscribe();\n        activeTask = null;\n        var value = lastValue;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle() {\n      var targetTime = lastTime + dueTime;\n      var now = scheduler.now();\n      if (now < targetTime) {\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n      emit();\n    }\n    source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n      lastValue = value;\n      lastTime = scheduler.now();\n      if (!activeTask) {\n        activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n        subscriber.add(activeTask);\n      }\n    }, function () {\n      emit();\n      subscriber.complete();\n    }, undefined, function () {\n      lastValue = activeTask = null;\n    }));\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAc,QAAQ,oBAAoB;AAGnD,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,wBAAwB,QAAQ,sBAAsB;AA2D/D,OAAM,SAAUC,YAAY,CAAIC,OAAe,EAAEC,SAAyC;EAAzC;IAAAA,0BAAyC;EAAA;EACxF,OAAOJ,OAAO,CAAC,UAACK,MAAM,EAAEC,UAAU;IAChC,IAAIC,UAAU,GAAwB,IAAI;IAC1C,IAAIC,SAAS,GAAa,IAAI;IAC9B,IAAIC,QAAQ,GAAkB,IAAI;IAElC,IAAMC,IAAI,GAAG,SAAPA,IAAI,GAAG;MACX,IAAIH,UAAU,EAAE;QAEdA,UAAU,CAACI,WAAW,EAAE;QACxBJ,UAAU,GAAG,IAAI;QACjB,IAAMK,KAAK,GAAGJ,SAAU;QACxBA,SAAS,GAAG,IAAI;QAChBF,UAAU,CAACO,IAAI,CAACD,KAAK,CAAC;;IAE1B,CAAC;IACD,SAASE,YAAY;MAInB,IAAMC,UAAU,GAAGN,QAAS,GAAGN,OAAO;MACtC,IAAMa,GAAG,GAAGZ,SAAS,CAACY,GAAG,EAAE;MAC3B,IAAIA,GAAG,GAAGD,UAAU,EAAE;QAEpBR,UAAU,GAAG,IAAI,CAACU,QAAQ,CAACC,SAAS,EAAEH,UAAU,GAAGC,GAAG,CAAC;QACvDV,UAAU,CAACa,GAAG,CAACZ,UAAU,CAAC;QAC1B;;MAGFG,IAAI,EAAE;IACR;IAEAL,MAAM,CAACe,SAAS,CACdnB,wBAAwB,CACtBK,UAAU,EACV,UAACM,KAAQ;MACPJ,SAAS,GAAGI,KAAK;MACjBH,QAAQ,GAAGL,SAAS,CAACY,GAAG,EAAE;MAG1B,IAAI,CAACT,UAAU,EAAE;QACfA,UAAU,GAAGH,SAAS,CAACa,QAAQ,CAACH,YAAY,EAAEX,OAAO,CAAC;QACtDG,UAAU,CAACa,GAAG,CAACZ,UAAU,CAAC;;IAE9B,CAAC,EACD;MAGEG,IAAI,EAAE;MACNJ,UAAU,CAACe,QAAQ,EAAE;IACvB,CAAC,EAEDH,SAAS,EACT;MAEEV,SAAS,GAAGD,UAAU,GAAG,IAAI;IAC/B,CAAC,CACF,CACF;EACH,CAAC,CAAC;AACJ","names":["asyncScheduler","operate","createOperatorSubscriber","debounceTime","dueTime","scheduler","source","subscriber","activeTask","lastValue","lastTime","emit","unsubscribe","value","next","emitWhenIdle","targetTime","now","schedule","undefined","add","subscribe","complete"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\debounceTime.ts"],"sourcesContent":["import { asyncScheduler } from '../scheduler/async';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits a notification from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent notification from each burst of emissions.</span>\r\n *\r\n * ![](debounceTime.png)\r\n *\r\n * `debounceTime` delays notifications emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new notification arrives on the source\r\n * Observable. This operator keeps track of the most recent notification from the\r\n * source Observable, and emits that only when `dueTime` has passed\r\n * without any other notification appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous notification will be dropped\r\n * and will not be emitted and a new `dueTime` is scheduled.\r\n * If the completing event happens during `dueTime` the last cached notification\r\n * is emitted before the completion event is forwarded to the output observable.\r\n * If the error event happens during `dueTime` or after it only the error event is\r\n * forwarded to the output observable. The cache notification is not emitted in this case.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * notification to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\r\n * managing timers.\r\n *\r\n * ## Example\r\n *\r\n * Emit the most recent click after a burst of clicks\r\n *\r\n * ```ts\r\n * import { fromEvent, debounceTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(debounceTime(1000));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} dueTime The timeout duration in milliseconds (or the time\r\n * unit determined internally by the optional `scheduler`) for the window of\r\n * time required to wait for emission silence before emitting the most recent\r\n * source value.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\r\n * managing the timers that handle the timeout for each value.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by the specified `dueTime`, and may drop some values\r\n * if they occur too frequently.\r\n */\r\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let activeTask: Subscription | null = null;\r\n    let lastValue: T | null = null;\r\n    let lastTime: number | null = null;\r\n\r\n    const emit = () => {\r\n      if (activeTask) {\r\n        // We have a value! Free up memory first, then emit the value.\r\n        activeTask.unsubscribe();\r\n        activeTask = null;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\r\n      // This is called `dueTime` after the first value\r\n      // but we might have received new values during this window!\r\n\r\n      const targetTime = lastTime! + dueTime;\r\n      const now = scheduler.now();\r\n      if (now < targetTime) {\r\n        // On that case, re-schedule to the new target\r\n        activeTask = this.schedule(undefined, targetTime - now);\r\n        subscriber.add(activeTask);\r\n        return;\r\n      }\r\n\r\n      emit();\r\n    }\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          lastValue = value;\r\n          lastTime = scheduler.now();\r\n\r\n          // Only set up a task if it's not already up\r\n          if (!activeTask) {\r\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\r\n            subscriber.add(activeTask);\r\n          }\r\n        },\r\n        () => {\r\n          // Source completed.\r\n          // Emit any pending debounced values then complete\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer.\r\n        undefined,\r\n        () => {\r\n          // Finalization.\r\n          lastValue = activeTask = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}