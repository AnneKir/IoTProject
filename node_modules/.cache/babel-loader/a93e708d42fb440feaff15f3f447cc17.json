{"ast":null,"code":"import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function refCount() {\n  return operate(function (source, subscriber) {\n    var connection = null;\n    source._refCount++;\n    var refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {\n      if (!source || source._refCount <= 0 || 0 < --source._refCount) {\n        connection = null;\n        return;\n      }\n      var sharedConnection = source._connection;\n      var conn = connection;\n      connection = null;\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n      subscriber.unsubscribe();\n    });\n    source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      connection = source.connect();\n    }\n  });\n}","map":{"version":3,"mappings":"AAGA,SAASA,OAAO,QAAQ,cAAc;AACtC,SAASC,wBAAwB,QAAQ,sBAAsB;AA4D/D,OAAM,SAAUC,QAAQ;EACtB,OAAOF,OAAO,CAAC,UAACG,MAAM,EAAEC,UAAU;IAChC,IAAIC,UAAU,GAAwB,IAAI;IAEzCF,MAAc,CAACG,SAAS,EAAE;IAE3B,IAAMC,UAAU,GAAGN,wBAAwB,CAACG,UAAU,EAAEI,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE;MACvF,IAAI,CAACL,MAAM,IAAKA,MAAc,CAACG,SAAS,IAAI,CAAC,IAAI,CAAC,GAAG,EAAGH,MAAc,CAACG,SAAS,EAAE;QAChFD,UAAU,GAAG,IAAI;QACjB;;MA4BF,IAAMI,gBAAgB,GAAIN,MAAc,CAACO,WAAW;MACpD,IAAMC,IAAI,GAAGN,UAAU;MACvBA,UAAU,GAAG,IAAI;MAEjB,IAAII,gBAAgB,KAAK,CAACE,IAAI,IAAIF,gBAAgB,KAAKE,IAAI,CAAC,EAAE;QAC5DF,gBAAgB,CAACG,WAAW,EAAE;;MAGhCR,UAAU,CAACQ,WAAW,EAAE;IAC1B,CAAC,CAAC;IAEFT,MAAM,CAACU,SAAS,CAACN,UAAU,CAAC;IAE5B,IAAI,CAACA,UAAU,CAACO,MAAM,EAAE;MACtBT,UAAU,GAAIF,MAAmC,CAACY,OAAO,EAAE;;EAE/D,CAAC,CAAC;AACJ","names":["operate","createOperatorSubscriber","refCount","source","subscriber","connection","_refCount","refCounter","undefined","sharedConnection","_connection","conn","unsubscribe","subscribe","closed","connect"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\refCount.ts"],"sourcesContent":["import { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\r\n * you can connect to it.\r\n *\r\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\r\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\r\n * unsubscribes from the source. This way you can make sure that everything before the *published*\r\n * refCount has only a single subscription independently of the number of subscribers to the target\r\n * observable.\r\n *\r\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\r\n * (making the observable hot) and the *refCount* operator in a sequence.\r\n *\r\n * ![](refCount.png)\r\n *\r\n * ## Example\r\n *\r\n * In the following example there are two intervals turned into connectable observables\r\n * by using the *publish* operator. The first one uses the *refCount* operator, the\r\n * second one does not use it. You will notice that a connectable observable does nothing\r\n * until you call its connect function.\r\n *\r\n * ```ts\r\n * import { interval, tap, publish, refCount } from 'rxjs';\r\n *\r\n * // Turn the interval observable into a ConnectableObservable (hot)\r\n * const refCountInterval = interval(400).pipe(\r\n *   tap(num => console.log(`refCount ${ num }`)),\r\n *   publish(),\r\n *   refCount()\r\n * );\r\n *\r\n * const publishedInterval = interval(400).pipe(\r\n *   tap(num => console.log(`publish ${ num }`)),\r\n *   publish()\r\n * );\r\n *\r\n * refCountInterval.subscribe();\r\n * refCountInterval.subscribe();\r\n * // 'refCount 0' -----> 'refCount 1' -----> etc\r\n * // All subscriptions will receive the same value and the tap (and\r\n * // every other operator) before the `publish` operator will be executed\r\n * // only once per event independently of the number of subscriptions.\r\n *\r\n * publishedInterval.subscribe();\r\n * // Nothing happens until you call .connect() on the observable.\r\n * ```\r\n *\r\n * @return A function that returns an Observable that automates the connection\r\n * to ConnectableObservable.\r\n * @see {@link ConnectableObservable}\r\n * @see {@link share}\r\n * @see {@link publish}\r\n * @deprecated Replaced with the {@link share} operator. How `share` is used\r\n * will depend on the connectable observable you created just prior to the\r\n * `refCount` operator.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let connection: Subscription | null = null;\r\n\r\n    (source as any)._refCount++;\r\n\r\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\r\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\r\n        connection = null;\r\n        return;\r\n      }\r\n\r\n      ///\r\n      // Compare the local RefCountSubscriber's connection Subscription to the\r\n      // connection Subscription on the shared ConnectableObservable. In cases\r\n      // where the ConnectableObservable source synchronously emits values, and\r\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\r\n      // execution continues to here before the RefCountOperator has a chance to\r\n      // supply the RefCountSubscriber with the shared connection Subscription.\r\n      // For example:\r\n      // ```\r\n      // range(0, 10).pipe(\r\n      //   publish(),\r\n      //   refCount(),\r\n      //   take(5),\r\n      // )\r\n      // .subscribe();\r\n      // ```\r\n      // In order to account for this case, RefCountSubscriber should only dispose\r\n      // the ConnectableObservable's shared connection Subscription if the\r\n      // connection Subscription exists, *and* either:\r\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\r\n      //      Subscription yet, or,\r\n      //   b. RefCountSubscriber's connection Subscription reference is identical\r\n      //      to the shared connection Subscription\r\n      ///\r\n\r\n      const sharedConnection = (source as any)._connection;\r\n      const conn = connection;\r\n      connection = null;\r\n\r\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\r\n        sharedConnection.unsubscribe();\r\n      }\r\n\r\n      subscriber.unsubscribe();\r\n    });\r\n\r\n    source.subscribe(refCounter);\r\n\r\n    if (!refCounter.closed) {\r\n      connection = (source as ConnectableObservable<T>).connect();\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}