{"ast":null,"code":"import { EMPTY } from './empty';\nimport { onErrorResumeNext as onErrorResumeNextWith } from '../operators/onErrorResumeNext';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nexport function onErrorResumeNext() {\n  var sources = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n  return onErrorResumeNextWith(argsOrArgArray(sources))(EMPTY);\n}","map":{"version":3,"mappings":"AAEA,SAASA,KAAK,QAAQ,SAAS;AAC/B,SAASC,iBAAiB,IAAIC,qBAAqB,QAAQ,gCAAgC;AAC3F,SAASC,cAAc,QAAQ,wBAAwB;AAsEvD,OAAM,SAAUF,iBAAiB;EAC/B;OAAA,UAAyE,EAAzEG,qBAAyE,EAAzEA,IAAyE;IAAzEC;;EAEA,OAAOH,qBAAqB,CAACC,cAAc,CAACE,OAAO,CAAC,CAAC,CAACL,KAAK,CAAC;AAC9D","names":["EMPTY","onErrorResumeNext","onErrorResumeNextWith","argsOrArgArray","_i","sources"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\onErrorResumeNext.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { ObservableInputTuple } from '../types';\r\nimport { EMPTY } from './empty';\r\nimport { onErrorResumeNext as onErrorResumeNextWith } from '../operators/onErrorResumeNext';\r\nimport { argsOrArgArray } from '../util/argsOrArgArray';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function onErrorResumeNext<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\nexport function onErrorResumeNext<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\n\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one\r\n * that was passed.\r\n *\r\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\r\n *\r\n * ![](onErrorResumeNext.png)\r\n *\r\n * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.\r\n * If the source it's subscribed to emits an error or completes, it will move to the next source\r\n * without error.\r\n *\r\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\r\n *\r\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\r\n * sources emits an error.\r\n *\r\n * Note that there is no way to handle any errors thrown by sources via the result of\r\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\r\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\r\n *\r\n * ## Example\r\n *\r\n * Subscribe to the next Observable after map fails\r\n *\r\n * ```ts\r\n * import { onErrorResumeNext, of, map } from 'rxjs';\r\n *\r\n * onErrorResumeNext(\r\n *   of(1, 2, 3, 0).pipe(\r\n *     map(x => {\r\n *       if (x === 0) {\r\n *         throw Error();\r\n *       }\r\n *       return 10 / x;\r\n *     })\r\n *   ),\r\n *   of(1, 2, 3)\r\n * )\r\n * .subscribe({\r\n *   next: value => console.log(value),\r\n *   error: err => console.log(err),     // Will never be called.\r\n *   complete: () => console.log('done')\r\n * });\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 5\r\n * // 3.3333333333333335\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 'done'\r\n * ```\r\n *\r\n * @see {@link concat}\r\n * @see {@link catchError}\r\n *\r\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\r\n * @return {Observable} An Observable that concatenates all sources, one after the other,\r\n * ignoring all errors, such that any error causes it to move on to the next source.\r\n */\r\nexport function onErrorResumeNext<A extends readonly unknown[]>(\r\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\r\n): Observable<A[number]> {\r\n  return onErrorResumeNextWith(argsOrArgArray(sources))(EMPTY);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}