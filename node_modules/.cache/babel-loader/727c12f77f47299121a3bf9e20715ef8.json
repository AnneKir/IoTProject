{"ast":null,"code":"import { operate } from '../util/lift';\nimport { scanInternals } from './scanInternals';\nexport function scan(accumulator, seed) {\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));\n}","map":{"version":3,"mappings":"AACA,SAASA,OAAO,QAAQ,cAAc;AACtC,SAASC,aAAa,QAAQ,iBAAiB;AAqF/C,OAAM,SAAUC,IAAI,CAAUC,WAA2D,EAAEC,IAAQ;EAMjG,OAAOJ,OAAO,CAACC,aAAa,CAACE,WAAW,EAAEC,IAAS,EAAEC,SAAS,CAACC,MAAM,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;AACpF","names":["operate","scanInternals","scan","accumulator","seed","arguments","length"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\scan.ts"],"sourcesContent":["import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { scanInternals } from './scanInternals';\r\n\r\nexport function scan<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\r\nexport function scan<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\r\nexport function scan<V, A, S>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\r\n\r\n// TODO: link to a \"redux pattern\" section in the guide (location TBD)\r\n\r\n/**\r\n * Useful for encapsulating and managing state. Applies an accumulator (or \"reducer function\")\r\n * to each value from the source after an initial state is established -- either via\r\n * a `seed` value (second argument), or from the first value from the source.\r\n *\r\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\r\n * accumulation state after each update</span>\r\n *\r\n * ![](scan.png)\r\n *\r\n * This operator maintains an internal state and emits it after processing each value as follows:\r\n *\r\n * 1. First value arrives\r\n *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.\r\n *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.\r\n * 2. Let `state = accumulator(state, value)`.\r\n *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.\r\n * 3. Emit `state`.\r\n * 4. Next value arrives, let `value = nextValue`, go to 2.\r\n *\r\n * ## Examples\r\n *\r\n * An average of previous numbers. This example shows how\r\n * not providing a `seed` can prime the stream with the\r\n * first value from the source.\r\n *\r\n * ```ts\r\n * import { of, scan, map } from 'rxjs';\r\n *\r\n * const numbers$ = of(1, 2, 3);\r\n *\r\n * numbers$\r\n *   .pipe(\r\n *     // Get the sum of the numbers coming in.\r\n *     scan((total, n) => total + n),\r\n *     // Get the average by dividing the sum by the total number\r\n *     // received so var (which is 1 more than the zero-based index).\r\n *     map((sum, index) => sum / (index + 1))\r\n *   )\r\n *   .subscribe(console.log);\r\n * ```\r\n *\r\n * The Fibonacci sequence. This example shows how you can use\r\n * a seed to prime accumulation process. Also... you know... Fibonacci.\r\n * So important to like, computers and stuff that its whiteboarded\r\n * in job interviews. Now you can show them the Rx version! (Please don't, haha)\r\n *\r\n * ```ts\r\n * import { interval, scan, map, startWith } from 'rxjs';\r\n *\r\n * const firstTwoFibs = [0, 1];\r\n * // An endless stream of Fibonacci numbers.\r\n * const fibonacci$ = interval(1000).pipe(\r\n *   // Scan to get the fibonacci numbers (after 0, 1)\r\n *   scan(([a, b]) => [b, a + b], firstTwoFibs),\r\n *   // Get the second number in the tuple, it's the one you calculated\r\n *   map(([, n]) => n),\r\n *   // Start with our first two digits :)\r\n *   startWith(...firstTwoFibs)\r\n * );\r\n *\r\n * fibonacci$.subscribe(console.log);\r\n * ```\r\n *\r\n * @see {@link expand}\r\n * @see {@link mergeScan}\r\n * @see {@link reduce}\r\n * @see {@link switchScan}\r\n *\r\n * @param accumulator A \"reducer function\". This will be called for each value after an initial state is\r\n * acquired.\r\n * @param seed The initial state. If this is not provided, the first value from the source will\r\n * be used as the initial state, and emitted without going through the accumulator. All subsequent values\r\n * will be processed by the accumulator function. If this is provided, all values will go through\r\n * the accumulator function.\r\n * @return A function that returns an Observable of the accumulated values.\r\n */\r\nexport function scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A> {\r\n  // providing a seed of `undefined` *should* be valid and trigger\r\n  // hasSeed! so don't use `seed !== undefined` checks!\r\n  // For this reason, we have to check it here at the original call site\r\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\r\n  // means they didn't provide anything or if they literally provided `undefined`\r\n  return operate(scanInternals(accumulator, seed as S, arguments.length >= 2, true));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}