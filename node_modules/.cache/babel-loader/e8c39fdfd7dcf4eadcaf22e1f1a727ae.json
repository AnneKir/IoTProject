{"ast":null,"code":"import { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { isFunction } from '../util/isFunction';\nexport function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\n    timestampProvider = selectorOrScheduler;\n  }\n  var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\n  return function (source) {\n    return multicast(new ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);\n  };\n}","map":{"version":3,"mappings":"AACA,SAASA,aAAa,QAAQ,kBAAkB;AAChD,SAASC,SAAS,QAAQ,aAAa;AAEvC,SAASC,UAAU,QAAQ,oBAAoB;AA8E/C,OAAM,SAAUC,aAAa,CAC3BC,UAAmB,EACnBC,UAAmB,EACnBC,mBAAgE,EAChEC,iBAAqC;EAErC,IAAID,mBAAmB,IAAI,CAACJ,UAAU,CAACI,mBAAmB,CAAC,EAAE;IAC3DC,iBAAiB,GAAGD,mBAAmB;;EAEzC,IAAME,QAAQ,GAAGN,UAAU,CAACI,mBAAmB,CAAC,GAAGA,mBAAmB,GAAGG,SAAS;EAGlF,OAAO,UAACC,MAAqB;IAAK,gBAAS,CAAC,IAAIV,aAAa,CAAII,UAAU,EAAEC,UAAU,EAAEE,iBAAiB,CAAC,EAAEC,QAAS,CAAC,CAACE,MAAM,CAAC;EAA7F,CAA6F;AACjI","names":["ReplaySubject","multicast","isFunction","publishReplay","bufferSize","windowTime","selectorOrScheduler","timestampProvider","selector","undefined","source"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\publishReplay.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { ReplaySubject } from '../ReplaySubject';\r\nimport { multicast } from './multicast';\r\nimport { MonoTypeOperatorFunction, OperatorFunction, TimestampProvider, ObservableInput, ObservedValueOf } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/**\r\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\r\n * internally.\r\n *\r\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\r\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\r\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\r\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\r\n * {@link ReplaySubject} under the hood, use {@link connectable}.\r\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\r\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\r\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\r\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T>(\r\n  bufferSize?: number,\r\n  windowTime?: number,\r\n  timestampProvider?: TimestampProvider\r\n): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Creates an observable, that when subscribed to, will create a {@link ReplaySubject},\r\n * and pass an observable from it (using [asObservable](api/index/class/Subject#asObservable)) to\r\n * the `selector` function, which then returns an observable that is subscribed to before\r\n * \"connecting\" the source to the internal `ReplaySubject`.\r\n *\r\n * Since this is deprecated, for additional details see the documentation for {@link connect}.\r\n *\r\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\r\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\r\n * @param selector A function used to setup the multicast.\r\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\r\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\r\n * `source.pipe(publishReplay(size, window, selector, scheduler))` is equivalent to\r\n * `source.pipe(connect(selector, { connector: () => new ReplaySubject(size, window, scheduler) }))`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T, O extends ObservableInput<any>>(\r\n  bufferSize: number | undefined,\r\n  windowTime: number | undefined,\r\n  selector: (shared: Observable<T>) => O,\r\n  timestampProvider?: TimestampProvider\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\r\n * internally.\r\n *\r\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\r\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\r\n * @param selector Passing `undefined` here determines that this operator will return a {@link ConnectableObservable}.\r\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\r\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\r\n * {@link ReplaySubject} under the hood, use {@link connectable}.\r\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\r\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\r\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\r\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T, O extends ObservableInput<any>>(\r\n  bufferSize: number | undefined,\r\n  windowTime: number | undefined,\r\n  selector: undefined,\r\n  timestampProvider: TimestampProvider\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\r\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\r\n * behaviors.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T, R>(\r\n  bufferSize?: number,\r\n  windowTime?: number,\r\n  selectorOrScheduler?: TimestampProvider | OperatorFunction<T, R>,\r\n  timestampProvider?: TimestampProvider\r\n) {\r\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\r\n    timestampProvider = selectorOrScheduler;\r\n  }\r\n  const selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\r\n  // Note, we're passing `selector!` here, because at runtime, `undefined` is an acceptable argument\r\n  // but it makes our TypeScript signature for `multicast` unhappy (as it should, because it's gross).\r\n  return (source: Observable<T>) => multicast(new ReplaySubject<T>(bufferSize, windowTime, timestampProvider), selector!)(source);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}