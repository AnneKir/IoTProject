{"ast":null,"code":"import { EmptyError } from '../util/EmptyError';\nimport { SequenceError } from '../util/SequenceError';\nimport { NotFoundError } from '../util/NotFoundError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function single(predicate) {\n  return operate(function (source, subscriber) {\n    var hasValue = false;\n    var singleValue;\n    var seenValue = false;\n    var index = 0;\n    source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n      seenValue = true;\n      if (!predicate || predicate(value, index++, source)) {\n        hasValue && subscriber.error(new SequenceError('Too many matching values'));\n        hasValue = true;\n        singleValue = value;\n      }\n    }, function () {\n      if (hasValue) {\n        subscriber.next(singleValue);\n        subscriber.complete();\n      } else {\n        subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\n      }\n    }));\n  });\n}","map":{"version":3,"mappings":"AACA,SAASA,UAAU,QAAQ,oBAAoB;AAG/C,SAASC,aAAa,QAAQ,uBAAuB;AACrD,SAASC,aAAa,QAAQ,uBAAuB;AACrD,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,wBAAwB,QAAQ,sBAAsB;AAiF/D,OAAM,SAAUC,MAAM,CAAIC,SAAuE;EAC/F,OAAOH,OAAO,CAAC,UAACI,MAAM,EAAEC,UAAU;IAChC,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIC,WAAc;IAClB,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,KAAK,GAAG,CAAC;IACbL,MAAM,CAACM,SAAS,CACdT,wBAAwB,CACtBI,UAAU,EACV,UAACM,KAAK;MACJH,SAAS,GAAG,IAAI;MAChB,IAAI,CAACL,SAAS,IAAIA,SAAS,CAACQ,KAAK,EAAEF,KAAK,EAAE,EAAEL,MAAM,CAAC,EAAE;QACnDE,QAAQ,IAAID,UAAU,CAACO,KAAK,CAAC,IAAId,aAAa,CAAC,0BAA0B,CAAC,CAAC;QAC3EQ,QAAQ,GAAG,IAAI;QACfC,WAAW,GAAGI,KAAK;;IAEvB,CAAC,EACD;MACE,IAAIL,QAAQ,EAAE;QACZD,UAAU,CAACQ,IAAI,CAACN,WAAW,CAAC;QAC5BF,UAAU,CAACS,QAAQ,EAAE;OACtB,MAAM;QACLT,UAAU,CAACO,KAAK,CAACJ,SAAS,GAAG,IAAIT,aAAa,CAAC,oBAAoB,CAAC,GAAG,IAAIF,UAAU,EAAE,CAAC;;IAE5F,CAAC,CACF,CACF;EACH,CAAC,CAAC;AACJ","names":["EmptyError","SequenceError","NotFoundError","operate","createOperatorSubscriber","single","predicate","source","subscriber","hasValue","singleValue","seenValue","index","subscribe","value","error","next","complete"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\single.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { EmptyError } from '../util/EmptyError';\r\n\r\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\r\nimport { SequenceError } from '../util/SequenceError';\r\nimport { NotFoundError } from '../util/NotFoundError';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an observable that asserts that only one value is\r\n * emitted from the observable that matches the predicate. If no\r\n * predicate is provided, then it will assert that the observable\r\n * only emits one value.\r\n *\r\n * In the event that the observable is empty, it will throw an\r\n * {@link EmptyError}.\r\n *\r\n * In the event that two values are found that match the predicate,\r\n * or when there are two values emitted and no predicate, it will\r\n * throw a {@link SequenceError}\r\n *\r\n * In the event that no values match the predicate, if one is provided,\r\n * it will throw a {@link NotFoundError}\r\n *\r\n * ## Example\r\n *\r\n * Expect only `name` beginning with `'B'`\r\n *\r\n * ```ts\r\n * import { of, single } from 'rxjs';\r\n *\r\n * const source1 = of(\r\n *  { name: 'Ben' },\r\n *  { name: 'Tracy' },\r\n *  { name: 'Laney' },\r\n *  { name: 'Lily' }\r\n * );\r\n *\r\n * source1\r\n *   .pipe(single(x => x.name.startsWith('B')))\r\n *   .subscribe(x => console.log(x));\r\n * // Emits 'Ben'\r\n *\r\n *\r\n * const source2 = of(\r\n *  { name: 'Ben' },\r\n *  { name: 'Tracy' },\r\n *  { name: 'Bradley' },\r\n *  { name: 'Lincoln' }\r\n * );\r\n *\r\n * source2\r\n *   .pipe(single(x => x.name.startsWith('B')))\r\n *   .subscribe({ error: err => console.error(err) });\r\n * // Error emitted: SequenceError('Too many values match')\r\n *\r\n *\r\n * const source3 = of(\r\n *  { name: 'Laney' },\r\n *  { name: 'Tracy' },\r\n *  { name: 'Lily' },\r\n *  { name: 'Lincoln' }\r\n * );\r\n *\r\n * source3\r\n *   .pipe(single(x => x.name.startsWith('B')))\r\n *   .subscribe({ error: err => console.error(err) });\r\n * // Error emitted: NotFoundError('No values match')\r\n * ```\r\n *\r\n * @see {@link first}\r\n * @see {@link find}\r\n * @see {@link findIndex}\r\n * @see {@link elementAt}\r\n *\r\n * @throws {NotFoundError} Delivers an NotFoundError to the Observer's `error`\r\n * callback if the Observable completes before any `next` notification was sent.\r\n * @throws {SequenceError} Delivers a SequenceError if more than one value is emitted that matches the\r\n * provided predicate. If no predicate is provided, will deliver a SequenceError if more\r\n * than one value comes from the source\r\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\r\n * @return A function that returns an Observable that emits the single item\r\n * emitted by the source Observable that matches the predicate.\r\n */\r\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    let singleValue: T;\r\n    let seenValue = false;\r\n    let index = 0;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          seenValue = true;\r\n          if (!predicate || predicate(value, index++, source)) {\r\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\r\n            hasValue = true;\r\n            singleValue = value;\r\n          }\r\n        },\r\n        () => {\r\n          if (hasValue) {\r\n            subscriber.next(singleValue);\r\n            subscriber.complete();\r\n          } else {\r\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\r\n          }\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}