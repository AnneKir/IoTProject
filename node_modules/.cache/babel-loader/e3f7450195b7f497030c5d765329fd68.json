{"ast":null,"code":"import { bindCallbackInternals } from './bindCallbackInternals';\nexport function bindCallback(callbackFunc, resultSelector, scheduler) {\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}","map":{"version":3,"mappings":"AAGA,SAASA,qBAAqB,QAAQ,yBAAyB;AAuI/D,OAAM,SAAUC,YAAY,CAC1BC,YAAkE,EAClEC,cAA0D,EAC1DC,SAAyB;EAEzB,OAAOJ,qBAAqB,CAAC,KAAK,EAAEE,YAAY,EAAEC,cAAc,EAAEC,SAAS,CAAC;AAC9E","names":["bindCallbackInternals","bindCallback","callbackFunc","resultSelector","scheduler"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\bindCallback.ts"],"sourcesContent":["/* @prettier */\r\nimport { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a callback API to a function that returns an Observable.\r\n *\r\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\r\n * it will return a function `g` that when called as `g(x)` will output an\r\n * Observable.</span>\r\n *\r\n * `bindCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters. The\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done.\r\n *\r\n * The output of `bindCallback` is a function that takes the same parameters\r\n * as `func`, except the last one (the callback). When the output function\r\n * is called with arguments it will return an Observable. If function `func`\r\n * calls its callback with one argument, the Observable will emit that value.\r\n * If on the other hand the callback is called with multiple values the resulting\r\n * Observable will emit an array with said values as arguments.\r\n *\r\n * It is **very important** to remember that input function `func` is not called\r\n * when the output function is, but rather when the Observable returned by the output\r\n * function is subscribed. This means if `func` makes an AJAX request, that request\r\n * will be made every time someone subscribes to the resulting Observable, but not before.\r\n *\r\n * The last optional parameter - `scheduler` - can be used to control when the call\r\n * to `func` happens after someone subscribes to Observable, as well as when results\r\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\r\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\r\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\r\n * and call `subscribe` on the output Observable, all function calls that are currently executing\r\n * will end before `func` is invoked.\r\n *\r\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\r\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\r\n * will call the `next` function synchronously as well.  If you want to defer that call,\r\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\r\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\r\n *\r\n * Note that the Observable created by the output function will always emit a single value\r\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\r\n * calls will not appear in the stream. If you need to listen for multiple calls,\r\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\r\n *\r\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\r\n * will be the context that the output function has at call time. In particular, if `func`\r\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\r\n * it is recommended that the context of the output function is set to that object as well.\r\n *\r\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\r\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\r\n * provides convenient error handling and probably is a better choice.\r\n * `bindCallback` will treat such functions the same as any other and error parameters\r\n * (whether passed or not) will always be interpreted as regular callback argument.\r\n *\r\n * ## Examples\r\n *\r\n * ### Convert jQuery's getJSON to an Observable API\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n * import * as jQuery from 'jquery';\r\n *\r\n * // Suppose we have jQuery.getJSON('/my/url', callback)\r\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\r\n * const result = getJSONAsObservable('/my/url');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * ### Receive an array of arguments passed to a callback\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n *\r\n * const someFunction = (cb) => {\r\n *   cb(5, 'some string', {someProperty: 'someValue'})\r\n * };\r\n *\r\n * const boundSomeFunction = bindCallback(someFunction);\r\n * boundSomeFunction(12, 10).subscribe(values => {\r\n *   console.log(values); // [22, 2]\r\n * });\r\n * ```\r\n *\r\n * ### Compare behaviour with and without async Scheduler\r\n * ```ts\r\n * import { bindCallback, asyncScheduler } from 'rxjs';\r\n *\r\n * function iCallMyCallbackSynchronously(cb) {\r\n *   cb();\r\n * }\r\n *\r\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\r\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\r\n *\r\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\r\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\r\n * console.log('This happened...');\r\n *\r\n * // Logs:\r\n * // I was sync!\r\n * // This happened...\r\n * // I was async!\r\n * ```\r\n *\r\n * ### Use bindCallback on an object method\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n *\r\n * const boundMethod = bindCallback(someObject.methodWithCallback);\r\n * boundMethod\r\n *   .call(someObject) // make sure methodWithCallback has access to someObject\r\n *   .subscribe(subscriber);\r\n * ```\r\n *\r\n * @see {@link bindNodeCallback}\r\n * @see {@link from}\r\n *\r\n * @param {function} func A function with a callback as the last parameter.\r\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\r\n * callbacks.\r\n * @return {function(...params: *): Observable} A function which returns the\r\n * Observable that delivers the same values the callback would deliver.\r\n */\r\nexport function bindCallback(\r\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<unknown> {\r\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}