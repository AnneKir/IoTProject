{"ast":null,"code":"import { asyncScheduler } from '../scheduler/async';\nimport { sample } from './sample';\nimport { interval } from '../observable/interval';\nexport function sampleTime(period, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = asyncScheduler;\n  }\n  return sample(interval(period, scheduler));\n}","map":{"version":3,"mappings":"AAAA,SAASA,cAAc,QAAQ,oBAAoB;AAEnD,SAASC,MAAM,QAAQ,UAAU;AACjC,SAASC,QAAQ,QAAQ,wBAAwB;AA6CjD,OAAM,SAAUC,UAAU,CAAIC,MAAc,EAAEC,SAAyC;EAAzC;IAAAA,0BAAyC;EAAA;EACrF,OAAOJ,MAAM,CAACC,QAAQ,CAACE,MAAM,EAAEC,SAAS,CAAC,CAAC;AAC5C","names":["asyncScheduler","sample","interval","sampleTime","period","scheduler"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\sampleTime.ts"],"sourcesContent":["import { asyncScheduler } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { sample } from './sample';\r\nimport { interval } from '../observable/interval';\r\n\r\n/**\r\n * Emits the most recently emitted value from the source Observable within\r\n * periodic time intervals.\r\n *\r\n * <span class=\"informal\">Samples the source Observable at periodic time\r\n * intervals, emitting what it samples.</span>\r\n *\r\n * ![](sampleTime.png)\r\n *\r\n * `sampleTime` periodically looks at the source Observable and emits whichever\r\n * value it has most recently emitted since the previous sampling, unless the\r\n * source has not emitted anything since the previous sampling. The sampling\r\n * happens periodically in time every `period` milliseconds (or the time unit\r\n * defined by the optional `scheduler` argument). The sampling starts as soon as\r\n * the output Observable is subscribed.\r\n *\r\n * ## Example\r\n *\r\n * Every second, emit the most recent click at most once\r\n *\r\n * ```ts\r\n * import { fromEvent, sampleTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(sampleTime(1000));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sample}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} period The sampling period expressed in milliseconds or the\r\n * time unit determined internally by the optional `scheduler`.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\r\n * managing the timers that handle the sampling.\r\n * @return A function that returns an Observable that emits the results of\r\n * sampling the values emitted by the source Observable at the specified time\r\n * interval.\r\n */\r\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  return sample(interval(period, scheduler));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}