{"ast":null,"code":"import { async } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { timeout } from './timeout';\nexport function timeoutWith(due, withObservable, scheduler) {\n  var first;\n  var each;\n  var _with;\n  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;\n  if (isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n  if (withObservable) {\n    _with = function _with() {\n      return withObservable;\n    };\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n  if (first == null && each == null) {\n    throw new TypeError('No timeout provided.');\n  }\n  return timeout({\n    first: first,\n    each: each,\n    scheduler: scheduler,\n    with: _with\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,KAAK,QAAQ,oBAAoB;AAC1C,SAASC,WAAW,QAAQ,gBAAgB;AAE5C,SAASC,OAAO,QAAQ,WAAW;AA+EnC,OAAM,SAAUC,WAAW,CACzBC,GAAkB,EAClBC,cAAkC,EAClCC,SAAyB;EAEzB,IAAIC,KAAgC;EACpC,IAAIC,IAAwB;EAC5B,IAAIC,KAA+B;EACnCH,SAAS,GAAGA,SAAS,aAATA,SAAS,cAATA,SAAS,GAAIN,KAAK;EAE9B,IAAIC,WAAW,CAACG,GAAG,CAAC,EAAE;IACpBG,KAAK,GAAGH,GAAG;GACZ,MAAM,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAClCI,IAAI,GAAGJ,GAAG;;EAGZ,IAAIC,cAAc,EAAE;IAClBI,KAAK,GAAG;MAAM,qBAAc;IAAd,CAAc;GAC7B,MAAM;IACL,MAAM,IAAIC,SAAS,CAAC,qCAAqC,CAAC;;EAG5D,IAAIH,KAAK,IAAI,IAAI,IAAIC,IAAI,IAAI,IAAI,EAAE;IAEjC,MAAM,IAAIE,SAAS,CAAC,sBAAsB,CAAC;;EAG7C,OAAOR,OAAO,CAAwB;IACpCK,KAAK;IACLC,IAAI;IACJF,SAAS;IACTK,IAAI,EAAEF;GACP,CAAC;AACJ","names":["async","isValidDate","timeout","timeoutWith","due","withObservable","scheduler","first","each","_with","TypeError","with"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\operators\\timeoutWith.ts"],"sourcesContent":["import { async } from '../scheduler/async';\r\nimport { isValidDate } from '../util/isDate';\r\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\r\nimport { timeout } from './timeout';\r\n\r\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\r\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\r\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\r\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\r\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\r\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\r\n\r\n/**\r\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\r\n * and switch the subscription to another observable.\r\n *\r\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\r\n *\r\n * Useful in cases where:\r\n *\r\n * - You want to switch to a different source that may be faster.\r\n * - You want to notify a user that the data stream is slow.\r\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\r\n *   by the default usage of {@link timeout}.\r\n *\r\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\r\n * it will unsubscribe from the source and switch the subscription to another observable.\r\n *\r\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\r\n *\r\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\r\n * the `first` configuration to get the same effect.\r\n *\r\n * ## Examples\r\n *\r\n * Fallback to a faster observable\r\n *\r\n * ```ts\r\n * import { interval, timeoutWith } from 'rxjs';\r\n *\r\n * const slow$ = interval(1000);\r\n * const faster$ = interval(500);\r\n *\r\n * slow$\r\n *   .pipe(timeoutWith(900, faster$))\r\n *   .subscribe(console.log);\r\n * ```\r\n *\r\n * Emit your own custom timeout error\r\n *\r\n * ```ts\r\n * import { interval, timeoutWith, throwError } from 'rxjs';\r\n *\r\n * class CustomTimeoutError extends Error {\r\n *   constructor() {\r\n *     super('It was too slow');\r\n *     this.name = 'CustomTimeoutError';\r\n *   }\r\n * }\r\n *\r\n * const slow$ = interval(1000);\r\n *\r\n * slow$\r\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\r\n *   .subscribe({\r\n *     error: err => console.error(err.message)\r\n *   });\r\n * ```\r\n *\r\n * @see {@link timeout}\r\n *\r\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\r\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\r\n * @param withObservable The observable to switch to when timeout occurs.\r\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\r\n * @return A function that returns an Observable that mirrors behaviour of the\r\n * source Observable, unless timeout happens when it starts emitting values\r\n * from the `ObservableInput` passed as a second parameter.\r\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\r\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\r\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\r\n */\r\nexport function timeoutWith<T, R>(\r\n  due: number | Date,\r\n  withObservable: ObservableInput<R>,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, T | R> {\r\n  let first: number | Date | undefined;\r\n  let each: number | undefined;\r\n  let _with: () => ObservableInput<R>;\r\n  scheduler = scheduler ?? async;\r\n\r\n  if (isValidDate(due)) {\r\n    first = due;\r\n  } else if (typeof due === 'number') {\r\n    each = due;\r\n  }\r\n\r\n  if (withObservable) {\r\n    _with = () => withObservable;\r\n  } else {\r\n    throw new TypeError('No observable provided to switch to');\r\n  }\r\n\r\n  if (first == null && each == null) {\r\n    // Ensure timeout was provided at runtime.\r\n    throw new TypeError('No timeout provided.');\r\n  }\r\n\r\n  return timeout<T, ObservableInput<R>>({\r\n    first,\r\n    each,\r\n    scheduler,\r\n    with: _with,\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}