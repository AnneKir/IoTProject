{"ast":null,"code":"const bl = require('bl');\nconst EventEmitter = require('events');\nconst Packet = require('./packet');\nconst constants = require('./constants');\nconst debug = require('debug')('mqtt-packet:parser');\nclass Parser extends EventEmitter {\n  constructor() {\n    super();\n    this.parser = this.constructor.parser;\n  }\n  static parser(opt) {\n    if (!(this instanceof Parser)) return new Parser().parser(opt);\n    this.settings = opt || {};\n    this._states = ['_parseHeader', '_parseLength', '_parsePayload', '_newPacket'];\n    this._resetState();\n    return this;\n  }\n  _resetState() {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter');\n    this.packet = new Packet();\n    this.error = null;\n    this._list = bl();\n    this._stateCounter = 0;\n  }\n  parse(buf) {\n    if (this.error) this._resetState();\n    this._list.append(buf);\n    debug('parse: current state: %s', this._states[this._stateCounter]);\n    while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {\n      this._stateCounter++;\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter);\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length);\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length);\n    return this._list.length;\n  }\n  _parseHeader() {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0);\n    this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n    this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n    debug('_parseHeader: packet: %o', this.packet);\n    this._list.consume(1);\n    return true;\n  }\n  _parseLength() {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true);\n    if (result) {\n      this.packet.length = result.value;\n      this._list.consume(result.bytes);\n    }\n    debug('_parseLength %d', result.value);\n    return !!result;\n  }\n  _parsePayload() {\n    debug('_parsePayload: payload %O', this._list);\n    let result = false;\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0;\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect();\n          break;\n        case 'connack':\n          this._parseConnack();\n          break;\n        case 'publish':\n          this._parsePublish();\n          break;\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation();\n          break;\n        case 'subscribe':\n          this._parseSubscribe();\n          break;\n        case 'suback':\n          this._parseSuback();\n          break;\n        case 'unsubscribe':\n          this._parseUnsubscribe();\n          break;\n        case 'unsuback':\n          this._parseUnsuback();\n          break;\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break;\n        case 'disconnect':\n          this._parseDisconnect();\n          break;\n        case 'auth':\n          this._parseAuth();\n          break;\n        default:\n          this._emitError(new Error('Not supported'));\n      }\n      result = true;\n    }\n    debug('_parsePayload complete result: %s', result);\n    return result;\n  }\n  _parseConnect() {\n    debug('_parseConnect');\n    let topic; // Will topic\n    let payload; // Will payload\n    let password; // Password\n    let username; // Username\n    const flags = {};\n    const packet = this.packet;\n\n    // Parse protocolId\n    const protocolId = this._parseString();\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'));\n    }\n    packet.protocolId = protocolId;\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n    packet.protocolVersion = this._list.readUInt8(this._pos);\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true;\n      packet.protocolVersion = packet.protocolVersion - 128;\n    }\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'));\n    }\n    this._pos++;\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'));\n    }\n\n    // Parse connect flags\n    flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n    flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n    flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n    if (flags.will) {\n      packet.will = {};\n      packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n      packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n    }\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n    this._pos++;\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum();\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'));\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString();\n    if (clientId === null) return this._emitError(new Error('Packet too short'));\n    packet.clientId = clientId;\n    debug('_parseConnect: packet.clientId: %s', packet.clientId);\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties();\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties;\n        }\n      }\n      // Parse will topic\n      topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n      packet.will.topic = topic;\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic);\n\n      // Parse will payload\n      payload = this._parseBuffer();\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n      packet.will.payload = payload;\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload);\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString();\n      if (username === null) return this._emitError(new Error('Cannot parse username'));\n      packet.username = username;\n      debug('_parseConnect: packet.username: %s', packet.username);\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer();\n      if (password === null) return this._emitError(new Error('Cannot parse password'));\n      packet.password = password;\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet;\n    debug('_parseConnect: complete');\n    return packet;\n  }\n  _parseConnack() {\n    debug('_parseConnack');\n    const packet = this.packet;\n    if (this._list.length < 1) return null;\n    packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++);\n      } else {\n        packet.reasonCode = 0;\n      }\n    } else {\n      if (this._list.length < 2) return null;\n      packet.returnCode = this._list.readUInt8(this._pos++);\n    }\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'));\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    debug('_parseConnack: complete');\n  }\n  _parsePublish() {\n    debug('_parsePublish');\n    const packet = this.packet;\n    packet.topic = this._parseString();\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    packet.payload = this._list.slice(this._pos, packet.length);\n    debug('_parsePublish: payload from buffer list: %o', packet.payload);\n  }\n  _parseSubscribe() {\n    debug('_parseSubscribe');\n    const packet = this.packet;\n    let topic;\n    let options;\n    let qos;\n    let rh;\n    let rap;\n    let nl;\n    let subscription;\n    if (packet.qos !== 1) {\n      return this._emitError(new Error('Wrong subscribe header'));\n    }\n    packet.subscriptions = [];\n    if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'));\n      options = this._parseByte();\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n      nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n      rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n      rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n      subscription = {\n        topic,\n        qos\n      };\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl;\n        subscription.rap = rap;\n        subscription.rh = rh;\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0;\n        subscription.rap = true;\n        subscription.nl = true;\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription);\n      packet.subscriptions.push(subscription);\n    }\n  }\n  _parseSuback() {\n    debug('_parseSuback');\n    const packet = this.packet;\n    this.packet.granted = [];\n    if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      this.packet.granted.push(this._list.readUInt8(this._pos++));\n    }\n  }\n  _parseUnsubscribe() {\n    debug('_parseUnsubscribe');\n    const packet = this.packet;\n    packet.unsubscriptions = [];\n\n    // Parse messageId\n    if (!this._parseMessageId()) {\n      return;\n    }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic);\n      packet.unsubscriptions.push(topic);\n    }\n  }\n  _parseUnsuback() {\n    debug('_parseUnsuback');\n    const packet = this.packet;\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'));\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n      // Parse granted QoSes\n      packet.granted = [];\n      while (this._pos < this.packet.length) {\n        this.packet.granted.push(this._list.readUInt8(this._pos++));\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation() {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd);\n    const packet = this.packet;\n    this._parseMessageId();\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte();\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode);\n      } else {\n        packet.reasonCode = 0;\n      }\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties();\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties;\n        }\n      }\n    }\n    return true;\n  }\n\n  // parse disconnect packet\n  _parseDisconnect() {\n    const packet = this.packet;\n    debug('_parseDisconnect');\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte();\n      } else {\n        packet.reasonCode = 0;\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties();\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n    debug('_parseDisconnect result: true');\n    return true;\n  }\n\n  // parse auth packet\n  _parseAuth() {\n    debug('_parseAuth');\n    const packet = this.packet;\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte();\n    // properies mqtt 5\n    const properties = this._parseProperties();\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties;\n    }\n    debug('_parseAuth: result: true');\n    return true;\n  }\n  _parseMessageId() {\n    const packet = this.packet;\n    packet.messageId = this._parseNum();\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'));\n      return false;\n    }\n    debug('_parseMessageId: packet.messageId %d', packet.messageId);\n    return true;\n  }\n  _parseString(maybeBuffer) {\n    const length = this._parseNum();\n    const end = length + this._pos;\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n    const result = this._list.toString('utf8', this._pos, end);\n    this._pos += length;\n    debug('_parseString: result: %s', result);\n    return result;\n  }\n  _parseStringPair() {\n    debug('_parseStringPair');\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    };\n  }\n  _parseBuffer() {\n    const length = this._parseNum();\n    const end = length + this._pos;\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n    const result = this._list.slice(this._pos, end);\n    this._pos += length;\n    debug('_parseBuffer: result: %o', result);\n    return result;\n  }\n  _parseNum() {\n    if (this._list.length - this._pos < 2) return -1;\n    const result = this._list.readUInt16BE(this._pos);\n    this._pos += 2;\n    debug('_parseNum: result: %s', result);\n    return result;\n  }\n  _parse4ByteNum() {\n    if (this._list.length - this._pos < 4) return -1;\n    const result = this._list.readUInt32BE(this._pos);\n    this._pos += 4;\n    debug('_parse4ByteNum: result: %s', result);\n    return result;\n  }\n  _parseVarByteNum(fullInfoFlag) {\n    debug('_parseVarByteNum');\n    const maxBytes = 4;\n    let bytes = 0;\n    let mul = 1;\n    let value = 0;\n    let result = false;\n    let current;\n    const padding = this._pos ? this._pos : 0;\n    while (bytes < maxBytes && padding + bytes < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++);\n      value += mul * (current & constants.VARBYTEINT_MASK);\n      mul *= 0x80;\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true;\n        break;\n      }\n      if (this._list.length <= bytes) {\n        break;\n      }\n    }\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'));\n    }\n    if (padding) {\n      this._pos += bytes;\n    }\n    result = result ? fullInfoFlag ? {\n      bytes,\n      value\n    } : value : false;\n    debug('_parseVarByteNum: result: %o', result);\n    return result;\n  }\n  _parseByte() {\n    let result;\n    if (this._pos < this._list.length) {\n      result = this._list.readUInt8(this._pos);\n      this._pos++;\n    }\n    debug('_parseByte: result: %o', result);\n    return result;\n  }\n  _parseByType(type) {\n    debug('_parseByType: type: %s', type);\n    switch (type) {\n      case 'byte':\n        {\n          return this._parseByte() !== 0;\n        }\n      case 'int8':\n        {\n          return this._parseByte();\n        }\n      case 'int16':\n        {\n          return this._parseNum();\n        }\n      case 'int32':\n        {\n          return this._parse4ByteNum();\n        }\n      case 'var':\n        {\n          return this._parseVarByteNum();\n        }\n      case 'string':\n        {\n          return this._parseString();\n        }\n      case 'pair':\n        {\n          return this._parseStringPair();\n        }\n      case 'binary':\n        {\n          return this._parseBuffer();\n        }\n    }\n  }\n  _parseProperties() {\n    debug('_parseProperties');\n    const length = this._parseVarByteNum();\n    const start = this._pos;\n    const end = start + length;\n    const result = {};\n    while (this._pos < end) {\n      const type = this._parseByte();\n      if (!type) {\n        this._emitError(new Error('Cannot parse property code type'));\n        return false;\n      }\n      const name = constants.propertiesCodes[type];\n      if (!name) {\n        this._emitError(new Error('Unknown property'));\n        return false;\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null);\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value);\n          } else {\n            const currentValue = result[name][currentUserProperty.name];\n            result[name][currentUserProperty.name] = [currentValue];\n            result[name][currentUserProperty.name].push(currentUserProperty.value);\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value;\n        }\n        continue;\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]));\n        } else {\n          result[name] = [result[name]];\n          result[name].push(this._parseByType(constants.propertiesTypes[name]));\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name]);\n      }\n    }\n    return result;\n  }\n  _newPacket() {\n    debug('_newPacket');\n    if (this.packet) {\n      this._list.consume(this.packet.length);\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length);\n      this.emit('packet', this.packet);\n    }\n    debug('_newPacket: new packet');\n    this.packet = new Packet();\n    this._pos = 0;\n    return true;\n  }\n  _emitError(err) {\n    debug('_emitError');\n    this.error = err;\n    this.emit('error', err);\n  }\n}\nmodule.exports = Parser;","map":{"version":3,"names":["bl","require","EventEmitter","Packet","constants","debug","Parser","constructor","parser","opt","settings","_states","_resetState","packet","error","_list","_stateCounter","parse","buf","append","length","_parseHeader","zero","readUInt8","cmd","types","CMD_SHIFT","retain","RETAIN_MASK","qos","QOS_SHIFT","QOS_MASK","dup","DUP_MASK","consume","_parseLength","result","_parseVarByteNum","value","bytes","_parsePayload","_pos","_parseConnect","_parseConnack","_parsePublish","_parseConfirmation","_parseSubscribe","_parseSuback","_parseUnsubscribe","_parseUnsuback","_parseDisconnect","_parseAuth","_emitError","Error","topic","payload","password","username","flags","protocolId","_parseString","protocolVersion","bridgeMode","USERNAME_MASK","PASSWORD_MASK","will","WILL_FLAG_MASK","WILL_RETAIN_MASK","WILL_QOS_MASK","WILL_QOS_SHIFT","clean","CLEAN_SESSION_MASK","keepalive","_parseNum","properties","_parseProperties","Object","getOwnPropertyNames","clientId","willProperties","_parseBuffer","sessionPresent","SESSIONPRESENT_MASK","reasonCode","returnCode","_parseMessageId","slice","options","rh","rap","nl","subscription","subscriptions","_parseByte","SUBSCRIBE_OPTIONS_QOS_MASK","SUBSCRIBE_OPTIONS_NL_SHIFT","SUBSCRIBE_OPTIONS_NL_MASK","SUBSCRIBE_OPTIONS_RAP_SHIFT","SUBSCRIBE_OPTIONS_RAP_MASK","SUBSCRIBE_OPTIONS_RH_SHIFT","SUBSCRIBE_OPTIONS_RH_MASK","push","granted","unsubscriptions","messageId","maybeBuffer","end","toString","_parseStringPair","name","readUInt16BE","_parse4ByteNum","readUInt32BE","fullInfoFlag","maxBytes","mul","current","padding","VARBYTEINT_MASK","VARBYTEINT_FIN_MASK","_parseByType","type","start","propertiesCodes","create","currentUserProperty","propertiesTypes","Array","isArray","currentValue","_newPacket","emit","err","module","exports"],"sources":["C:/Users/Amali/Desktop/Building_the_IoT_w._P2P_and_Cloud_Computing/IoTProject/node_modules/mqtt-packet/parser.js"],"sourcesContent":["const bl = require('bl')\nconst EventEmitter = require('events')\nconst Packet = require('./packet')\nconst constants = require('./constants')\nconst debug = require('debug')('mqtt-packet:parser')\n\nclass Parser extends EventEmitter {\n  constructor () {\n    super()\n    this.parser = this.constructor.parser\n  }\n\n  static parser (opt) {\n    if (!(this instanceof Parser)) return (new Parser()).parser(opt)\n\n    this.settings = opt || {}\n\n    this._states = [\n      '_parseHeader',\n      '_parseLength',\n      '_parsePayload',\n      '_newPacket'\n    ]\n\n    this._resetState()\n    return this\n  }\n\n  _resetState () {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter')\n    this.packet = new Packet()\n    this.error = null\n    this._list = bl()\n    this._stateCounter = 0\n  }\n\n  parse (buf) {\n    if (this.error) this._resetState()\n\n    this._list.append(buf)\n    debug('parse: current state: %s', this._states[this._stateCounter])\n    while ((this.packet.length !== -1 || this._list.length > 0) &&\n      this[this._states[this._stateCounter]]() &&\n      !this.error) {\n      this._stateCounter++\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)\n    return this._list.length\n  }\n\n  _parseHeader () {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0)\n    this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0\n    debug('_parseHeader: packet: %o', this.packet)\n\n    this._list.consume(1)\n\n    return true\n  }\n\n  _parseLength () {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true)\n\n    if (result) {\n      this.packet.length = result.value\n      this._list.consume(result.bytes)\n    }\n    debug('_parseLength %d', result.value)\n    return !!result\n  }\n\n  _parsePayload () {\n    debug('_parsePayload: payload %O', this._list)\n    let result = false\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0\n\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect()\n          break\n        case 'connack':\n          this._parseConnack()\n          break\n        case 'publish':\n          this._parsePublish()\n          break\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation()\n          break\n        case 'subscribe':\n          this._parseSubscribe()\n          break\n        case 'suback':\n          this._parseSuback()\n          break\n        case 'unsubscribe':\n          this._parseUnsubscribe()\n          break\n        case 'unsuback':\n          this._parseUnsuback()\n          break\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break\n        case 'disconnect':\n          this._parseDisconnect()\n          break\n        case 'auth':\n          this._parseAuth()\n          break\n        default:\n          this._emitError(new Error('Not supported'))\n      }\n\n      result = true\n    }\n    debug('_parsePayload complete result: %s', result)\n    return result\n  }\n\n  _parseConnect () {\n    debug('_parseConnect')\n    let topic // Will topic\n    let payload // Will payload\n    let password // Password\n    let username // Username\n    const flags = {}\n    const packet = this.packet\n\n    // Parse protocolId\n    const protocolId = this._parseString()\n\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'))\n    }\n\n    packet.protocolId = protocolId\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n    packet.protocolVersion = this._list.readUInt8(this._pos)\n\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true\n      packet.protocolVersion = packet.protocolVersion - 128\n    }\n\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'))\n    }\n\n    this._pos++\n\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'))\n    }\n\n    // Parse connect flags\n    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n    if (flags.will) {\n      packet.will = {}\n      packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0\n      packet.will.qos = (this._list.readUInt8(this._pos) &\n        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n    }\n\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n    this._pos++\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum()\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString()\n    if (clientId === null) return this._emitError(new Error('Packet too short'))\n    packet.clientId = clientId\n    debug('_parseConnect: packet.clientId: %s', packet.clientId)\n\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties()\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties\n        }\n      }\n      // Parse will topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n      packet.will.topic = topic\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)\n\n      // Parse will payload\n      payload = this._parseBuffer()\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n      packet.will.payload = payload\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString()\n      if (username === null) return this._emitError(new Error('Cannot parse username'))\n      packet.username = username\n      debug('_parseConnect: packet.username: %s', packet.username)\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer()\n      if (password === null) return this._emitError(new Error('Cannot parse password'))\n      packet.password = password\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet\n    debug('_parseConnect: complete')\n    return packet\n  }\n\n  _parseConnack () {\n    debug('_parseConnack')\n    const packet = this.packet\n\n    if (this._list.length < 1) return null\n    packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)\n\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++)\n      } else {\n        packet.reasonCode = 0\n      }\n    } else {\n      if (this._list.length < 2) return null\n      packet.returnCode = this._list.readUInt8(this._pos++)\n    }\n\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    debug('_parseConnack: complete')\n  }\n\n  _parsePublish () {\n    debug('_parsePublish')\n    const packet = this.packet\n    packet.topic = this._parseString()\n\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    packet.payload = this._list.slice(this._pos, packet.length)\n    debug('_parsePublish: payload from buffer list: %o', packet.payload)\n  }\n\n  _parseSubscribe () {\n    debug('_parseSubscribe')\n    const packet = this.packet\n    let topic\n    let options\n    let qos\n    let rh\n    let rap\n    let nl\n    let subscription\n\n    if (packet.qos !== 1) {\n      return this._emitError(new Error('Wrong subscribe header'))\n    }\n\n    packet.subscriptions = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n\n      options = this._parseByte()\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK\n      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0\n      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0\n      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK\n\n      subscription = { topic, qos }\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl\n        subscription.rap = rap\n        subscription.rh = rh\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0\n        subscription.rap = true\n        subscription.nl = true\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)\n      packet.subscriptions.push(subscription)\n    }\n  }\n\n  _parseSuback () {\n    debug('_parseSuback')\n    const packet = this.packet\n    this.packet.granted = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      this.packet.granted.push(this._list.readUInt8(this._pos++))\n    }\n  }\n\n  _parseUnsubscribe () {\n    debug('_parseUnsubscribe')\n    const packet = this.packet\n\n    packet.unsubscriptions = []\n\n    // Parse messageId\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)\n      packet.unsubscriptions.push(topic)\n    }\n  }\n\n  _parseUnsuback () {\n    debug('_parseUnsuback')\n    const packet = this.packet\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n      // Parse granted QoSes\n      packet.granted = []\n      while (this._pos < this.packet.length) {\n        this.packet.granted.push(this._list.readUInt8(this._pos++))\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation () {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)\n    const packet = this.packet\n\n    this._parseMessageId()\n\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte()\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)\n      } else {\n        packet.reasonCode = 0\n      }\n\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties()\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties\n        }\n      }\n    }\n\n    return true\n  }\n\n  // parse disconnect packet\n  _parseDisconnect () {\n    const packet = this.packet\n    debug('_parseDisconnect')\n\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte()\n      } else {\n        packet.reasonCode = 0\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    debug('_parseDisconnect result: true')\n    return true\n  }\n\n  // parse auth packet\n  _parseAuth () {\n    debug('_parseAuth')\n    const packet = this.packet\n\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'))\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte()\n    // properies mqtt 5\n    const properties = this._parseProperties()\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties\n    }\n\n    debug('_parseAuth: result: true')\n    return true\n  }\n\n  _parseMessageId () {\n    const packet = this.packet\n\n    packet.messageId = this._parseNum()\n\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'))\n      return false\n    }\n\n    debug('_parseMessageId: packet.messageId %d', packet.messageId)\n    return true\n  }\n\n  _parseString (maybeBuffer) {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.toString('utf8', this._pos, end)\n    this._pos += length\n    debug('_parseString: result: %s', result)\n    return result\n  }\n\n  _parseStringPair () {\n    debug('_parseStringPair')\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    }\n  }\n\n  _parseBuffer () {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.slice(this._pos, end)\n\n    this._pos += length\n    debug('_parseBuffer: result: %o', result)\n    return result\n  }\n\n  _parseNum () {\n    if (this._list.length - this._pos < 2) return -1\n\n    const result = this._list.readUInt16BE(this._pos)\n    this._pos += 2\n    debug('_parseNum: result: %s', result)\n    return result\n  }\n\n  _parse4ByteNum () {\n    if (this._list.length - this._pos < 4) return -1\n\n    const result = this._list.readUInt32BE(this._pos)\n    this._pos += 4\n    debug('_parse4ByteNum: result: %s', result)\n    return result\n  }\n\n  _parseVarByteNum (fullInfoFlag) {\n    debug('_parseVarByteNum')\n    const maxBytes = 4\n    let bytes = 0\n    let mul = 1\n    let value = 0\n    let result = false\n    let current\n    const padding = this._pos ? this._pos : 0\n\n    while (bytes < maxBytes && (padding + bytes) < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++)\n      value += mul * (current & constants.VARBYTEINT_MASK)\n      mul *= 0x80\n\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true\n        break\n      }\n      if (this._list.length <= bytes) {\n        break\n      }\n    }\n\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'))\n    }\n\n    if (padding) {\n      this._pos += bytes\n    }\n\n    result = result\n      ? fullInfoFlag ? {\n        bytes,\n        value\n      } : value\n      : false\n\n    debug('_parseVarByteNum: result: %o', result)\n    return result\n  }\n\n  _parseByte () {\n    let result\n    if (this._pos < this._list.length) {\n      result = this._list.readUInt8(this._pos)\n      this._pos++\n    }\n    debug('_parseByte: result: %o', result)\n    return result\n  }\n\n  _parseByType (type) {\n    debug('_parseByType: type: %s', type)\n    switch (type) {\n      case 'byte': {\n        return this._parseByte() !== 0\n      }\n      case 'int8': {\n        return this._parseByte()\n      }\n      case 'int16': {\n        return this._parseNum()\n      }\n      case 'int32': {\n        return this._parse4ByteNum()\n      }\n      case 'var': {\n        return this._parseVarByteNum()\n      }\n      case 'string': {\n        return this._parseString()\n      }\n      case 'pair': {\n        return this._parseStringPair()\n      }\n      case 'binary': {\n        return this._parseBuffer()\n      }\n    }\n  }\n\n  _parseProperties () {\n    debug('_parseProperties')\n    const length = this._parseVarByteNum()\n    const start = this._pos\n    const end = start + length\n    const result = {}\n    while (this._pos < end) {\n      const type = this._parseByte()\n      if (!type) {\n        this._emitError(new Error('Cannot parse property code type'))\n        return false\n      }\n      const name = constants.propertiesCodes[type]\n      if (!name) {\n        this._emitError(new Error('Unknown property'))\n        return false\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null)\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          } else {\n            const currentValue = result[name][currentUserProperty.name]\n            result[name][currentUserProperty.name] = [currentValue]\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value\n        }\n        continue\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        } else {\n          result[name] = [result[name]]\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name])\n      }\n    }\n    return result\n  }\n\n  _newPacket () {\n    debug('_newPacket')\n    if (this.packet) {\n      this._list.consume(this.packet.length)\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)\n      this.emit('packet', this.packet)\n    }\n    debug('_newPacket: new packet')\n    this.packet = new Packet()\n\n    this._pos = 0\n\n    return true\n  }\n\n  _emitError (err) {\n    debug('_emitError')\n    this.error = err\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = Parser\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}