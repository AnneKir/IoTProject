{"ast":null,"code":"// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n'use strict';\n\nconst SortedSet = require('js-sdsl').OrderedSet;\nconst debugTrace = require('debug')('number-allocator:trace');\nconst debugError = require('debug')('number-allocator:error');\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval(low, high) {\n  this.low = low;\n  this.high = high;\n}\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high;\n};\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1;\n  if (other.low < this.low && other.high < this.low) return 1;\n  return 0;\n};\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator(min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max);\n  }\n  this.min = min;\n  this.max = max;\n  this.ss = new SortedSet([], (lhs, rhs) => {\n    return lhs.compare(rhs);\n  });\n  debugTrace('Create');\n  this.clear();\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null;\n  return this.ss.front().low;\n};\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty');\n    return null;\n  }\n  const it = this.ss.begin();\n  const low = it.pointer.low;\n  const high = it.pointer.high;\n  const num = low;\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.updateKeyByIterator(it, new Interval(low + 1, high));\n  } else {\n    this.ss.eraseElementByPos(0);\n  }\n  debugTrace('alloc():' + num);\n  return num;\n};\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low;\n    const high = it.pointer.high;\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it);\n      debugTrace('use():' + num);\n      return true;\n    }\n\n    // x |-----|\n    if (low > num) return false;\n\n    // |x----|\n    if (low === num) {\n      // x|----|\n      this.ss.updateKeyByIterator(it, new Interval(low + 1, high));\n      debugTrace('use():' + num);\n      return true;\n    }\n\n    // |----x|\n    if (high === num) {\n      // |----|x\n      this.ss.updateKeyByIterator(it, new Interval(low, high - 1));\n      debugTrace('use():' + num);\n      return true;\n    }\n\n    // |--x--|\n    // x|--|\n    this.ss.updateKeyByIterator(it, new Interval(num + 1, high));\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1));\n    debugTrace('use():' + num);\n    return true;\n  }\n  debugTrace('use():failed');\n  return false;\n};\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range');\n    return;\n  }\n  const key = new Interval(num, num);\n  const it = this.ss.upperBound(key);\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key);\n      return;\n    }\n    it.pre();\n    const low = it.pointer.high;\n    const high = it.pointer.high;\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.updateKeyByIterator(it, new Interval(low, num));\n    } else {\n      // Insert new interval\n      this.ss.insert(key);\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const low = it.pointer.high - 1;\n        const high = it.pointer.high;\n        this.ss.updateKeyByIterator(it, new Interval(low, high));\n      } else {\n        // Insert new interval\n        this.ss.insert(key);\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low;\n      const rHigh = it.pointer.high;\n      it.pre();\n      const lLow = it.pointer.low;\n      const lHigh = it.pointer.high;\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it);\n          const high = it.pointer.high;\n          this.ss.updateKeyByIterator(it, new Interval(lLow, high));\n        } else {\n          // Concat to left\n          this.ss.updateKeyByIterator(it, new Interval(lLow, num));\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next());\n          this.ss.insert(new Interval(num, rHigh));\n        } else {\n          // Insert new interval\n          this.ss.insert(key);\n        }\n      }\n    }\n  }\n  debugTrace('free():' + num);\n};\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()');\n  this.ss.clear();\n  this.ss.insert(new Interval(this.min, this.max));\n};\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size();\n};\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size());\n  for (const element of this.ss) {\n    console.log(element);\n  }\n};\nmodule.exports = NumberAllocator;","map":{"version":3,"names":["SortedSet","require","OrderedSet","debugTrace","debugError","Interval","low","high","prototype","equals","other","compare","NumberAllocator","min","max","ss","lhs","rhs","clear","firstVacant","size","front","alloc","it","begin","pointer","num","updateKeyByIterator","eraseElementByPos","use","key","lowerBound","end","eraseElementByIterator","insert","free","upperBound","pre","rLow","rHigh","lLow","lHigh","next","intervalCount","dump","console","log","element","module","exports"],"sources":["C:/Users/Amali/Desktop/Building_the_IoT_w._P2P_and_Cloud_Computing/IoTProject/node_modules/number-allocator/lib/number-allocator.js"],"sourcesContent":["// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n'use strict'\n\nconst SortedSet = require('js-sdsl').OrderedSet\nconst debugTrace = require('debug')('number-allocator:trace')\nconst debugError = require('debug')('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.begin()\n  const low = it.pointer.low\n  const high = it.pointer.high\n  const num = low\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low\n    const high = it.pointer.high\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (low > num) return false\n\n    // |x----|\n    if (low === num) {\n      // x|----|\n      this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (high === num) {\n      // |----|x\n      this.ss.updateKeyByIterator(it, new Interval(low, high - 1))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |--x--|\n    // x|--|\n    this.ss.updateKeyByIterator(it, new Interval(num + 1, high))\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.upperBound(key)\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    it.pre()\n    const low = it.pointer.high\n    const high = it.pointer.high\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.updateKeyByIterator(it, new Interval(low, num))\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const low = it.pointer.high - 1\n        const high = it.pointer.high\n        this.ss.updateKeyByIterator(it, new Interval(low, high))\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low\n      const rHigh = it.pointer.high\n      it.pre()\n      const lLow = it.pointer.low\n      const lHigh = it.pointer.high\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it)\n          const high = it.pointer.high\n          this.ss.updateKeyByIterator(it, new Interval(lLow, high))\n        } else {\n          // Concat to left\n          this.ss.updateKeyByIterator(it, new Interval(lLow, num))\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next())\n          this.ss.insert(new Interval(num, rHigh))\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}