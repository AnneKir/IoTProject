{"ast":null,"code":"import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nexport function forkJoin() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var resultSelector = popResultSelector(args);\n  var _a = argsArgArrayOrObject(args),\n    sources = _a.args,\n    keys = _a.keys;\n  var result = new Observable(function (subscriber) {\n    var length = sources.length;\n    if (!length) {\n      subscriber.complete();\n      return;\n    }\n    var values = new Array(length);\n    var remainingCompletions = length;\n    var remainingEmissions = length;\n    var _loop_1 = function _loop_1(sourceIndex) {\n      var hasValue = false;\n      innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {\n        if (!hasValue) {\n          hasValue = true;\n          remainingEmissions--;\n        }\n        values[sourceIndex] = value;\n      }, function () {\n        return remainingCompletions--;\n      }, undefined, function () {\n        if (!remainingCompletions || !hasValue) {\n          if (!remainingEmissions) {\n            subscriber.next(keys ? createObject(keys, values) : values);\n          }\n          subscriber.complete();\n        }\n      }));\n    };\n    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n      _loop_1(sourceIndex);\n    }\n  });\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAE1C,SAASC,oBAAoB,QAAQ,8BAA8B;AACnE,SAASC,SAAS,QAAQ,aAAa;AACvC,SAASC,iBAAiB,QAAQ,cAAc;AAChD,SAASC,wBAAwB,QAAQ,iCAAiC;AAC1E,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,SAASC,YAAY,QAAQ,sBAAsB;AA2InD,OAAM,SAAUC,QAAQ;EAAC;OAAA,UAAc,EAAdC,qBAAc,EAAdA,IAAc;IAAdC;;EACvB,IAAMC,cAAc,GAAGP,iBAAiB,CAACM,IAAI,CAAC;EACxC,SAA0BR,oBAAoB,CAACQ,IAAI,CAAC;IAA5CE,OAAO;IAAEC,IAAI,UAA+B;EAC1D,IAAMC,MAAM,GAAG,IAAIb,UAAU,CAAC,UAACc,UAAU;IAC/B,UAAM,GAAKH,OAAO,OAAZ;IACd,IAAI,CAACI,MAAM,EAAE;MACXD,UAAU,CAACE,QAAQ,EAAE;MACrB;;IAEF,IAAMC,MAAM,GAAG,IAAIC,KAAK,CAACH,MAAM,CAAC;IAChC,IAAII,oBAAoB,GAAGJ,MAAM;IACjC,IAAIK,kBAAkB,GAAGL,MAAM;mCACtBM,WAAW;MAClB,IAAIC,QAAQ,GAAG,KAAK;MACpBpB,SAAS,CAACS,OAAO,CAACU,WAAW,CAAC,CAAC,CAACE,SAAS,CACvCnB,wBAAwB,CACtBU,UAAU,EACV,UAACU,KAAK;QACJ,IAAI,CAACF,QAAQ,EAAE;UACbA,QAAQ,GAAG,IAAI;UACfF,kBAAkB,EAAE;;QAEtBH,MAAM,CAACI,WAAW,CAAC,GAAGG,KAAK;MAC7B,CAAC,EACD;QAAM,2BAAoB,EAAE;MAAtB,CAAsB,EAC5BC,SAAS,EACT;QACE,IAAI,CAACN,oBAAoB,IAAI,CAACG,QAAQ,EAAE;UACtC,IAAI,CAACF,kBAAkB,EAAE;YACvBN,UAAU,CAACY,IAAI,CAACd,IAAI,GAAGN,YAAY,CAACM,IAAI,EAAEK,MAAM,CAAC,GAAGA,MAAM,CAAC;;UAE7DH,UAAU,CAACE,QAAQ,EAAE;;MAEzB,CAAC,CACF,CACF;;IAvBH,KAAK,IAAIK,WAAW,GAAG,CAAC,EAAEA,WAAW,GAAGN,MAAM,EAAEM,WAAW,EAAE;cAApDA,WAAW;;EAyBtB,CAAC,CAAC;EACF,OAAOX,cAAc,GAAGG,MAAM,CAACc,IAAI,CAACtB,gBAAgB,CAACK,cAAc,CAAC,CAAC,GAAGG,MAAM;AAChF","names":["Observable","argsArgArrayOrObject","innerFrom","popResultSelector","createOperatorSubscriber","mapOneOrManyArgs","createObject","forkJoin","_i","args","resultSelector","sources","keys","result","subscriber","length","complete","values","Array","remainingCompletions","remainingEmissions","sourceIndex","hasValue","subscribe","value","undefined","next","pipe"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\forkJoin.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\r\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\r\nimport { innerFrom } from './innerFrom';\r\nimport { popResultSelector } from '../util/args';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { createObject } from '../util/createObject';\r\nimport { AnyCatcher } from '../AnyCatcher';\r\n\r\n// forkJoin(any)\r\n// We put this first because we need to catch cases where the user has supplied\r\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\r\n// we don't want it to randomly hit one of the other type signatures below,\r\n// as we have no idea at build-time what type we should be returning when given an any.\r\n\r\n/**\r\n * You have passed `any` here, we can't figure out if it is\r\n * an array or an object, so you're getting `unknown`. Use better types.\r\n * @param arg Something typed as `any`\r\n */\r\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\r\n\r\n// forkJoin(null | undefined)\r\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\r\n\r\n// forkJoin([a, b, c])\r\nexport function forkJoin(sources: readonly []): Observable<never>;\r\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\r\nexport function forkJoin<A extends readonly unknown[], R>(\r\n  sources: readonly [...ObservableInputTuple<A>],\r\n  resultSelector: (...values: A) => R\r\n): Observable<R>;\r\n\r\n// forkJoin(a, b, c)\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function forkJoin<A extends readonly unknown[], R>(\r\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\r\n): Observable<R>;\r\n\r\n// forkJoin({a, b, c})\r\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\r\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\r\n  sourcesObject: T\r\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\r\n\r\n/**\r\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\r\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\r\n * or a dictionary of values in the same shape as the passed dictionary.\r\n *\r\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\r\n * complete immediately if an empty array is passed.</span>\r\n *\r\n * ![](forkJoin.png)\r\n *\r\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\r\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\r\n * then the resulting stream will complete immediately.\r\n *\r\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\r\n * values from corresponding observables.\r\n *\r\n * If you pass an array of `n` observables to the operator, then the resulting\r\n * array will have `n` values, where the first value is the last one emitted by the first observable,\r\n * second value is the last one emitted by the second observable and so on.\r\n *\r\n * If you pass a dictionary of observables to the operator, then the resulting\r\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\r\n * located at the corresponding key.\r\n *\r\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\r\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\r\n * or {@link zip} instead.\r\n *\r\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\r\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n * and it will not emit anything either, even if it already has some last values from other observables.\r\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\r\n * unless at any point some other observable completes without emitting a value, which brings us back to\r\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\r\n * have to emit something at least once and complete.\r\n *\r\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\r\n * from the other observables.\r\n *\r\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\r\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\r\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\r\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\r\n * when `forkJoin` is supposed to emit a result.\r\n *\r\n * ## Examples\r\n *\r\n * Use `forkJoin` with a dictionary of observable inputs\r\n *\r\n * ```ts\r\n * import { forkJoin, of, timer } from 'rxjs';\r\n *\r\n * const observable = forkJoin({\r\n *   foo: of(1, 2, 3, 4),\r\n *   bar: Promise.resolve(8),\r\n *   baz: timer(4000)\r\n * });\r\n * observable.subscribe({\r\n *  next: value => console.log(value),\r\n *  complete: () => console.log('This is how it ends!'),\r\n * });\r\n *\r\n * // Logs:\r\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\r\n * // 'This is how it ends!' immediately after\r\n * ```\r\n *\r\n * Use `forkJoin` with an array of observable inputs\r\n *\r\n * ```ts\r\n * import { forkJoin, of, timer } from 'rxjs';\r\n *\r\n * const observable = forkJoin([\r\n *   of(1, 2, 3, 4),\r\n *   Promise.resolve(8),\r\n *   timer(4000)\r\n * ]);\r\n * observable.subscribe({\r\n *  next: value => console.log(value),\r\n *  complete: () => console.log('This is how it ends!'),\r\n * });\r\n *\r\n * // Logs:\r\n * // [4, 8, 0] after 4 seconds\r\n * // 'This is how it ends!' immediately after\r\n * ```\r\n *\r\n * @see {@link combineLatest}\r\n * @see {@link zip}\r\n *\r\n * @param {...ObservableInput} args Any number of Observables provided either as an array or as an arguments\r\n * passed directly to the operator.\r\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\r\n * that will appear in resulting Observable instead of default array.\r\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\r\n * or value from project function.\r\n */\r\nexport function forkJoin(...args: any[]): Observable<any> {\r\n  const resultSelector = popResultSelector(args);\r\n  const { args: sources, keys } = argsArgArrayOrObject(args);\r\n  const result = new Observable((subscriber) => {\r\n    const { length } = sources;\r\n    if (!length) {\r\n      subscriber.complete();\r\n      return;\r\n    }\r\n    const values = new Array(length);\r\n    let remainingCompletions = length;\r\n    let remainingEmissions = length;\r\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\r\n      let hasValue = false;\r\n      innerFrom(sources[sourceIndex]).subscribe(\r\n        createOperatorSubscriber(\r\n          subscriber,\r\n          (value) => {\r\n            if (!hasValue) {\r\n              hasValue = true;\r\n              remainingEmissions--;\r\n            }\r\n            values[sourceIndex] = value;\r\n          },\r\n          () => remainingCompletions--,\r\n          undefined,\r\n          () => {\r\n            if (!remainingCompletions || !hasValue) {\r\n              if (!remainingEmissions) {\r\n                subscriber.next(keys ? createObject(keys, values) : values);\r\n              }\r\n              subscriber.complete();\r\n            }\r\n          }\r\n        )\r\n      );\r\n    }\r\n  });\r\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}