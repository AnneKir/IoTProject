{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst WS = require('ws');\nconst debug = require('debug')('mqttjs:ws');\nconst duplexify = require('duplexify');\nconst Transform = require('readable-stream').Transform;\nconst WSS_OPTIONS = ['rejectUnauthorized', 'ca', 'cert', 'key', 'pfx', 'passphrase'];\n// eslint-disable-next-line camelcase\nconst IS_BROWSER = typeof process !== 'undefined' && process.title === 'browser' || typeof __webpack_require__ === 'function';\nfunction buildUrl(opts, client) {\n  let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n  if (typeof opts.transformWsUrl === 'function') {\n    url = opts.transformWsUrl(url, opts, client);\n  }\n  return url;\n}\nfunction setDefaultOpts(opts) {\n  const options = opts;\n  if (!opts.hostname) {\n    options.hostname = 'localhost';\n  }\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      options.port = 443;\n    } else {\n      options.port = 80;\n    }\n  }\n  if (!opts.path) {\n    options.path = '/';\n  }\n  if (!opts.wsOptions) {\n    options.wsOptions = {};\n  }\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {\n        options.wsOptions[prop] = opts[prop];\n      }\n    });\n  }\n  return options;\n}\nfunction setDefaultBrowserOpts(opts) {\n  const options = setDefaultOpts(opts);\n  if (!options.hostname) {\n    options.hostname = options.host;\n  }\n  if (!options.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof document === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.');\n    }\n    const parsed = new URL(document.URL);\n    options.hostname = parsed.hostname;\n    if (!options.port) {\n      options.port = parsed.port;\n    }\n  }\n\n  // objectMode should be defined for logic\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined);\n  }\n  return options;\n}\nfunction createWebSocket(client, url, opts) {\n  debug('createWebSocket');\n  debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion);\n  const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n  debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol);\n  const socket = new WS(url, [websocketSubProtocol], opts.wsOptions);\n  return socket;\n}\nfunction createBrowserWebSocket(client, opts) {\n  const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n  const url = buildUrl(opts, client);\n  /* global WebSocket */\n  const socket = new WebSocket(url, [websocketSubProtocol]);\n  socket.binaryType = 'arraybuffer';\n  return socket;\n}\nfunction streamBuilder(client, opts) {\n  debug('streamBuilder');\n  const options = setDefaultOpts(opts);\n  const url = buildUrl(options, client);\n  const socket = createWebSocket(client, url, options);\n  const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);\n  webSocketStream.url = url;\n  socket.on('close', () => {\n    webSocketStream.destroy();\n  });\n  return webSocketStream;\n}\nfunction browserStreamBuilder(client, opts) {\n  debug('browserStreamBuilder');\n  let stream;\n  const options = setDefaultBrowserOpts(opts);\n  // sets the maximum socket buffer size before throttling\n  const bufferSize = options.browserBufferSize || 1024 * 512;\n  const bufferTimeout = opts.browserBufferTimeout || 1000;\n  const coerceToBuffer = !opts.objectMode;\n  const socket = createBrowserWebSocket(client, opts);\n  const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);\n  if (!opts.objectMode) {\n    proxy._writev = writev;\n  }\n  proxy.on('close', () => {\n    socket.close();\n  });\n  const eventListenerSupport = typeof socket.addEventListener !== 'undefined';\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy;\n  } else {\n    stream = stream = duplexify(undefined, undefined, opts);\n    if (!opts.objectMode) {\n      stream._writev = writev;\n    }\n    if (eventListenerSupport) {\n      socket.addEventListener('open', onopen);\n    } else {\n      socket.onopen = onopen;\n    }\n  }\n  stream.socket = socket;\n  if (eventListenerSupport) {\n    socket.addEventListener('close', onclose);\n    socket.addEventListener('error', onerror);\n    socket.addEventListener('message', onmessage);\n  } else {\n    socket.onclose = onclose;\n    socket.onerror = onerror;\n    socket.onmessage = onmessage;\n  }\n\n  // methods for browserStreamBuilder\n\n  function buildProxy(options, socketWrite, socketEnd) {\n    const proxy = new Transform({\n      objectModeMode: options.objectMode\n    });\n    proxy._write = socketWrite;\n    proxy._flush = socketEnd;\n    return proxy;\n  }\n  function onopen() {\n    stream.setReadable(proxy);\n    stream.setWritable(proxy);\n    stream.emit('connect');\n  }\n  function onclose() {\n    stream.end();\n    stream.destroy();\n  }\n  function onerror(err) {\n    stream.destroy(err);\n  }\n  function onmessage(event) {\n    let data = event.data;\n    if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n    proxy.push(data);\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev(chunks, cb) {\n    const buffers = new Array(chunks.length);\n    for (let i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8');\n      } else {\n        buffers[i] = chunks[i].chunk;\n      }\n    }\n    this._write(Buffer.concat(buffers), 'binary', cb);\n  }\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      // throttle data until buffered amount is reduced.\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n    }\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8');\n    }\n    try {\n      socket.send(chunk);\n    } catch (err) {\n      return next(err);\n    }\n    next();\n  }\n  function socketEndBrowser(done) {\n    socket.close();\n    done();\n  }\n\n  // end methods for browserStreamBuilder\n\n  return stream;\n}\nif (IS_BROWSER) {\n  module.exports = browserStreamBuilder;\n} else {\n  module.exports = streamBuilder;\n}","map":{"version":3,"names":["Buffer","require","WS","debug","duplexify","Transform","WSS_OPTIONS","IS_BROWSER","process","title","__webpack_require__","buildUrl","opts","client","url","protocol","hostname","port","path","transformWsUrl","setDefaultOpts","options","wsOptions","forEach","prop","Object","prototype","hasOwnProperty","call","setDefaultBrowserOpts","host","document","Error","parsed","URL","objectMode","undefined","binary","createWebSocket","protocolId","protocolVersion","websocketSubProtocol","socket","createBrowserWebSocket","WebSocket","binaryType","streamBuilder","webSocketStream","createWebSocketStream","on","destroy","browserStreamBuilder","stream","bufferSize","browserBufferSize","bufferTimeout","browserBufferTimeout","coerceToBuffer","proxy","buildProxy","socketWriteBrowser","socketEndBrowser","_writev","writev","close","eventListenerSupport","addEventListener","readyState","OPEN","onopen","onclose","onerror","onmessage","socketWrite","socketEnd","objectModeMode","_write","_flush","setReadable","setWritable","emit","end","err","event","data","ArrayBuffer","from","push","chunks","cb","buffers","Array","length","i","chunk","concat","enc","next","bufferedAmount","setTimeout","send","done","module","exports"],"sources":["C:/Users/Amali/Desktop/Building_the_IoT_w._P2P_and_Cloud_Computing/IoTProject/node_modules/mqtt/lib/connect/ws.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst WS = require('ws')\nconst debug = require('debug')('mqttjs:ws')\nconst duplexify = require('duplexify')\nconst Transform = require('readable-stream').Transform\n\nconst WSS_OPTIONS = [\n  'rejectUnauthorized',\n  'ca',\n  'cert',\n  'key',\n  'pfx',\n  'passphrase'\n]\n// eslint-disable-next-line camelcase\nconst IS_BROWSER = (typeof process !== 'undefined' && process.title === 'browser') || typeof __webpack_require__ === 'function'\nfunction buildUrl (opts, client) {\n  let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  const options = opts\n  if (!opts.hostname) {\n    options.hostname = 'localhost'\n  }\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      options.port = 443\n    } else {\n      options.port = 80\n    }\n  }\n  if (!opts.path) {\n    options.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    options.wsOptions = {}\n  }\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {\n        options.wsOptions[prop] = opts[prop]\n      }\n    })\n  }\n\n  return options\n}\n\nfunction setDefaultBrowserOpts (opts) {\n  const options = setDefaultOpts(opts)\n\n  if (!options.hostname) {\n    options.hostname = options.host\n  }\n\n  if (!options.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof (document) === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.')\n    }\n    const parsed = new URL(document.URL)\n    options.hostname = parsed.hostname\n\n    if (!options.port) {\n      options.port = parsed.port\n    }\n  }\n\n  // objectMode should be defined for logic\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  return options\n}\n\nfunction createWebSocket (client, url, opts) {\n  debug('createWebSocket')\n  debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion)\n  const websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol)\n  const socket = new WS(url, [websocketSubProtocol], opts.wsOptions)\n  return socket\n}\n\nfunction createBrowserWebSocket (client, opts) {\n  const websocketSubProtocol =\n  (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n    ? 'mqttv3.1'\n    : 'mqtt'\n\n  const url = buildUrl(opts, client)\n  /* global WebSocket */\n  const socket = new WebSocket(url, [websocketSubProtocol])\n  socket.binaryType = 'arraybuffer'\n  return socket\n}\n\nfunction streamBuilder (client, opts) {\n  debug('streamBuilder')\n  const options = setDefaultOpts(opts)\n  const url = buildUrl(options, client)\n  const socket = createWebSocket(client, url, options)\n  const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions)\n  webSocketStream.url = url\n  socket.on('close', () => { webSocketStream.destroy() })\n  return webSocketStream\n}\n\nfunction browserStreamBuilder (client, opts) {\n  debug('browserStreamBuilder')\n  let stream\n  const options = setDefaultBrowserOpts(opts)\n  // sets the maximum socket buffer size before throttling\n  const bufferSize = options.browserBufferSize || 1024 * 512\n\n  const bufferTimeout = opts.browserBufferTimeout || 1000\n\n  const coerceToBuffer = !opts.objectMode\n\n  const socket = createBrowserWebSocket(client, opts)\n\n  const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser)\n\n  if (!opts.objectMode) {\n    proxy._writev = writev\n  }\n  proxy.on('close', () => { socket.close() })\n\n  const eventListenerSupport = (typeof socket.addEventListener !== 'undefined')\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else {\n    stream = stream = duplexify(undefined, undefined, opts)\n    if (!opts.objectMode) {\n      stream._writev = writev\n    }\n\n    if (eventListenerSupport) {\n      socket.addEventListener('open', onopen)\n    } else {\n      socket.onopen = onopen\n    }\n  }\n\n  stream.socket = socket\n\n  if (eventListenerSupport) {\n    socket.addEventListener('close', onclose)\n    socket.addEventListener('error', onerror)\n    socket.addEventListener('message', onmessage)\n  } else {\n    socket.onclose = onclose\n    socket.onerror = onerror\n    socket.onmessage = onmessage\n  }\n\n  // methods for browserStreamBuilder\n\n  function buildProxy (options, socketWrite, socketEnd) {\n    const proxy = new Transform({\n      objectModeMode: options.objectMode\n    })\n\n    proxy._write = socketWrite\n    proxy._flush = socketEnd\n\n    return proxy\n  }\n\n  function onopen () {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onclose () {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror (err) {\n    stream.destroy(err)\n  }\n\n  function onmessage (event) {\n    let data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    const buffers = new Array(chunks.length)\n    for (let i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  function socketWriteBrowser (chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      // throttle data until buffered amount is reduced.\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch (err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEndBrowser (done) {\n    socket.close()\n    done()\n  }\n\n  // end methods for browserStreamBuilder\n\n  return stream\n}\n\nif (IS_BROWSER) {\n  module.exports = browserStreamBuilder\n} else {\n  module.exports = streamBuilder\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAO,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACpC,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;AACxB,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAO,CAAC,CAAC,WAAW,CAAC;AAC3C,MAAMG,SAAS,GAAGH,OAAO,CAAC,WAAW,CAAC;AACtC,MAAMI,SAAS,GAAGJ,OAAO,CAAC,iBAAiB,CAAC,CAACI,SAAS;AAEtD,MAAMC,WAAW,GAAG,CAClB,oBAAoB,EACpB,IAAI,EACJ,MAAM,EACN,KAAK,EACL,KAAK,EACL,YAAY,CACb;AACD;AACA,MAAMC,UAAU,GAAI,OAAOC,OAAO,KAAK,WAAW,IAAIA,OAAO,CAACC,KAAK,KAAK,SAAS,IAAK,OAAOC,mBAAmB,KAAK,UAAU;AAC/H,SAASC,QAAQ,CAAEC,IAAI,EAAEC,MAAM,EAAE;EAC/B,IAAIC,GAAG,GAAGF,IAAI,CAACG,QAAQ,GAAG,KAAK,GAAGH,IAAI,CAACI,QAAQ,GAAG,GAAG,GAAGJ,IAAI,CAACK,IAAI,GAAGL,IAAI,CAACM,IAAI;EAC7E,IAAI,OAAQN,IAAI,CAACO,cAAe,KAAK,UAAU,EAAE;IAC/CL,GAAG,GAAGF,IAAI,CAACO,cAAc,CAACL,GAAG,EAAEF,IAAI,EAAEC,MAAM,CAAC;EAC9C;EACA,OAAOC,GAAG;AACZ;AAEA,SAASM,cAAc,CAAER,IAAI,EAAE;EAC7B,MAAMS,OAAO,GAAGT,IAAI;EACpB,IAAI,CAACA,IAAI,CAACI,QAAQ,EAAE;IAClBK,OAAO,CAACL,QAAQ,GAAG,WAAW;EAChC;EACA,IAAI,CAACJ,IAAI,CAACK,IAAI,EAAE;IACd,IAAIL,IAAI,CAACG,QAAQ,KAAK,KAAK,EAAE;MAC3BM,OAAO,CAACJ,IAAI,GAAG,GAAG;IACpB,CAAC,MAAM;MACLI,OAAO,CAACJ,IAAI,GAAG,EAAE;IACnB;EACF;EACA,IAAI,CAACL,IAAI,CAACM,IAAI,EAAE;IACdG,OAAO,CAACH,IAAI,GAAG,GAAG;EACpB;EAEA,IAAI,CAACN,IAAI,CAACU,SAAS,EAAE;IACnBD,OAAO,CAACC,SAAS,GAAG,CAAC,CAAC;EACxB;EACA,IAAI,CAACf,UAAU,IAAIK,IAAI,CAACG,QAAQ,KAAK,KAAK,EAAE;IAC1C;IACAT,WAAW,CAACiB,OAAO,CAAC,UAAUC,IAAI,EAAE;MAClC,IAAIC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAChB,IAAI,EAAEY,IAAI,CAAC,IAAI,CAACC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAChB,IAAI,CAACU,SAAS,EAAEE,IAAI,CAAC,EAAE;QACnHH,OAAO,CAACC,SAAS,CAACE,IAAI,CAAC,GAAGZ,IAAI,CAACY,IAAI,CAAC;MACtC;IACF,CAAC,CAAC;EACJ;EAEA,OAAOH,OAAO;AAChB;AAEA,SAASQ,qBAAqB,CAAEjB,IAAI,EAAE;EACpC,MAAMS,OAAO,GAAGD,cAAc,CAACR,IAAI,CAAC;EAEpC,IAAI,CAACS,OAAO,CAACL,QAAQ,EAAE;IACrBK,OAAO,CAACL,QAAQ,GAAGK,OAAO,CAACS,IAAI;EACjC;EAEA,IAAI,CAACT,OAAO,CAACL,QAAQ,EAAE;IACrB;IACA;IACA;IACA,IAAI,OAAQe,QAAS,KAAK,WAAW,EAAE;MACrC,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;IACrE;IACA,MAAMC,MAAM,GAAG,IAAIC,GAAG,CAACH,QAAQ,CAACG,GAAG,CAAC;IACpCb,OAAO,CAACL,QAAQ,GAAGiB,MAAM,CAACjB,QAAQ;IAElC,IAAI,CAACK,OAAO,CAACJ,IAAI,EAAE;MACjBI,OAAO,CAACJ,IAAI,GAAGgB,MAAM,CAAChB,IAAI;IAC5B;EACF;;EAEA;EACA,IAAII,OAAO,CAACc,UAAU,KAAKC,SAAS,EAAE;IACpCf,OAAO,CAACc,UAAU,GAAG,EAAEd,OAAO,CAACgB,MAAM,KAAK,IAAI,IAAIhB,OAAO,CAACgB,MAAM,KAAKD,SAAS,CAAC;EACjF;EAEA,OAAOf,OAAO;AAChB;AAEA,SAASiB,eAAe,CAAEzB,MAAM,EAAEC,GAAG,EAAEF,IAAI,EAAE;EAC3CT,KAAK,CAAC,iBAAiB,CAAC;EACxBA,KAAK,CAAC,YAAY,GAAGS,IAAI,CAAC2B,UAAU,GAAG,GAAG,GAAG3B,IAAI,CAAC4B,eAAe,CAAC;EAClE,MAAMC,oBAAoB,GACvB7B,IAAI,CAAC2B,UAAU,KAAK,QAAQ,IAAM3B,IAAI,CAAC4B,eAAe,KAAK,CAAE,GAC1D,UAAU,GACV,MAAM;EAEZrC,KAAK,CAAC,kCAAkC,GAAGW,GAAG,GAAG,iBAAiB,GAAG2B,oBAAoB,CAAC;EAC1F,MAAMC,MAAM,GAAG,IAAIxC,EAAE,CAACY,GAAG,EAAE,CAAC2B,oBAAoB,CAAC,EAAE7B,IAAI,CAACU,SAAS,CAAC;EAClE,OAAOoB,MAAM;AACf;AAEA,SAASC,sBAAsB,CAAE9B,MAAM,EAAED,IAAI,EAAE;EAC7C,MAAM6B,oBAAoB,GACzB7B,IAAI,CAAC2B,UAAU,KAAK,QAAQ,IAAM3B,IAAI,CAAC4B,eAAe,KAAK,CAAE,GAC1D,UAAU,GACV,MAAM;EAEV,MAAM1B,GAAG,GAAGH,QAAQ,CAACC,IAAI,EAAEC,MAAM,CAAC;EAClC;EACA,MAAM6B,MAAM,GAAG,IAAIE,SAAS,CAAC9B,GAAG,EAAE,CAAC2B,oBAAoB,CAAC,CAAC;EACzDC,MAAM,CAACG,UAAU,GAAG,aAAa;EACjC,OAAOH,MAAM;AACf;AAEA,SAASI,aAAa,CAAEjC,MAAM,EAAED,IAAI,EAAE;EACpCT,KAAK,CAAC,eAAe,CAAC;EACtB,MAAMkB,OAAO,GAAGD,cAAc,CAACR,IAAI,CAAC;EACpC,MAAME,GAAG,GAAGH,QAAQ,CAACU,OAAO,EAAER,MAAM,CAAC;EACrC,MAAM6B,MAAM,GAAGJ,eAAe,CAACzB,MAAM,EAAEC,GAAG,EAAEO,OAAO,CAAC;EACpD,MAAM0B,eAAe,GAAG7C,EAAE,CAAC8C,qBAAqB,CAACN,MAAM,EAAErB,OAAO,CAACC,SAAS,CAAC;EAC3EyB,eAAe,CAACjC,GAAG,GAAGA,GAAG;EACzB4B,MAAM,CAACO,EAAE,CAAC,OAAO,EAAE,MAAM;IAAEF,eAAe,CAACG,OAAO,EAAE;EAAC,CAAC,CAAC;EACvD,OAAOH,eAAe;AACxB;AAEA,SAASI,oBAAoB,CAAEtC,MAAM,EAAED,IAAI,EAAE;EAC3CT,KAAK,CAAC,sBAAsB,CAAC;EAC7B,IAAIiD,MAAM;EACV,MAAM/B,OAAO,GAAGQ,qBAAqB,CAACjB,IAAI,CAAC;EAC3C;EACA,MAAMyC,UAAU,GAAGhC,OAAO,CAACiC,iBAAiB,IAAI,IAAI,GAAG,GAAG;EAE1D,MAAMC,aAAa,GAAG3C,IAAI,CAAC4C,oBAAoB,IAAI,IAAI;EAEvD,MAAMC,cAAc,GAAG,CAAC7C,IAAI,CAACuB,UAAU;EAEvC,MAAMO,MAAM,GAAGC,sBAAsB,CAAC9B,MAAM,EAAED,IAAI,CAAC;EAEnD,MAAM8C,KAAK,GAAGC,UAAU,CAAC/C,IAAI,EAAEgD,kBAAkB,EAAEC,gBAAgB,CAAC;EAEpE,IAAI,CAACjD,IAAI,CAACuB,UAAU,EAAE;IACpBuB,KAAK,CAACI,OAAO,GAAGC,MAAM;EACxB;EACAL,KAAK,CAACT,EAAE,CAAC,OAAO,EAAE,MAAM;IAAEP,MAAM,CAACsB,KAAK,EAAE;EAAC,CAAC,CAAC;EAE3C,MAAMC,oBAAoB,GAAI,OAAOvB,MAAM,CAACwB,gBAAgB,KAAK,WAAY;;EAE7E;EACA,IAAIxB,MAAM,CAACyB,UAAU,KAAKzB,MAAM,CAAC0B,IAAI,EAAE;IACrChB,MAAM,GAAGM,KAAK;EAChB,CAAC,MAAM;IACLN,MAAM,GAAGA,MAAM,GAAGhD,SAAS,CAACgC,SAAS,EAAEA,SAAS,EAAExB,IAAI,CAAC;IACvD,IAAI,CAACA,IAAI,CAACuB,UAAU,EAAE;MACpBiB,MAAM,CAACU,OAAO,GAAGC,MAAM;IACzB;IAEA,IAAIE,oBAAoB,EAAE;MACxBvB,MAAM,CAACwB,gBAAgB,CAAC,MAAM,EAAEG,MAAM,CAAC;IACzC,CAAC,MAAM;MACL3B,MAAM,CAAC2B,MAAM,GAAGA,MAAM;IACxB;EACF;EAEAjB,MAAM,CAACV,MAAM,GAAGA,MAAM;EAEtB,IAAIuB,oBAAoB,EAAE;IACxBvB,MAAM,CAACwB,gBAAgB,CAAC,OAAO,EAAEI,OAAO,CAAC;IACzC5B,MAAM,CAACwB,gBAAgB,CAAC,OAAO,EAAEK,OAAO,CAAC;IACzC7B,MAAM,CAACwB,gBAAgB,CAAC,SAAS,EAAEM,SAAS,CAAC;EAC/C,CAAC,MAAM;IACL9B,MAAM,CAAC4B,OAAO,GAAGA,OAAO;IACxB5B,MAAM,CAAC6B,OAAO,GAAGA,OAAO;IACxB7B,MAAM,CAAC8B,SAAS,GAAGA,SAAS;EAC9B;;EAEA;;EAEA,SAASb,UAAU,CAAEtC,OAAO,EAAEoD,WAAW,EAAEC,SAAS,EAAE;IACpD,MAAMhB,KAAK,GAAG,IAAIrD,SAAS,CAAC;MAC1BsE,cAAc,EAAEtD,OAAO,CAACc;IAC1B,CAAC,CAAC;IAEFuB,KAAK,CAACkB,MAAM,GAAGH,WAAW;IAC1Bf,KAAK,CAACmB,MAAM,GAAGH,SAAS;IAExB,OAAOhB,KAAK;EACd;EAEA,SAASW,MAAM,GAAI;IACjBjB,MAAM,CAAC0B,WAAW,CAACpB,KAAK,CAAC;IACzBN,MAAM,CAAC2B,WAAW,CAACrB,KAAK,CAAC;IACzBN,MAAM,CAAC4B,IAAI,CAAC,SAAS,CAAC;EACxB;EAEA,SAASV,OAAO,GAAI;IAClBlB,MAAM,CAAC6B,GAAG,EAAE;IACZ7B,MAAM,CAACF,OAAO,EAAE;EAClB;EAEA,SAASqB,OAAO,CAAEW,GAAG,EAAE;IACrB9B,MAAM,CAACF,OAAO,CAACgC,GAAG,CAAC;EACrB;EAEA,SAASV,SAAS,CAAEW,KAAK,EAAE;IACzB,IAAIC,IAAI,GAAGD,KAAK,CAACC,IAAI;IACrB,IAAIA,IAAI,YAAYC,WAAW,EAAED,IAAI,GAAGpF,MAAM,CAACsF,IAAI,CAACF,IAAI,CAAC,MACpDA,IAAI,GAAGpF,MAAM,CAACsF,IAAI,CAACF,IAAI,EAAE,MAAM,CAAC;IACrC1B,KAAK,CAAC6B,IAAI,CAACH,IAAI,CAAC;EAClB;;EAEA;EACA,SAASrB,MAAM,CAAEyB,MAAM,EAAEC,EAAE,EAAE;IAC3B,MAAMC,OAAO,GAAG,IAAIC,KAAK,CAACH,MAAM,CAACI,MAAM,CAAC;IACxC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;MACtC,IAAI,OAAOL,MAAM,CAACK,CAAC,CAAC,CAACC,KAAK,KAAK,QAAQ,EAAE;QACvCJ,OAAO,CAACG,CAAC,CAAC,GAAG7F,MAAM,CAACsF,IAAI,CAACE,MAAM,CAACK,CAAC,CAAC,EAAE,MAAM,CAAC;MAC7C,CAAC,MAAM;QACLH,OAAO,CAACG,CAAC,CAAC,GAAGL,MAAM,CAACK,CAAC,CAAC,CAACC,KAAK;MAC9B;IACF;IAEA,IAAI,CAAClB,MAAM,CAAC5E,MAAM,CAAC+F,MAAM,CAACL,OAAO,CAAC,EAAE,QAAQ,EAAED,EAAE,CAAC;EACnD;EAEA,SAAS7B,kBAAkB,CAAEkC,KAAK,EAAEE,GAAG,EAAEC,IAAI,EAAE;IAC7C,IAAIvD,MAAM,CAACwD,cAAc,GAAG7C,UAAU,EAAE;MACtC;MACA8C,UAAU,CAACvC,kBAAkB,EAAEL,aAAa,EAAEuC,KAAK,EAAEE,GAAG,EAAEC,IAAI,CAAC;IACjE;IAEA,IAAIxC,cAAc,IAAI,OAAOqC,KAAK,KAAK,QAAQ,EAAE;MAC/CA,KAAK,GAAG9F,MAAM,CAACsF,IAAI,CAACQ,KAAK,EAAE,MAAM,CAAC;IACpC;IAEA,IAAI;MACFpD,MAAM,CAAC0D,IAAI,CAACN,KAAK,CAAC;IACpB,CAAC,CAAC,OAAOZ,GAAG,EAAE;MACZ,OAAOe,IAAI,CAACf,GAAG,CAAC;IAClB;IAEAe,IAAI,EAAE;EACR;EAEA,SAASpC,gBAAgB,CAAEwC,IAAI,EAAE;IAC/B3D,MAAM,CAACsB,KAAK,EAAE;IACdqC,IAAI,EAAE;EACR;;EAEA;;EAEA,OAAOjD,MAAM;AACf;AAEA,IAAI7C,UAAU,EAAE;EACd+F,MAAM,CAACC,OAAO,GAAGpD,oBAAoB;AACvC,CAAC,MAAM;EACLmD,MAAM,CAACC,OAAO,GAAGzD,aAAa;AAChC"},"metadata":{},"sourceType":"script"}