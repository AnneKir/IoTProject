{"ast":null,"code":"import { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\nexport function merge() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var scheduler = popScheduler(args);\n  var concurrent = popNumber(args, Infinity);\n  var sources = args;\n  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));\n}","map":{"version":3,"mappings":"AAEA,SAASA,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,SAAS,QAAQ,aAAa;AACvC,SAASC,KAAK,QAAQ,SAAS;AAC/B,SAASC,SAAS,EAAEC,YAAY,QAAQ,cAAc;AACtD,SAASC,IAAI,QAAQ,QAAQ;AAmF7B,OAAM,SAAUC,KAAK;EAAC;OAAA,UAA8D,EAA9DC,qBAA8D,EAA9DA,IAA8D;IAA9DC;;EACpB,IAAMC,SAAS,GAAGL,YAAY,CAACI,IAAI,CAAC;EACpC,IAAME,UAAU,GAAGP,SAAS,CAACK,IAAI,EAAEG,QAAQ,CAAC;EAC5C,IAAMC,OAAO,GAAGJ,IAAkC;EAClD,OAAO,CAACI,OAAO,CAACC,MAAM,GAElBX,KAAK,GACLU,OAAO,CAACC,MAAM,KAAK,CAAC,GAEpBZ,SAAS,CAACW,OAAO,CAAC,CAAC,CAAC,CAAC,GAErBZ,QAAQ,CAACU,UAAU,CAAC,CAACL,IAAI,CAACO,OAAO,EAAEH,SAAS,CAAC,CAAC;AACpD","names":["mergeAll","innerFrom","EMPTY","popNumber","popScheduler","from","merge","_i","args","scheduler","concurrent","Infinity","sources","length"],"sources":["C:\\Users\\Amali\\Desktop\\Building_the_IoT_w._P2P_and_Cloud_Computing\\IoTProject\\node_modules\\rxjs\\src\\internal\\observable\\merge.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\r\nimport { mergeAll } from '../operators/mergeAll';\r\nimport { innerFrom } from './innerFrom';\r\nimport { EMPTY } from './empty';\r\nimport { popNumber, popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function merge<A extends readonly unknown[]>(\r\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\r\n): Observable<A[number]>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function merge<A extends readonly unknown[]>(\r\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\r\n): Observable<A[number]>;\r\n\r\n/**\r\n * Creates an output Observable which concurrently emits all values from every\r\n * given input Observable.\r\n *\r\n * <span class=\"informal\">Flattens multiple Observables together by blending\r\n * their values into one Observable.</span>\r\n *\r\n * ![](merge.png)\r\n *\r\n * `merge` subscribes to each given input Observable (as arguments), and simply\r\n * forwards (without doing any transformation) all the values from all the input\r\n * Observables to the output Observable. The output Observable only completes\r\n * once all input Observables have completed. Any error delivered by an input\r\n * Observable will be immediately emitted on the output Observable.\r\n *\r\n * ## Examples\r\n *\r\n * Merge together two Observables: 1s interval and clicks\r\n *\r\n * ```ts\r\n * import { merge, fromEvent, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const timer = interval(1000);\r\n * const clicksOrTimer = merge(clicks, timer);\r\n * clicksOrTimer.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // timer will emit ascending values, one every second(1000ms) to console\r\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\r\n * // Since the two streams are merged you see these happening\r\n * // as they occur.\r\n * ```\r\n *\r\n * Merge together 3 Observables, but run only 2 concurrently\r\n *\r\n * ```ts\r\n * import { interval, take, merge } from 'rxjs';\r\n *\r\n * const timer1 = interval(1000).pipe(take(10));\r\n * const timer2 = interval(2000).pipe(take(6));\r\n * const timer3 = interval(500).pipe(take(10));\r\n *\r\n * const concurrent = 2; // the argument\r\n * const merged = merge(timer1, timer2, timer3, concurrent);\r\n * merged.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // - First timer1 and timer2 will run concurrently\r\n * // - timer1 will emit a value every 1000ms for 10 iterations\r\n * // - timer2 will emit a value every 2000ms for 6 iterations\r\n * // - after timer1 hits its max iteration, timer2 will\r\n * //   continue, and timer3 will start to run concurrently with timer2\r\n * // - when timer2 hits its max iteration it terminates, and\r\n * //   timer3 will continue to emit a value every 500ms until it is complete\r\n * ```\r\n *\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeMapTo}\r\n * @see {@link mergeScan}\r\n *\r\n * @param {...ObservableInput} observables Input Observables to merge together.\r\n * @param {number} [concurrent=Infinity] Maximum number of input\r\n * Observables being subscribed to concurrently.\r\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\r\n * concurrency of input Observables.\r\n * @return {Observable} an Observable that emits items that are the result of\r\n * every input Observable.\r\n */\r\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\r\n  const scheduler = popScheduler(args);\r\n  const concurrent = popNumber(args, Infinity);\r\n  const sources = args as ObservableInput<unknown>[];\r\n  return !sources.length\r\n    ? // No source provided\r\n      EMPTY\r\n    : sources.length === 1\r\n    ? // One source? Just return it.\r\n      innerFrom(sources[0])\r\n    : // Merge all sources\r\n      mergeAll(concurrent)(from(sources, scheduler));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}