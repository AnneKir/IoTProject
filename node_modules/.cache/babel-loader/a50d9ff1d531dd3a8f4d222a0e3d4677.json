{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies\n */\nconst EventEmitter = require('events').EventEmitter;\nconst Store = require('./store');\nconst TopicAliasRecv = require('./topic-alias-recv');\nconst TopicAliasSend = require('./topic-alias-send');\nconst mqttPacket = require('mqtt-packet');\nconst DefaultMessageIdProvider = require('./default-message-id-provider');\nconst Writable = require('readable-stream').Writable;\nconst inherits = require('inherits');\nconst reInterval = require('reinterval');\nconst clone = require('rfdc/default');\nconst validations = require('./validations');\nconst xtend = require('xtend');\nconst debug = require('debug')('mqttjs:client');\nconst nextTick = process ? process.nextTick : function (callback) {\n  setTimeout(callback, 0);\n};\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback);\n};\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nconst socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND'];\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\nfunction applyTopicAlias(client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias;\n      if (packet.properties) {\n        alias = packet.properties.topicAlias;\n      }\n      const topic = packet.topic.toString();\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n              return new Error('Sending Topic Alias out of range');\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n              if (alias) {\n                packet.topic = '';\n                packet.properties = {\n                  ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);\n              } else {\n                alias = client.topicAliasSend.getLruAlias();\n                client.topicAliasSend.put(topic, alias);\n                packet.properties = {\n                  ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n              if (alias) {\n                packet.topic = '';\n                packet.properties = {\n                  ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n        return new Error('Sending Topic Alias out of range');\n      }\n    }\n  }\n}\nfunction removeTopicAliasAndRecoverTopicName(client, packet) {\n  let alias;\n  if (packet.properties) {\n    alias = packet.properties.topicAlias;\n  }\n  let topic = packet.topic.toString();\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias');\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias);\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias');\n      } else {\n        packet.topic = topic;\n      }\n    }\n  }\n  if (alias) {\n    delete packet.properties.topicAlias;\n  }\n}\nfunction sendPacket(client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet);\n  debug('sendPacket :: emitting `packetsend`');\n  client.emit('packetsend', packet);\n  debug('sendPacket :: writing to stream');\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options);\n  debug('sendPacket :: writeToStream result %s', result);\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.');\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    debug('sendPacket :: invoking cb');\n    cb();\n  }\n}\nfunction flush(queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!queue);\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n        delete queue[messageId];\n      }\n    });\n  }\n}\nfunction flushVolatile(queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n  let storePacket = packet;\n  let err;\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket);\n    if (err) {\n      return cb && cb(err);\n    }\n  }\n  client.outgoingStore.put(storePacket, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\nfunction nop(error) {\n  debug('nop ::', error);\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient(streamBuilder, options) {\n  let k;\n  const that = this;\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n  this.options = options || {};\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n  debug('MqttClient :: options.protocol', options.protocol);\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n  debug('MqttClient :: options.username', options.username);\n  debug('MqttClient :: options.keepalive', options.keepalive);\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum);\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  debug('MqttClient :: clientId', this.options.clientId);\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder;\n  this.messageIdProvider = typeof this.options.messageIdProvider === 'undefined' ? new DefaultMessageIdProvider() : this.options.messageIdProvider;\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store();\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {};\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {};\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null;\n  // Is the client connected?\n  this.connected = false;\n  // Are we disconnecting?\n  this.disconnecting = false;\n  // Packet queue\n  this.queue = [];\n  // connack timer\n  this.connackTimer = null;\n  // Reconnect timer\n  this.reconnectTimer = null;\n  // Is processing store?\n  this._storeProcessing = false;\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {};\n  // Store processing queue\n  this._storeProcessingQueue = [];\n\n  // Inflight callbacks\n  this.outgoing = {};\n\n  // True if connection is first time.\n  this._firstConnection = true;\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range');\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum);\n    }\n  }\n\n  // Send queued packets\n  this.on('connect', function () {\n    const queue = this.queue;\n    function deliver() {\n      const entry = queue.shift();\n      debug('deliver :: entry %o', entry);\n      let packet = null;\n      if (!entry) {\n        that._resubscribe();\n        return;\n      }\n      packet = entry.packet;\n      debug('deliver :: call _sendPacket for %o', packet);\n      let send = true;\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false;\n        }\n      }\n      if (send) {\n        that._sendPacket(packet, function (err) {\n          if (entry.cb) {\n            entry.cb(err);\n          }\n          deliver();\n        });\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId);\n        deliver();\n      }\n    }\n    debug('connect :: sending queued packets');\n    deliver();\n  });\n  this.on('close', function () {\n    debug('close :: connected set to `false`');\n    this.connected = false;\n    debug('close :: clearing connackTimer');\n    clearTimeout(this.connackTimer);\n    debug('close :: clearing ping timer');\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear();\n    }\n    debug('close :: calling _setupReconnect');\n    this._setupReconnect();\n  });\n  EventEmitter.call(this);\n  debug('MqttClient :: setting up stream');\n  this._setupStream();\n}\ninherits(MqttClient, EventEmitter);\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  const that = this;\n  const writable = new Writable();\n  const parser = mqttPacket.parser(this.options);\n  let completeParse = null;\n  const packets = [];\n  debug('_setupStream :: calling method to clear reconnect');\n  this._clearReconnect();\n  debug('_setupStream :: using streamBuilder provided to client to create stream');\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.');\n    packets.push(packet);\n  });\n  function nextTickWork() {\n    if (packets.length) {\n      nextTick(work);\n    } else {\n      const done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n  function work() {\n    debug('work :: getting next packet in queue');\n    const packet = packets.shift();\n    if (packet) {\n      debug('work :: packet pulled from queue');\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      debug('work :: no packets in queue');\n      const done = completeParse;\n      completeParse = null;\n      debug('work :: done flag is %s', !!done);\n      if (done) done();\n    }\n  }\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    debug('writable stream :: parsing buffer');\n    parser.parse(buf);\n    work();\n  };\n  function streamErrorHandler(error) {\n    debug('streamErrorHandler :: error', error.message);\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error');\n      that.emit('error', error);\n    } else {\n      nop(error);\n    }\n  }\n  debug('_setupStream :: pipe stream to writable stream');\n  this.stream.pipe(writable);\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler);\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId);\n    flushVolatile(that.outgoing);\n    debug('stream: emit close to MqttClient');\n    that.emit('close');\n  });\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`');\n  const connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {};\n    }\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;\n    }\n  }\n  // avoid message queue\n  sendPacket(this, connectPacket);\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'));\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n      return this;\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options;\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n  debug('_handlePacket :: emitting packetreceive');\n  this.emit('packetreceive', packet);\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n      break;\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n      done();\n      break;\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n      break;\n    case 'connack':\n      this._handleConnack(packet);\n      done();\n      break;\n    case 'auth':\n      this._handleAuth(packet);\n      done();\n      break;\n    case 'pingresp':\n      this._handlePingresp(packet);\n      done();\n      break;\n    case 'disconnect':\n      this._handleDisconnect(packet);\n      done();\n      break;\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n  return this.disconnecting;\n};\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic);\n  const options = this.options;\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  // default opts\n  const defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  const that = this;\n  const publishProc = function () {\n    let messageId = 0;\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId();\n      if (messageId === null) {\n        debug('No messageId left');\n        return false;\n      }\n    }\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    };\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties;\n    }\n    debug('publish :: qos', opts.qos);\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        };\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n        that._sendPacket(packet, undefined, opts.cbStorePut);\n        break;\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n        that._sendPacket(packet, callback, opts.cbStorePut);\n        break;\n    }\n    return true;\n  };\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push({\n      invoke: publishProc,\n      cbStorePut: opts.cbStorePut,\n      callback: callback\n    });\n  }\n  return this;\n};\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n  const subs = [];\n  let obj = args.shift();\n  const resubscribe = obj.resubscribe;\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n  const version = this.options.protocolVersion;\n  delete obj.resubscribe;\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n  const invalidTopic = validations.validateTopics(obj);\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true');\n    return this;\n  }\n  const defaultOpts = {\n    qos: 0\n  };\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n  opts = xtend(defaultOpts, opts);\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic);\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      debug('subscribe: object topic %s', k);\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        const currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n        debug('subscribe: pushing `%s` to subs list', currentOpts);\n        subs.push(currentOpts);\n      }\n    });\n  }\n  if (!subs.length) {\n    callback(null, []);\n    return this;\n  }\n  const subscribeProc = function () {\n    const messageId = that._nextId();\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    };\n    if (opts.properties) {\n      packet.properties = opts.properties;\n    }\n\n    // subscriptions to resubscribe to in case of disconnect\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true');\n      const topics = [];\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = {\n            qos: sub.qos\n          };\n          if (version === 5) {\n            topic.nl = sub.nl || false;\n            topic.rap = sub.rap || false;\n            topic.rh = sub.rh || 0;\n            topic.properties = sub.properties;\n          }\n          that._resubscribeTopics[sub.topic] = topic;\n          topics.push(sub.topic);\n        }\n      });\n      that.messageIdToTopic[packet.messageId] = topics;\n    }\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted;\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i];\n          }\n        }\n        callback(err, subs);\n      }\n    };\n    debug('subscribe :: call _sendPacket');\n    that._sendPacket(packet);\n    return true;\n  };\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: subscribeProc,\n      callback: callback\n    });\n  }\n  return this;\n};\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n  let topic = args.shift();\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n  const invalidTopic = validations.validateTopics(topic);\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n  if (that._checkDisconnecting(callback)) {\n    return this;\n  }\n  const unsubscribeProc = function () {\n    const messageId = that._nextId();\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    };\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic];\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic;\n    }\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic];\n      });\n    }\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties;\n    }\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    };\n    debug('unsubscribe: call _sendPacket');\n    that._sendPacket(packet);\n    return true;\n  };\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: unsubscribeProc,\n      callback: callback\n    });\n  }\n  return this;\n};\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this;\n  debug('end :: (%s)', this.options.clientId);\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n  debug('end :: cb? %s', !!cb);\n  cb = cb || nop;\n  function closeStores() {\n    debug('end :: closeStores: closing incoming and outgoing stores');\n    that.disconnected = true;\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end');\n        that.emit('end');\n        if (cb) {\n          const err = e1 || e2;\n          debug('end :: closeStores: invoking callback with args');\n          cb(err);\n        }\n      });\n    });\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores');\n      // const boundProcess = nextTick.bind(null, closeStores)\n      nextTick(closeStores.bind(that));\n    }, opts);\n  }\n  if (this.disconnecting) {\n    cb();\n    return this;\n  }\n  this._clearReconnect();\n  this.disconnecting = true;\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n    finish();\n  }\n  return this;\n};\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastAllocated());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  delete this.outgoing[messageId];\n  this.outgoingStore.del({\n    messageId: messageId\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect');\n  const that = this;\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n    that._reconnect();\n  };\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n  return this;\n};\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client');\n  this.emit('reconnect');\n  if (this.connected) {\n    this.end(() => {\n      this._setupStream();\n    });\n    debug('client already connected. disconnecting first.');\n  } else {\n    debug('_reconnect: calling _setupStream');\n    this._setupStream();\n  }\n};\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  const that = this;\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state');\n      this.emit('offline');\n      debug('_setupReconnect :: set `reconnecting` to `true`');\n      this.reconnecting = true;\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!');\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  } else {\n    debug('_setupReconnect :: doing nothing...');\n  }\n};\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer');\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2];\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close');\n    this.stream.on('close', done);\n  }\n  debug('_cleanUp :: forced? %s', forced);\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n    this.stream.destroy();\n  } else {\n    const packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n    this._clearReconnect();\n    this._setupReconnect();\n  }\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer');\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n  cbStorePut = cbStorePut || nop;\n  cb = cb || nop;\n  const err = applyTopicAlias(this, packet);\n  if (err) {\n    cb(err);\n    return;\n  }\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval();\n      sendPacket(this, packet, cb);\n      return;\n    }\n    debug('_sendPacket :: client not connected. Storing packet offline.');\n    this._storePacket(packet, cb, cbStorePut);\n    return;\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval();\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n    /* falls through */\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n};\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet);\n  debug('_storePacket :: cb? %s', !!cb);\n  cbStorePut = cbStorePut || nop;\n  let storePacket = packet;\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket);\n    if (err) {\n      return cb && cb(err);\n    }\n  }\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== 'publish') {\n    this.queue.push({\n      packet: storePacket,\n      cb: cb\n    });\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n  const that = this;\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...');\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n    this.pingResp = false;\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true');\n    this._cleanUp(true);\n  }\n};\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack');\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n  delete this.topicAliasSend;\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'));\n        return;\n      }\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);\n      }\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n      this._shiftPingInterval();\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n  if (rc === 0) {\n    this.reconnecting = false;\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version);\n    err.code = rc;\n    this.emit('error', err);\n    return;\n  }\n  const that = this;\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err);\n      return;\n    }\n    if (rc === 24) {\n      that.reconnecting = false;\n      that._sendPacket(packet);\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc]);\n      err.code = rc;\n      that.emit('error', error);\n    }\n  });\n};\n\n/**\n * @param packet the packet received by the broker\n * @return the auth packet to be returned to the broker\n * @api public\n */\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback();\n};\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet);\n  done = typeof done !== 'undefined' ? done : nop;\n  let topic = packet.topic.toString();\n  const message = packet.payload;\n  const qos = packet.qos;\n  const messageId = packet.messageId;\n  const that = this;\n  const options = this.options;\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n  if (this.options.protocolVersion === 5) {\n    let alias;\n    if (packet.properties) {\n      alias = packet.properties.topicAlias;\n    }\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);\n          if (gotTopic) {\n            topic = gotTopic;\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias);\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias);\n            this.emit('error', new Error('Received unregistered Topic Alias'));\n            return;\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias);\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      }\n    }\n  }\n  debug('_handlePublish: qos %d', qos);\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n          if (error) {\n            return that.emit('error', error);\n          }\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: messageId\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n          if (error) {\n            return that.emit('error', error);\n          }\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.');\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId;\n  const type = packet.cmd;\n  let response = null;\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  const that = this;\n  let err;\n\n  // Checking `!cb` happens to work, but it's not technically \"correct\".\n  //\n  // Why? This code assumes that \"no callback\" is the same as that \"we're not\n  // waiting for responses\" (puback, pubrec, pubcomp, suback, or unsuback).\n  //\n  // It would be better to check `if (!this.outgoing[messageId])` here, but\n  // there's no reason to change it and risk (another) regression.\n  //\n  // The only reason this code works is becaues code in MqttClient.publish,\n  // MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will\n  // have a callback even if the user doesn't pass one in.)\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.');\n    // Server sent an ack in error, ignore it.\n    return;\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type);\n  switch (type) {\n    case 'pubcomp':\n    // same thing as puback for QoS 2\n    case 'puback':\n      {\n        const pubackRC = packet.reasonCode;\n        // Callback - we're done\n        if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubackRC]);\n          err.code = pubackRC;\n          cb(err, packet);\n        }\n        delete this.outgoing[messageId];\n        this.outgoingStore.del(packet, cb);\n        this.messageIdProvider.deallocate(messageId);\n        this._invokeStoreProcessingQueue();\n        break;\n      }\n    case 'pubrec':\n      {\n        response = {\n          cmd: 'pubrel',\n          qos: 2,\n          messageId: messageId\n        };\n        const pubrecRC = packet.reasonCode;\n        if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubrecRC]);\n          err.code = pubrecRC;\n          cb(err, packet);\n        } else {\n          this._sendPacket(response);\n        }\n        break;\n      }\n    case 'suback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n        for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n          if ((packet.granted[grantedI] & 0x80) !== 0) {\n            // suback with Failure status\n            const topics = this.messageIdToTopic[messageId];\n            if (topics) {\n              topics.forEach(function (topic) {\n                delete that._resubscribeTopics[topic];\n              });\n            }\n          }\n        }\n        this._invokeStoreProcessingQueue();\n        cb(null, packet);\n        break;\n      }\n    case 'unsuback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n        this._invokeStoreProcessingQueue();\n        cb(null);\n        break;\n      }\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet');\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  const messageId = packet.messageId;\n  const that = this;\n  const comp = {\n    cmd: 'pubcomp',\n    messageId: messageId\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        that.incomingStore.del(pub, nop);\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate();\n};\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated();\n};\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe');\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5');\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n  this._firstConnection = false;\n};\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n  const that = this;\n  this.connackPacket = packet;\n  this.messageIdProvider.clear();\n  this._setupPingTimer();\n  this.connected = true;\n  function startStreamProcess() {\n    let outStore = that.outgoingStore.createStream();\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n      that._flushStoreProcessingQueue();\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n      that._flushStoreProcessingQueue();\n      clearStoreProcessing();\n    }\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n      that._storeProcessing = true;\n      const packet = outStore.read(1);\n      let cb;\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status);\n            }\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet);\n        } else {\n          debug('messageId: %d has already used.', packet.messageId);\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n    outStore.on('end', function () {\n      let allProcessed = true;\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n        that._invokeAllStoreProcessingQueue();\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  }\n  // start flowing\n  startStreamProcess();\n};\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0];\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift();\n      return true;\n    }\n  }\n  return false;\n};\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) {/* empty */}\n};\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'));\n    if (f.callback) f.callback(new Error('Connection closed'));\n  }\n  this._storeProcessingQueue.splice(0);\n};\nmodule.exports = MqttClient;","map":{"version":3,"names":["EventEmitter","require","Store","TopicAliasRecv","TopicAliasSend","mqttPacket","DefaultMessageIdProvider","Writable","inherits","reInterval","clone","validations","xtend","debug","nextTick","process","callback","setTimeout","setImmediate","global","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","socketErrors","errors","defaultId","Math","random","toString","substr","applyTopicAlias","client","packet","options","cmd","alias","properties","topicAlias","topic","topicAliasSend","length","put","Error","autoAssignTopicAlias","getAliasByTopic","getLruAlias","autoUseTopicAlias","removeTopicAliasAndRecoverTopicName","getTopicByAlias","sendPacket","cb","emit","result","writeToStream","stream","nop","once","flush","queue","Object","keys","forEach","messageId","flushVolatile","volatile","storeAndSend","cbStorePut","storePacket","err","outgoingStore","storedPacket","error","MqttClient","streamBuilder","k","that","protocol","username","rejectUnauthorized","topicAliasMaximum","clientId","customHandleAcks","arguments","messageIdProvider","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","_storeProcessingQueue","outgoing","_firstConnection","topicAliasRecv","on","deliver","entry","shift","_resubscribe","send","register","_sendPacket","clearTimeout","clear","_setupReconnect","call","_setupStream","prototype","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","work","done","_handlePacket","_write","buf","enc","parse","streamErrorHandler","message","includes","code","pipe","connectPacket","create","max","bind","authenticationMethod","authenticationData","end","authPacket","reasonCode","setMaxListeners","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handleAuth","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","opts","defaultOpts","qos","retain","dup","publishProc","_nextId","payload","invoke","subscribe","args","Array","i","subs","obj","pop","version","invalidTopic","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscribeProc","subscriptions","topics","sub","granted","unsubscribe","unsubscribeProc","unsubscriptions","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_storePacket","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","handleAuth","validReasonCodes","gotTopic","indexOf","handleMessage","type","response","pubackRC","deallocate","_invokeStoreProcessingQueue","pubrecRC","grantedI","comp","get","pub","allocate","getLastMessageId","getLastAllocated","_resubscribeTopicsKeys","connackPacket","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","_flushStoreProcessingQueue","storeDeliver","read","status","allProcessed","id","_invokeAllStoreProcessingQueue","splice","module","exports"],"sources":["C:/Users/Amali/Desktop/Building_the_IoT_w._P2P_and_Cloud_Computing/IoTProject/node_modules/mqtt/lib/client.js"],"sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\nconst EventEmitter = require('events').EventEmitter\nconst Store = require('./store')\nconst TopicAliasRecv = require('./topic-alias-recv')\nconst TopicAliasSend = require('./topic-alias-send')\nconst mqttPacket = require('mqtt-packet')\nconst DefaultMessageIdProvider = require('./default-message-id-provider')\nconst Writable = require('readable-stream').Writable\nconst inherits = require('inherits')\nconst reInterval = require('reinterval')\nconst clone = require('rfdc/default')\nconst validations = require('./validations')\nconst xtend = require('xtend')\nconst debug = require('debug')('mqttjs:client')\nconst nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback)\n}\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nconst socketErrors = [\n  'ECONNREFUSED',\n  'EADDRINUSE',\n  'ECONNRESET',\n  'ENOTFOUND'\n]\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction applyTopicAlias (client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias\n      if (packet.properties) {\n        alias = packet.properties.topicAlias\n      }\n      const topic = packet.topic.toString()\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias)\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\n              return new Error('Sending Topic Alias out of range')\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic)\n              if (alias) {\n                packet.topic = ''\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias)\n              } else {\n                alias = client.topicAliasSend.getLruAlias()\n                client.topicAliasSend.put(topic, alias)\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias)\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic)\n              if (alias) {\n                packet.topic = ''\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias)\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\n        return new Error('Sending Topic Alias out of range')\n      }\n    }\n  }\n}\n\nfunction removeTopicAliasAndRecoverTopicName (client, packet) {\n  let alias\n  if (packet.properties) {\n    alias = packet.properties.topicAlias\n  }\n\n  let topic = packet.topic.toString()\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias')\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias)\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias')\n      } else {\n        packet.topic = topic\n      }\n    }\n  }\n  if (alias) {\n    delete packet.properties.topicAlias\n  }\n}\n\nfunction sendPacket (client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet)\n  debug('sendPacket :: emitting `packetsend`')\n\n  client.emit('packetsend', packet)\n\n  debug('sendPacket :: writing to stream')\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options)\n  debug('sendPacket :: writeToStream result %s', result)\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.')\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    debug('sendPacket :: invoking cb')\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!(queue))\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction flushVolatile (queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\n  let storePacket = packet\n  let err\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet)\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket)\n    if (err) {\n      return cb && cb(err)\n    }\n  }\n  client.outgoingStore.put(storePacket, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    cbStorePut()\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop (error) {\n  debug('nop ::', error)\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  let k\n  const that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol)\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\n  debug('MqttClient :: options.username', options.username)\n  debug('MqttClient :: options.keepalive', options.keepalive)\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum)\n\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\n\n  debug('MqttClient :: clientId', this.options.clientId)\n\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\n\n  this.streamBuilder = streamBuilder\n\n  this.messageIdProvider = (typeof this.options.messageIdProvider === 'undefined') ? new DefaultMessageIdProvider() : this.options.messageIdProvider\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store()\n  this.incomingStore = options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // Is processing store?\n  this._storeProcessing = false\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {}\n  // Store processing queue\n  this._storeProcessingQueue = []\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // True if connection is first time.\n  this._firstConnection = true\n\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range')\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum)\n    }\n  }\n\n  // Send queued packets\n  this.on('connect', function () {\n    const queue = this.queue\n\n    function deliver () {\n      const entry = queue.shift()\n      debug('deliver :: entry %o', entry)\n      let packet = null\n\n      if (!entry) {\n        that._resubscribe()\n        return\n      }\n\n      packet = entry.packet\n      debug('deliver :: call _sendPacket for %o', packet)\n      let send = true\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false\n        }\n      }\n      if (send) {\n        that._sendPacket(\n          packet,\n          function (err) {\n            if (entry.cb) {\n              entry.cb(err)\n            }\n            deliver()\n          }\n        )\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId)\n        deliver()\n      }\n    }\n\n    debug('connect :: sending queued packets')\n    deliver()\n  })\n\n  this.on('close', function () {\n    debug('close :: connected set to `false`')\n    this.connected = false\n\n    debug('close :: clearing connackTimer')\n    clearTimeout(this.connackTimer)\n\n    debug('close :: clearing ping timer')\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear()\n    }\n\n    debug('close :: calling _setupReconnect')\n    this._setupReconnect()\n  })\n  EventEmitter.call(this)\n\n  debug('MqttClient :: setting up stream')\n  this._setupStream()\n}\ninherits(MqttClient, EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  const that = this\n  const writable = new Writable()\n  const parser = mqttPacket.parser(this.options)\n  let completeParse = null\n  const packets = []\n\n  debug('_setupStream :: calling method to clear reconnect')\n  this._clearReconnect()\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.')\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    if (packets.length) {\n      nextTick(work)\n    } else {\n      const done = completeParse\n      completeParse = null\n      done()\n    }\n  }\n\n  function work () {\n    debug('work :: getting next packet in queue')\n    const packet = packets.shift()\n\n    if (packet) {\n      debug('work :: packet pulled from queue')\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      debug('work :: no packets in queue')\n      const done = completeParse\n      completeParse = null\n      debug('work :: done flag is %s', !!(done))\n      if (done) done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    debug('writable stream :: parsing buffer')\n    parser.parse(buf)\n    work()\n  }\n\n  function streamErrorHandler (error) {\n    debug('streamErrorHandler :: error', error.message)\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error')\n      that.emit('error', error)\n    } else {\n      nop(error)\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream')\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler)\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId)\n    flushVolatile(that.outgoing)\n    debug('stream: emit close to MqttClient')\n    that.emit('close')\n  })\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`')\n  const connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {}\n    }\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max\n    }\n  }\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() =>\n        this.emit('error', new Error('Packet has no Authentication Method')\n        ))\n      return this\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket)\n      sendPacket(this, authPacket)\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\n    this.end({ reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' } })\n    return this\n  }\n  debug('_handlePacket :: emitting packetreceive')\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'auth':\n      this._handleAuth(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    case 'disconnect':\n      this._handleDisconnect(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic)\n  const options = this.options\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  const defaultOpts = { qos: 0, retain: false, dup: false }\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  const that = this\n  const publishProc = function () {\n    let messageId = 0\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId()\n      if (messageId === null) {\n        debug('No messageId left')\n        return false\n      }\n    }\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    }\n\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties\n    }\n\n    debug('publish :: qos', opts.qos)\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        }\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        that._sendPacket(packet, undefined, opts.cbStorePut)\n        break\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        that._sendPacket(packet, callback, opts.cbStorePut)\n        break\n    }\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: publishProc,\n        cbStorePut: opts.cbStorePut,\n        callback: callback\n      }\n    )\n  }\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  const that = this\n  const args = new Array(arguments.length)\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  const subs = []\n  let obj = args.shift()\n  const resubscribe = obj.resubscribe\n  let callback = args.pop() || nop\n  let opts = args.pop()\n  const version = this.options.protocolVersion\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  const invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true')\n    return this\n  }\n\n  const defaultOpts = {\n    qos: 0\n  }\n  if (version === 5) {\n    defaultOpts.nl = false\n    defaultOpts.rap = false\n    defaultOpts.rh = 0\n  }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic)\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) ||\n        that._resubscribeTopics[topic].qos < opts.qos ||\n          resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        }\n        if (version === 5) {\n          currentOpts.nl = opts.nl\n          currentOpts.rap = opts.rap\n          currentOpts.rh = opts.rh\n          currentOpts.properties = opts.properties\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\n        subs.push(currentOpts)\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        debug('subscribe: object topic %s', k)\n        if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) ||\n          that._resubscribeTopics[k].qos < obj[k].qos ||\n            resubscribe) {\n          const currentOpts = {\n            topic: k,\n            qos: obj[k].qos\n          }\n          if (version === 5) {\n            currentOpts.nl = obj[k].nl\n            currentOpts.rap = obj[k].rap\n            currentOpts.rh = obj[k].rh\n            currentOpts.properties = opts.properties\n          }\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\n          subs.push(currentOpts)\n        }\n      })\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return this\n  }\n\n  const subscribeProc = function () {\n    const messageId = that._nextId()\n    if (messageId === null) {\n      debug('No messageId left')\n      return false\n    }\n\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    }\n\n    if (opts.properties) {\n      packet.properties = opts.properties\n    }\n\n    // subscriptions to resubscribe to in case of disconnect\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true')\n      const topics = []\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = { qos: sub.qos }\n          if (version === 5) {\n            topic.nl = sub.nl || false\n            topic.rap = sub.rap || false\n            topic.rh = sub.rh || 0\n            topic.properties = sub.properties\n          }\n          that._resubscribeTopics[sub.topic] = topic\n          topics.push(sub.topic)\n        }\n      })\n      that.messageIdToTopic[packet.messageId] = topics\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i]\n          }\n        }\n\n        callback(err, subs)\n      }\n    }\n    debug('subscribe :: call _sendPacket')\n    that._sendPacket(packet)\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: subscribeProc,\n        callback: callback\n      }\n    )\n  }\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  const that = this\n  const args = new Array(arguments.length)\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  let topic = args.shift()\n  let callback = args.pop() || nop\n  let opts = args.pop()\n  if (typeof topic === 'string') {\n    topic = [topic]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  const invalidTopic = validations.validateTopics(topic)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (that._checkDisconnecting(callback)) {\n    return this\n  }\n\n  const unsubscribeProc = function () {\n    const messageId = that._nextId()\n    if (messageId === null) {\n      debug('No messageId left')\n      return false\n    }\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    }\n\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic]\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic\n    }\n\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic]\n      })\n    }\n\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    }\n\n    debug('unsubscribe: call _sendPacket')\n    that._sendPacket(packet)\n\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: unsubscribeProc,\n        callback: callback\n      }\n    )\n  }\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this\n\n  debug('end :: (%s)', this.options.clientId)\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop\n    opts = force\n    force = false\n    if (typeof opts !== 'object') {\n      cb = opts\n      opts = null\n      if (typeof cb !== 'function') {\n        cb = nop\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts\n    opts = null\n  }\n\n  debug('end :: cb? %s', !!cb)\n  cb = cb || nop\n\n  function closeStores () {\n    debug('end :: closeStores: closing incoming and outgoing stores')\n    that.disconnected = true\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end')\n        that.emit('end')\n        if (cb) {\n          const err = e1 || e2\n          debug('end :: closeStores: invoking callback with args')\n          cb(err)\n        }\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores')\n      // const boundProcess = nextTick.bind(null, closeStores)\n      nextTick(closeStores.bind(that))\n    }, opts)\n  }\n\n  if (this.disconnecting) {\n    cb()\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastAllocated());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  delete this.outgoing[messageId]\n  this.outgoingStore.del({ messageId: messageId }, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect')\n  const that = this\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client')\n  this.emit('reconnect')\n  if (this.connected) {\n    this.end(() => { this._setupStream() })\n    debug('client already connected. disconnecting first.')\n  } else {\n    debug('_reconnect: calling _setupStream')\n    this._setupStream()\n  }\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  const that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state')\n      this.emit('offline')\n      debug('_setupReconnect :: set `reconnecting` to `true`')\n      this.reconnecting = true\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!')\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  } else {\n    debug('_setupReconnect :: doing nothing...')\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer')\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2]\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close')\n    this.stream.on('close', done)\n  }\n\n  debug('_cleanUp :: forced? %s', forced)\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\n    this.stream.destroy()\n  } else {\n    const packet = xtend({ cmd: 'disconnect' }, opts)\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\n    this._sendPacket(\n      packet,\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer')\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\n  cbStorePut = cbStorePut || nop\n  cb = cb || nop\n\n  const err = applyTopicAlias(this, packet)\n  if (err) {\n    cb(err)\n    return\n  }\n\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval()\n      sendPacket(this, packet, cb)\n      return\n    }\n\n    debug('_sendPacket :: client not connected. Storing packet offline.')\n    this._storePacket(packet, cb, cbStorePut)\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\n}\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet)\n  debug('_storePacket :: cb? %s', !!cb)\n  cbStorePut = cbStorePut || nop\n\n  let storePacket = packet\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet)\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket)\n    if (err) {\n      return cb && cb(err)\n    }\n  }\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if (((storePacket.qos || 0) === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {\n    this.queue.push({ packet: storePacket, cb: cb })\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err)\n      }\n      cbStorePut()\n    })\n  } else if (cb) {\n    cb(new Error('No connection to broker'))\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\n  const that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...')\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true')\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack')\n  const options = this.options\n  const version = options.protocolVersion\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  clearTimeout(this.connackTimer)\n  delete this.topicAliasSend\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'))\n        return\n      }\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum)\n      }\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive\n      this._shiftPingInterval()\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this._onConnect(packet)\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options\n  const version = options.protocolVersion\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version)\n    err.code = rc\n    this.emit('error', err)\n    return\n  }\n\n  const that = this\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err)\n      return\n    }\n\n    if (rc === 24) {\n      that.reconnecting = false\n      that._sendPacket(packet)\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc])\n      err.code = rc\n      that.emit('error', error)\n    }\n  })\n}\n\n/**\n * @param packet the packet received by the broker\n * @return the auth packet to be returned to the broker\n * @api public\n */\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet)\n  done = typeof done !== 'undefined' ? done : nop\n  let topic = packet.topic.toString()\n  const message = packet.payload\n  const qos = packet.qos\n  const messageId = packet.messageId\n  const that = this\n  const options = this.options\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\n  if (this.options.protocolVersion === 5) {\n    let alias\n    if (packet.properties) {\n      alias = packet.properties.topicAlias\n    }\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias)\n          if (gotTopic) {\n            topic = gotTopic\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias)\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias)\n            this.emit('error', new Error('Received unregistered Topic Alias'))\n            return\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\n          this.emit('error', new Error('Received Topic Alias is out of range'))\n          return\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias)\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\n          this.emit('error', new Error('Received Topic Alias is out of range'))\n          return\n        }\n      }\n    }\n  }\n  debug('_handlePublish: qos %d', qos)\n  switch (qos) {\n    case 2: {\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\n        if (code) {\n          that._sendPacket({ cmd: 'pubrec', messageId: messageId, reasonCode: code }, done)\n        } else {\n          that.incomingStore.put(packet, function () {\n            that._sendPacket({ cmd: 'pubrec', messageId: messageId }, done)\n          })\n        }\n      })\n      break\n    }\n    case 1: {\n      // emit the message event\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\n        if (!code) { that.emit('message', topic, message, packet) }\n        that.handleMessage(packet, function (err) {\n          if (err) {\n            return done && done(err)\n          }\n          that._sendPacket({ cmd: 'puback', messageId: messageId, reasonCode: code }, done)\n        })\n      })\n      break\n    }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.')\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId\n  const type = packet.cmd\n  let response = null\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  const that = this\n  let err\n\n  // Checking `!cb` happens to work, but it's not technically \"correct\".\n  //\n  // Why? This code assumes that \"no callback\" is the same as that \"we're not\n  // waiting for responses\" (puback, pubrec, pubcomp, suback, or unsuback).\n  //\n  // It would be better to check `if (!this.outgoing[messageId])` here, but\n  // there's no reason to change it and risk (another) regression.\n  //\n  // The only reason this code works is becaues code in MqttClient.publish,\n  // MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will\n  // have a callback even if the user doesn't pass one in.)\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type)\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback': {\n      const pubackRC = packet.reasonCode\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC])\n        err.code = pubackRC\n        cb(err, packet)\n      }\n      delete this.outgoing[messageId]\n      this.outgoingStore.del(packet, cb)\n      this.messageIdProvider.deallocate(messageId)\n      this._invokeStoreProcessingQueue()\n      break\n    }\n    case 'pubrec': {\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      }\n      const pubrecRC = packet.reasonCode\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC])\n        err.code = pubrecRC\n        cb(err, packet)\n      } else {\n        this._sendPacket(response)\n      }\n      break\n    }\n    case 'suback': {\n      delete this.outgoing[messageId]\n      this.messageIdProvider.deallocate(messageId)\n      for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          const topics = this.messageIdToTopic[messageId]\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic]\n            })\n          }\n        }\n      }\n      this._invokeStoreProcessingQueue()\n      cb(null, packet)\n      break\n    }\n    case 'unsuback': {\n      delete this.outgoing[messageId]\n      this.messageIdProvider.deallocate(messageId)\n      this._invokeStoreProcessingQueue()\n      cb(null)\n      break\n    }\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet')\n  callback = typeof callback !== 'undefined' ? callback : nop\n  const messageId = packet.messageId\n  const that = this\n\n  const comp = { cmd: 'pubcomp', messageId: messageId }\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.incomingStore.del(pub, nop)\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet)\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate()\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated()\n}\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe')\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n  if (!this._firstConnection &&\n      (this.options.clean || (this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent)) &&\n      _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5')\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {}\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\n          resubscribeTopic.resubscribe = true\n          this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties })\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      }\n    } else {\n      this._resubscribeTopics = {}\n    }\n  }\n\n  this._firstConnection = false\n}\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet)\n    return\n  }\n\n  const that = this\n\n  this.connackPacket = packet\n  this.messageIdProvider.clear()\n  this._setupPingTimer()\n\n  this.connected = true\n\n  function startStreamProcess () {\n    let outStore = that.outgoingStore.createStream()\n\n    function clearStoreProcessing () {\n      that._storeProcessing = false\n      that._packetIdsDuringStoreProcessing = {}\n    }\n\n    that.once('close', remove)\n    outStore.on('error', function (err) {\n      clearStoreProcessing()\n      that._flushStoreProcessingQueue()\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n      that._flushStoreProcessingQueue()\n      clearStoreProcessing()\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n      that._storeProcessing = true\n\n      const packet = outStore.read(1)\n\n      let cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver()\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n        }\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet)\n        } else {\n          debug('messageId: %d has already used.', packet.messageId)\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    outStore.on('end', function () {\n      let allProcessed = true\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false\n          break\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing()\n        that.removeListener('close', remove)\n        that._invokeAllStoreProcessingQueue()\n        that.emit('connect', packet)\n      } else {\n        startStreamProcess()\n      }\n    })\n    storeDeliver()\n  }\n  // start flowing\n  startStreamProcess()\n}\n\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0]\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift()\n      return true\n    }\n  }\n  return false\n}\n\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) { /* empty */ }\n}\n\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'))\n    if (f.callback) f.callback(new Error('Connection closed'))\n  }\n  this._storeProcessingQueue.splice(0)\n}\n\nmodule.exports = MqttClient\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}