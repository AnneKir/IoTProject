import { BehaviorSubject } from 'rxjs';
import freeice from 'freeice';
import SimplePeer from 'simple-peer';
import uid from 'uid-safe';
import { Stack } from 'typed-structures';
import React from 'react';
import filterReactProps from 'filter-react-props';
import { deflate_encode_raw, deflate_decode_raw } from 'wasm-flate';

var getSignalData = function getSignalData(peerConnection) {
  try {
    return Promise.resolve(new Promise(function (resolve, reject) {
      try {
        if (peerConnection) peerConnection.on('signal', function (data) {
          return resolve(data);
        });
      } catch (e) {
        reject(e);
      }
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var processOfferRequest = function processOfferRequest(request) {
  try {
    var state = ReactSimplePeerState.value;

    if (ReactSimplePeerStatusState.value !== Status.IDLE) {
      state.joinRequests.stack(request);
      ReactSimplePeerState.next(state);
      return Promise.resolve();
    }

    ReactSimplePeerStatusState.next(Status.EMITTING_OFFER);
    var config = {
      initiator: true,
      trickle: false,
      config: {
        iceServers: freeice()
      }
    };

    if (state.model.stream) {
      config.stream = state.model.stream;
    }

    state.peerConnection = new SimplePeer(config);
    state.peerConnection.on('stream', function (stream) {
      try {
        var localState = ReactSimplePeerState.value;

        var _temp2 = function () {
          if (localState.connections.get(request.peerId)) {
            var connection = localState.connections.get(request.peerId);
            return Promise.resolve(stream).then(function (_stream) {
              connection.model.stream = _stream;
              localState.connections.set(request.peerId, connection);
              ReactSimplePeerState.next(localState);
            });
          }
        }();

        return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    });
    return Promise.resolve(getSignalData(state.peerConnection)).then(function (_getSignalData) {
      state.signalData = _getSignalData;
      state.emitOfferResponse(request, state.signalData);
      ReactSimplePeerState.next(state);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var initState = {
  id:
  /*#__PURE__*/
  uid.sync(15),
  peers: {},
  // Room assignment left to createRoom implementation
  // Since users may want to base it on something business related
  room: null,
  roomCreatorId: null,
  signalData: {},
  connections:
  /*#__PURE__*/
  new Map(),
  peerConnection:
  /*#__PURE__*/
  new SimplePeer(),
  commands:
  /*#__PURE__*/
  new Map(),
  model: {
    connection:
    /*#__PURE__*/
    new SimplePeer(),
    stream: null
  },
  joinRequests:
  /*#__PURE__*/
  new Stack(),
  clientOffers:
  /*#__PURE__*/
  new Stack(),
  emitJoinRequest: function emitJoinRequest() {},
  emitOfferResponse: function emitOfferResponse() {},
  emitInitiatorOffers: function emitInitiatorOffers() {},
  emitJoinAck: function emitJoinAck() {}
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var JoinRoomButton =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(JoinRoomButton, _React$Component);

  function JoinRoomButton() {
    var _this;

    _this = _React$Component.apply(this, arguments) || this;
    _this.state = {};
    return _this;
  }

  var _proto = JoinRoomButton.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var state = ReactSimplePeerState.value;
    state.emitJoinRequest = this.props.join;
    ReactSimplePeerState.next(state);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        join = _this$props.join,
        children = _this$props.children,
        room = _this$props.room,
        _onClick = _this$props.onClick;
    return React.createElement("button", Object.assign({}, filterReactProps(this.props), {
      onClick: function onClick(e) {
        setRoom(room);
        join();

        if (_onClick) {
          _onClick(e);
        }
      }
    }), children);
  };

  return JoinRoomButton;
}(React.Component);

function parse(data, state) {
  var senderId = data.substr(0, 20);
  var command = data.substr(20, 20);

  if (state.commands.get(command)) {
    try {
      state.commands.get(command)(senderId, data.substr(40), state);
    } catch (e) {
      console.warn(e);
    }
  }

  return senderId;
}

var send = function send(pc, command, data) {
  try {
    try {
      pc.send(deflate_encode_raw(new Uint8Array(Buffer.from("" + ReactSimplePeerState.value.id + command + data))));
      return Promise.resolve(true);
    } catch (e) {
      console.warn('An error occurred when trying to send data to peer: Failed to reach peer');
      return Promise.resolve(false);
    }
  } catch (e) {
    return Promise.reject(e);
  }
};

function handlePeerConnection(pc, openConnectionAsInitiator) {
  pc.on('connect', function () {
    try {
      var _temp3 = function _temp3() {
        var state = ReactSimplePeerState.value;
        var model = state.model;
        var peers = Array.from(state.connections.keys());
        return Promise.resolve(send(pc, 'SYNC_MODEL_DATA_____', JSON.stringify({
          model: model,
          peers: peers
        }))).then(function () {});
      };

      var _temp4 = function () {
        if (openConnectionAsInitiator) {
          return Promise.resolve(send(pc, 'OPEN_CNTS_AS_INIT___', JSON.stringify(ReactSimplePeerState.value.peers))).then(function () {});
        }
      }();

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
    } catch (e) {
      return Promise.reject(e);
    }
  });
  pc.on('data', function (data) {
    if (!pc.initiator && ReactSimplePeerState.value.connections.size === 0) {
      ReactSimplePeerStatusState.next(Status.CONNECTING_TO_EXISTING_PEERS);
    }

    parse(new TextDecoder('utf-8').decode(deflate_decode_raw(data)), ReactSimplePeerState.value);
    ReactSimplePeerState.next(ReactSimplePeerState.value);
  });
}

var createExistingPeersOffers = function createExistingPeersOffers(peers, state) {
  try {
    return Promise.resolve(Promise.all(Object.entries(peers).filter(function (set) {
      return set[0] !== state.id;
    }).map(function (set) {
      try {
        var config = {
          initiator: true,
          trickle: false,
          config: {
            iceServers: freeice()
          }
        };

        if (state.model.stream) {
          config.stream = state.model.stream;
        }

        var pc = new SimplePeer(config);
        handlePeerConnection(pc, false);
        pc.on('stream', function (stream) {
          try {
            var _temp2 = function () {
              if (state.connections.get(set[0])) {
                return Promise.resolve(stream).then(function (_stream) {
                  state.connections.get(set[0]).model.stream = _stream;
                });
              }
            }();

            return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
          } catch (e) {
            return Promise.reject(e);
          }
        });
        return Promise.resolve(getSignalData(pc)).then(function (signalData) {
          set.splice(1, 1, signalData);
          var connection = state.connections.get(set[0]);
          state.connections.set(set[0], connection || {
            model: {
              connection: pc,
              stream: null
            },
            peers: []
          });
          ReactSimplePeerState.next(state);
          return set;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }))).then(Object.fromEntries);
  } catch (e) {
    return Promise.reject(e);
  }
};

var openConnectionsAsInitiator = function openConnectionsAsInitiator(_, data, state) {
  try {
    var peers = JSON.parse(data);

    var _temp2 = function () {
      if (Object.entries(peers).length) {
        return Promise.resolve(createExistingPeersOffers(peers, state)).then(function (offers) {
          state.emitInitiatorOffers(offers, state.id, state.room);
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
};

function syncModelData(senderId, data, state) {
  if (state.connections.get(senderId)) {
    var syncData = JSON.parse(data);
    var model = state.connections.get(senderId).model;
    state.connections.set(senderId, {
      peers: syncData.peers,
      model: _extends({}, syncData.model, {
        connection: model.connection,
        stream: model.stream
      })
    });
    ReactSimplePeerState.next(state);
  }
}

var processJoinResponse = function processJoinResponse(offer, id, room) {
  try {
    var state = ReactSimplePeerState.value;

    if (state.connections.size === 0) {
      ReactSimplePeerStatusState.next(Status.RECEIVING_RESPONSE_ACCESS);
    }

    var config = {
      initiator: false,
      trickle: false,
      config: {
        iceServers: freeice()
      }
    };

    if (state.model.stream) {
      config.stream = state.model.stream;
    }

    state.peerConnection = new SimplePeer(config);
    state.peerConnection.on('stream', function (stream) {
      if (id) {
        state.connections.set(id, {
          model: {
            connection: state.peerConnection,
            stream: stream
          },
          peers: []
        });
      }
    });
    state.peerConnection.signal(offer);
    return Promise.resolve(getSignalData(state.peerConnection)).then(function (signalData) {
      if (state.connections.size === 0) {
        ReactSimplePeerStatusState.next(Status.JOINING_SESSION);
      }

      state.emitJoinAck(signalData, room, id, state.id);
      handlePeerConnection(state.peerConnection, false);
      ReactSimplePeerState.next(state);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function processClientOffer(data, id, roomCreator, emitterPeerId) {
  var state = ReactSimplePeerState.value;

  if (roomCreator) {
    handlePeerConnection(state.peerConnection, true);
    var connection = state.connections.get(emitterPeerId);
    state.connections.set(emitterPeerId, connection || {
      model: {
        connection: state.peerConnection,
        stream: null
      },
      peers: []
    });
    ReactSimplePeerState.next(state);
  }

  if (id && state.connections.get(emitterPeerId)) {
    var peerConnection = state.connections.get(emitterPeerId);
    handlePeerConnection(peerConnection.model.connection, false);
    state.peerConnection = peerConnection.model.connection;
    ReactSimplePeerState.next(state);
  }

  var retry = function retry() {
    try {
      var _temp2 = function _temp2(_send) {
        if (!relayPeer || relayPeer && !_send) {
          setTimeout(function () {
            return Promise.resolve(retry());
          }, Math.ceil(Math.random() * 1000));
        }
      };

      var relayPeer = Array.from(ReactSimplePeerState.value.connections.values()).find(function (peer) {
        return peer.peers.includes(emitterPeerId);
      });
      return Promise.resolve(!relayPeer || !relayPeer ? _temp2(!relayPeer || relayPeer && send(relayPeer.model.connection, 'TELL_HIM_TO_RETRY___', emitterPeerId)) : Promise.resolve(!relayPeer || relayPeer && send(relayPeer.model.connection, 'TELL_HIM_TO_RETRY___', emitterPeerId)).then(_temp2));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  state.peerConnection.on('error', function (e) {
    try {
      if (e.code === 'ERR_SET_REMOTE_DESCRIPTION') {
        console.warn('Encountered an error while trying to signal incoming offer, retrying');
        setTimeout(function () {
          return Promise.resolve(retry());
        }, Math.ceil(Math.random() * 1000));
        return Promise.resolve();
      }

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  });
  state.peerConnection.signal(data.offer);
  state.peers = data.peers;
  ReactSimplePeerStatusState.next(Status.IDLE);
  ReactSimplePeerState.next(state);
}

var initiatorOffer = function initiatorOffer(_, str, state) {
  try {
    var data = JSON.parse(str);
    var offer = JSON.parse(data.offer);
    var id = data.id;
    var config = {
      initiator: false,
      trickle: false,
      config: {
        iceServers: freeice()
      }
    };

    if (state.model.stream) {
      config.stream = state.model.stream;
    }

    var peerConnection = new SimplePeer(config);
    peerConnection.signal(offer);
    return Promise.resolve(getSignalData(state.peerConnection)).then(function (signalData) {
      send(peerConnection, 'NON_INITIATOR_OFFER_', JSON.stringify({
        id: state.id,
        offer: signalData
      }));
      handlePeerConnection(peerConnection, false);
      var connection = state.connections.get(id);
      state.connections.set(id, connection || {
        model: {
          connection: peerConnection,
          stream: null
        },
        peers: []
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var nonInitiatorOffer = function nonInitiatorOffer(_, str, state) {
  try {
    var data = JSON.parse(str);
    var offer = data.offer;
    var id = data.id;
    handlePeerConnection(state.peerConnection, true);
    var connection = state.connections.get(id);
    state.connections.set(id, connection || {
      model: {
        connection: state.peerConnection,
        stream: null
      },
      peers: []
    });
    state.peerConnection.signal(offer);
    ReactSimplePeerState.next(state);
    return Promise.resolve();
  } catch (e) {
    return Promise.reject(e);
  }
};

var tellHimToRetry = function tellHimToRetry(_, data, state) {
  try {
    var target = state.connections.get(data);

    var _temp2 = function () {
      if (target) {
        return Promise.resolve(send(target.model.connection, 'RETRY_______________')).then(function () {});
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
};

function retry(_, _1, state) {
  ReactSimplePeerState.next(initState);
  setTimeout(function () {
    return state.emitJoinRequest();
  }, Math.ceil(Math.random() * 1000));
}

var Setup =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Setup, _React$Component);

  function Setup(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {};
    var _this$props = _this.props,
        onJoinResponse = _this$props.onJoinResponse,
        onClientOffer = _this$props.onClientOffer,
        onOfferRequest = _this$props.onOfferRequest,
        onLeaving = _this$props.onLeaving,
        emitOfferResponse = _this$props.emitOfferResponse,
        emitInitiatorOffers = _this$props.emitInitiatorOffers,
        emitJoinAck = _this$props.emitJoinAck;
    var state = ReactSimplePeerState.value;
    state.commands.set('OPEN_CNTS_AS_INIT___', openConnectionsAsInitiator);
    state.commands.set('SYNC_MODEL_DATA_____', syncModelData);
    state.commands.set('INITIATOR_OFFER_____', initiatorOffer);
    state.commands.set('NON_INITIATOR_OFFER_', nonInitiatorOffer);
    state.commands.set('TELL_HIM_TO_RETRY___', tellHimToRetry);
    state.commands.set('RETRY_______________', retry);
    state.emitOfferResponse = emitOfferResponse;
    state.emitInitiatorOffers = emitInitiatorOffers;
    state.emitJoinAck = emitJoinAck;
    onOfferRequest(processOfferRequest);
    onJoinResponse(processJoinResponse);
    onClientOffer(processClientOffer);
    onLeaving(function () {
      return console.log('TODO: Implement processLeaving');
    });
    ReactSimplePeerState.next(state);
    return _this;
  }

  var _proto = Setup.prototype;

  _proto.render = function render() {
    return this.props.children || React.createElement(React.Fragment, null);
  };

  return Setup;
}(React.Component);

var Peers =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Peers, _React$Component);

  function Peers() {
    var _this;

    _this = _React$Component.apply(this, arguments) || this;
    _this.state = {
      connections: []
    };
    return _this;
  }

  var _proto = Peers.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    ReactSimplePeerState.subscribe(function (state) {
      _this2.setState({
        connections: Array.from(state.connections).map(function (set) {
          return set[1].model;
        })
      });
    });
  };

  _proto.render = function render() {
    var children = this.props.children;
    return children(this.state.connections) || React.createElement(React.Fragment, null);
  };

  return Peers;
}(React.Component);

var ReactSimplePeerStatus = {
  IDLE: 'Waiting for peers',
  EMITTING_OFFER: 'Emitting offer',
  REQUESTING_ACCESS: 'Requesting access',
  RECEIVING_RESPONSE_ACCESS: 'Receiving response access',
  CONNECTING_TO_EXISTING_PEERS: 'Connecting to existing peers',
  JOINING_SESSION: 'Joining session'
};

var State =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(State, _React$Component);

  function State() {
    var _this;

    _this = _React$Component.apply(this, arguments) || this;
    _this.state = {
      value: ''
    };
    return _this;
  }

  var _proto = State.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    ReactSimplePeerStatusState.subscribe(function (status) {
      try {
        _this2.setState({
          value: ReactSimplePeerStatus[status]
        });

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
  };

  _proto.render = function render() {
    return React.createElement(React.Fragment, null, this.state.value);
  };

  return State;
}(React.Component);

var PeerVideo =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(PeerVideo, _React$Component);

  function PeerVideo() {
    var _this;

    _this = _React$Component.apply(this, arguments) || this;
    _this.state = {
      stream: null
    };
    _this.video = document.createElement('video');
    return _this;
  }

  var _proto = PeerVideo.prototype;

  _proto.componentDidUpdate = function componentDidUpdate() {
    try {
      var _this3 = this;

      return Promise.resolve(_this3.props.peer.stream).then(function (_this2$props$peer$str) {
        _this3.video.srcObject = _this2$props$peer$str;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.render = function render() {
    var _this4 = this;

    return React.createElement("video", Object.assign({}, filterReactProps(this.props), {
      autoPlay: true,
      muted: true,
      ref: function ref(video) {
        _this4.video = video;
      }
    }));
  };

  return PeerVideo;
}(React.Component);

var ClientOffer = function ClientOffer(offer, peers) {
  this.offer = offer;
  this.peers = peers;
};

var JoinRequest = function JoinRequest(roomId, peerId) {
  this.roomId = roomId;
  this.peerId = peerId;
};

var Status;

(function (Status) {
  Status["IDLE"] = "IDLE";
  Status["EMITTING_OFFER"] = "EMITTING_OFFER";
  Status["REQUESTING_ACCESS"] = "REQUESTING_ACCESS";
  Status["RECEIVING_RESPONSE_ACCESS"] = "RECEIVING_RESPONSE_ACCESS";
  Status["CONNECTING_TO_EXISTING_PEERS"] = "CONNECTING_TO_EXISTING_PEERS";
  Status["JOINING_SESSION"] = "JOINING_SESSION";
})(Status || (Status = {}));

var ReactSimplePeerStatusState =
/*#__PURE__*/
new BehaviorSubject(Status.IDLE);
var ReactSimplePeerState =
/*#__PURE__*/
new BehaviorSubject(initState);
function setModel(model) {
  var state = ReactSimplePeerState.value;
  state.model = model;
  ReactSimplePeerState.next(state);
}
function setRoom(room) {
  var state = ReactSimplePeerState.value;
  state.room = room;
  ReactSimplePeerState.next(state);
}
function getId() {
  return ReactSimplePeerState.value.id;
}
ReactSimplePeerStatusState.subscribe(function (status) {
  try {
    if (status === Status.IDLE && ReactSimplePeerState.value.joinRequests.length()) {
      var state = ReactSimplePeerState.value;
      console.log(state.joinRequests.length());
      var joinRequest = state.joinRequests.unstack();
      console.log(state.joinRequests.length());
      ReactSimplePeerState.next(state);
      setTimeout(function () {
        try {
          return Promise.resolve(processOfferRequest(joinRequest));
        } catch (e) {
          return Promise.reject(e);
        }
      }, Math.ceil(Math.random() * 1000));
    }

    return Promise.resolve();
  } catch (e) {
    return Promise.reject(e);
  }
});

export { ClientOffer, JoinRequest, JoinRoomButton, PeerVideo, Peers, ReactSimplePeerState, ReactSimplePeerStatusState, Setup, State, Status, getId, setModel, setRoom };
//# sourceMappingURL=react-simple-peer.esm.js.map
